大家好，我是小康。

#### 前言

大家有没有想过，为什么在图书馆里，有的人一进门就能开始看书，而有人想动笔修改点东西，却要等到没人打扰的时候才能开始？其实，在我们的程序世界里，也有这么一套“读者优先、写者稍等”的规则。这套规则就是——**读写锁**。


那么，**读写锁到底是干啥的？** 今天咱们就来深入聊聊这个有趣的概念，讲得透彻、举例形象，让你彻底搞懂！

### 一、什么是读写锁？一个生活化的类比
想象你是图书馆管理员，你要管理的是一间满是资料的图书馆。这个图书馆的规则有点特别：

1. **读者**（来阅读资料的人）可以随便进出——只要图书馆里已经有读者，他们可以再进去，反正读书不会改动书的内容。
2. **作者**（要修改资料的人）则不同，一旦他们进来开始动笔，就不能有任何人在旁边读书了，因为你要确保修改过程不会被打扰到。

**读写锁 **正是用来管理这些读者和作者的：它让读者线程可以同时读取数据，而当写者线程出现时，大家都得暂停，给写者线程腾出一个独占的空间。

### 二、为什么不用普通的互斥锁？
可能你会好奇：为啥我们不用普通的**互斥锁**呢？答案很简单：效率！

普通互斥锁是一种“无差别锁”，无论你是读还是写，都得等待。对于“读多写少”的场景，互斥锁会浪费大量时间在“等”上面。而读写锁则聪明地拆分了读和写的权限，允许多个读者同时进行阅读，只有当写者来时，才会让大家停下来等他写完。

### 三、读写锁的基本接口
在 Linux 的 `pthread` 库中，我们可以用 `pthread_rwlock_init` 来初始化一个读写锁，用 `pthread_rwlock_rdlock` 和 `pthread_rwlock_wrlock` 分别对读锁和写锁进行上锁，用 `pthread_rwlock_unlock` 来解锁。

需要注意的是，读写锁允许多个线程同时获取读锁（读取数据），但在写锁被持有时，其他线程无法获取读锁或写锁。

```c++

pthread_rwlock_t rwlock;
pthread_rwlock_init(&rwlock, NULL);  // 初始化读写锁

pthread_rwlock_rdlock(&rwlock);      // 获取读锁
// 读取共享资源
pthread_rwlock_unlock(&rwlock);      // 释放读锁

pthread_rwlock_wrlock(&rwlock);      // 获取写锁
// 修改共享资源
pthread_rwlock_unlock(&rwlock);      // 释放写锁

pthread_rwlock_destroy(&rwlock);     // 销毁读写锁
```



这样你就可以用 `pthread_rwlock_rdlock` 和 `pthread_rwlock_wrlock` 分别控制读写权限，帮助更高效地管理共享资源。

### 四、读写锁的代码示例
接下来，让我们看看读写锁在实际代码中的使用。以下是一个简单的 C 语言示例：

```c++

pthread_rwlock_t rwlock; // 声明一个读写锁
int shared_data = 0;

void* reader(void* arg) {
    pthread_rwlock_rdlock(&rwlock); // 申请读锁
    printf("Reader: Reading shared data: %d\n", shared_data);
    pthread_rwlock_unlock(&rwlock); // 释放读锁
    return NULL;
}

void* writer(void* arg) {
    pthread_rwlock_wrlock(&rwlock); // 申请写锁
    shared_data++; // 修改共享数据
    printf("Writer: Writing shared data: %d\n", shared_data);
    pthread_rwlock_unlock(&rwlock); // 释放写锁
    return NULL;
}

int main() {
    pthread_t readers[3], writer_thread;
    pthread_rwlock_init(&rwlock, NULL); // 初始化读写锁

    for (int i = 0; i < 3; i++) {
        pthread_create(&readers[i], NULL, reader, NULL); // 创建读线程
    }
    pthread_create(&writer_thread, NULL, writer, NULL); // 创建写线程

    for (int i = 0; i < 3; i++) {
        pthread_join(readers[i], NULL); // 等待读线程完成
    }
    pthread_join(writer_thread, NULL); // 等待写线程完成

    pthread_rwlock_destroy(&rwlock); // 销毁读写锁
    return 0;
}
```

在这个代码示例中，我们用了一个 **读写锁 **来控制对共享数据`shared_data`的访问：

1. **读线程 **使用`pthread_rwlock_rdlock`来获取读锁。
2. **写线程 **使用`pthread_rwlock_wrlock`来获取写锁。

当多个读线程读取数据时，它们可以同时执行，不会互相阻塞；而当写线程需要修改数据时，读线程和其他写线程都必须等待。

### 五、读写锁的优缺点
**优点**：

+ **并发性能高**：多个读线程可以同时读取数据，提高了并发性能。
+ **适合读多写少的场景**：在读操作频繁的环境下，可以减少锁争用，提高效率。

**缺点**：

+ **有可能造成“写者饥饿”**：如果读操作过多，写线程可能长时间无法获取写锁，导致“写饥饿”。
+ **适用场景有限**：在读写频率差不多或者写操作很多的场景下，读写锁的性能优势不明显。  



### 六、读写锁的应用场景：什么时候用读写锁？
读写锁的“本事”就是分开读和写的权限，适合“读多写少”的场景，让大家可以一起读，但写的时候就得让出空间。具体来说，读写锁适合下面这些情况：

1. **读的多、写的少**：如果你有个数据很多线程都需要读，只有少量线程需要改，那用读写锁就很合适。多个线程可以一起读，只有当有人要改数据时，才会让其他人暂停，比如配置文件、缓存数据等，读写锁可以让读的速度快，又不妨碍写操作。
2. **日志系统**：日志系统里，通常会有很多线程在读取日志进行分析，只有少数线程会添加新的日志内容。用读写锁，读取日志的线程可以同时工作，写日志的线程则能独占写入，避免冲突。
3. **状态信息**：有些系统里的状态信息是给多个线程读取的，比如一些共享的统计数据，读取很频繁，但更新很少。读写锁能让多个线程同时读取，而当状态需要更新时，写锁可以保证独占。



**简单说**，读写锁特别适合“读多写少”的情况。当有很多读线程需要频繁访问数据而写线程很少时，读写锁可以显著提升效率，多个读线程可以同时读取，省去了等待时间。注意，如果读和写的频率差不多，那用读写锁可能会导致写线程“饥饿”，这种情况可能就要换别的锁，比如互斥锁。

### 七、总结

读写锁是一种专为**读多写少**场景设计的锁，它灵活地允许多个读者同时读取数据，而当写者出现时，才会把其他读者排在一旁等候。使用读写锁可以有效地提升并发性能，但在设计中也要注意可能的“写饥饿”问题。

希望今天这篇文章能让你彻底理解什么是读写锁！下次遇到这类面试题，拿出你的图书馆管理员思维，从容应对！

## 最后：

如果这篇文章帮你轻松搞懂了互斥锁，记得点个在看和赞👍，也可以分享给身边的小伙伴，让更多人一起进步！另外，欢迎关注我的公众号「**跟着小康学编程**」，这里会持续更新更多编程干货，每周带你轻松掌握各种技术难点！


#### 关注我能学到什么？

- 这里分享 Linux C、C++、Go 开发、计算机基础知识 和 编程面试干货等，内容深入浅出，让技术学习变得轻松有趣。

- 无论您是备战面试，还是想提升编程技能，这里都致力于提供实用、有趣、有深度的技术分享。快来关注，让我们一起成长！

#### 怎么关注我的公众号？

**非常简单！扫描下方二维码即可一键关注。**

![](https://files.mdnice.com/user/48364/65158d3c-cd38-4604-861a-8f0379066dc0.png)

此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！

![](https://files.mdnice.com/user/48364/971ccaa3-8f57-4e33-8bc9-d0863eeade81.png)




