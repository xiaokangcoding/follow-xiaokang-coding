
# 前言：互斥锁，其实一点都不难！

大家好，我是小康。

你有没有碰到过这种情况？明明一段代码刚跑得好好的，加了个新功能，程序立马开始“叽叽咕咕”，各种错误频频冒出。仔细一看，原来是**多个线程抢着用同一个资源**，导致数据乱套！😵‍💫

这时候，我们就得用上 **互斥锁（Mutex）** 了。  
别被名字吓到，其实它就像程序里的“厕所门锁”——每次只允许一个线程进去，其他人排队等候，保证数据不被同时修改，程序才能稳稳当当地运行。

今天这篇文章，我会用最通俗易懂的方式，把互斥锁这个抽象又头疼的概念讲透，让你一看就懂，一用就顺。


> 💡 学习建议：建议边看边动手实践，把互斥锁的用法结合小程序练一遍，你会发现原来线程同步也可以这么轻松掌握！
>
> 如果在学习过程中遇到问题，或者想获取更多 Linux、C/C++、Go 后端开发等技术干货，欢迎关注我的公众号「跟着小康学编程」。有问题也可以添加我的个人微信交流讨论。
> 
> <table>
> <tr>
> <td align="center">
> <img src="https://github.com/xiaokangcoding/follow-xiaokang-coding/raw/main/images/qrcode-wechat-official.png" width="200">
> <br>
> <em>公众号「跟着学小康编程」</em>
> </td>
> <td align="center">
> <img src="https://github.com/xiaokangcoding/follow-xiaokang-coding/raw/main/images/qrcode-personal-wechat.png" width="200">
> <br>
> <em>个人微信（备注：加群）</em>
> </td>
> </tr>
> </table>

准备好了吗？我们先从一个形象的例子入手，彻底搞懂 **互斥锁** 是怎么工作的！

##### 前言：
  
你有没有碰到过这种情况？明明一段代码刚跑着好好的，结果加了个小小的功能，程序立马就开始“叽叽咕咕”，各种错误频频冒出。再一看，原来是多个线程抢着用同一个资源，导致数据乱了套！这时候我们就得用上“**互斥锁**”了。今天咱们用最通俗易懂的语言，把互斥锁这个抽象又头疼的概念给聊透，让你一看就懂，一用就顺。

### 1. 什么是互斥锁？用“抢厕所”的例子解释

互斥锁，其实就像是“上厕所时反锁的门”！

想象一下，一个家庭里有 4 个人，但只有 1 个厕所。大家早上都很忙，你争我抢地要用厕所。要是没有反锁的门，可能会有人中途闯进去，场面就尴尬了吧？于是，第一个人进去后就会把门反锁，防止其他人闯进来。

在编程中，互斥锁（Mutex Lock）就像这个“反锁的门”，它可以保证同一时间内只有一个线程（Thread）访问共享资源，防止“线程间的尴尬”。

##### 代码示例

假设我们有一个变量`counter`，多个线程想同时更新它。我们先来看没有锁的情况：

```c++
#include <pthread.h>

int counter = 0;

void* increment(void* arg) {
    for (int i = 0; i < 100000; ++i) {
        counter++;  // 直接增量操作
    }
    return NULL;
}

int main() {
    pthread_t t1, t2;
    pthread_create(&t1, NULL, increment, NULL);
    pthread_create(&t2, NULL, increment, NULL);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    
    printf("Counter: %d\n", counter);  // 结果不确定
    return 0;
}
```


假设 t1、t2 两个线程同时执行 increment()，会发生什么呢？

没有锁的情况下，`counter`可能会被不同的线程同时访问，导致结果混乱（比如，应该是200000，可能最后得到的是个随机值）。

### 2. 用锁控制访问，像贴心的“厕所门锁”

为了解决这个问题，我们可以使用互斥锁，把访问`counter`的代码给“锁”起来，这样每次只有一个线程可以修改它，直到这段代码执行完才会释放锁，其他线程才有机会进入。

##### 先来了解下互斥锁的主要接口:

互斥锁的基本用法很简单。首先，用`pthread_mutex_init`初始化一个锁，然后在进入共享资源时用`pthread_mutex_lock`上锁，退出共享资源后用`pthread_mutex_unlock`解锁，最后在程序结束时用`pthread_mutex_destroy`销毁锁。

```c++
pthread_mutex_t lock;
pthread_mutex_init(&lock, NULL);  // 初始化锁

pthread_mutex_lock(&lock);        // 上锁
// 访问共享资源
pthread_mutex_unlock(&lock);      // 解锁

pthread_mutex_destroy(&lock);     // 销毁锁
```


##### 接下来看个代码示例，看看具体怎么使用互斥锁：

```c++
#include <pthread.h>

int counter = 0;
pthread_mutex_t lock;

void* increment(void* arg) {
    for (int i = 0; i < 100000; ++i) {
        pthread_mutex_lock(&lock);   // 上锁
        counter++;
        pthread_mutex_unlock(&lock); // 解锁
    }
    return NULL;
}

int main() {
    pthread_t t1, t2;
    pthread_mutex_init(&lock, NULL);  // 初始化锁

    pthread_create(&t1, NULL, increment, NULL);
    pthread_create(&t2, NULL, increment, NULL);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    
    printf("Counter: %d\n", counter);  // 结果是200000
    pthread_mutex_destroy(&lock);      // 销毁锁
    return 0;
}


# 假设两个线程同时执行 increment()，这次结果会是200000
```

在上面的代码中，我们使用了`pthread_mutex_lock`来上锁，并且在代码块结束后用`pthread_mutex_unlock`释放锁。这样做的好处是，锁保证了每次只有一个线程可以修改`counter`，不会再出现“结果不确定”的情况。



### 3. 为什么一定要加锁？避免“数据不一致”的崩溃风险

没有锁，就好比厕所门随时可以被推开，数据读写随时被“打断”。这种不确定性不仅会让程序员崩溃，也会让用户崩溃。互斥锁就是给资源加上一把锁，让一个线程完成访问后，其他线程才能继续访问。

### 4. 细节也很重要，锁的释放要谨慎

要注意，锁不仅要上得及时，还要放得恰当。假设你在厕所门上锁了，但人不小心摔倒晕过去了（程序异常退出了），厕所就永远被锁住，其他人无法使用。为避免这种情况，C++ 里我们用`lock_guard`来确保锁最终一定会释放。

##### 代码示例:

```c++
#include <iostream>
#include <thread>
#include <mutex>

int counter = 0;
std::mutex mtx;

void increment() {
    // 使用 lock_guard 确保锁在作用域结束时自动释放
    std::lock_guard<std::mutex> lock(mtx);
    counter++;
    // 即使这里发生异常，lock_guard 也会在作用域结束时自动释放锁
}

int main() {
    std::thread t1(increment);
    std::thread t2(increment);

    t1.join();
    t2.join();

    std::cout << "Counter: " << counter << std::endl;
    return 0;
}
```


在这个例子中，即便`increment`函数内部发生异常，`lock_guard`也会确保锁被释放，不会导致程序因为其他线程异常退出而一直“卡住”。

### 5. 死锁：互斥锁使用中的“大坑”

在多线程编程中，死锁是一个很容易遇到的“坑”。简单来说，死锁发生在两个或多个线程互相等待对方释放资源，而又谁都不放手，结果程序就这样一直卡住。

**场景**： 假设我们有两个线程 A 和 B，每个线程都需要获取两个锁 `lock1` 和 `lock2` 来执行操作。

+ **线程 A**：先拿到 `lock1`，接着想要拿 `lock2`。
+ **线程 B**：先拿到 `lock2`，接着想要拿 `lock1`。

如果线程 A 和 B 分别拿到了不同的锁，然后各自等待对方释放另一个锁，这就会形成“僵局”——谁都在等对方，导致程序永远无法继续执行，这就是死锁。

**来看张图,更直观的理解下死锁：**

```lua

线程 A                      线程 B
   |                           |
   |------获取 lock1------>    |
   |                           |------获取 lock2------>
   |                           |
   |<-----等待 lock2------     |<-----等待 lock1------
   |                           |
   ( 卡住：死锁发生 )
```

##### 说明：

1. 线程A获取了`lock1`，线程B获取了`lock2`。
2. 线程A在等待`lock2`，而线程B在等待`lock1`。
3. 结果就是两个线程都卡住了，因为它们都在等待对方释放锁，这就是死锁。

##### 如何避免死锁？

**统一锁的顺序**：让所有线程按同样的顺序获取锁，比如都先获取 `lock1`，再获取 `lock2`，这样就不会互相等待，死锁的问题也就不会发生。

##### 正确的示例：

```c++
pthread_mutex_lock(&lock1);  // 先获取 lock1
pthread_mutex_lock(&lock2);  // 然后获取 lock2

// ... 执行操作 ...

pthread_mutex_unlock(&lock2); // 释放 lock2
pthread_mutex_unlock(&lock1); // 释放 lock1
```

这样，每个线程都按同样的顺序获取锁，死锁就不会发生了。

### 2. 互斥锁的使用场景：哪些时候要上锁？

互斥锁通常用于多线程环境中，特别是当多个线程需要访问同一资源时，用它可以避免数据混乱或冲突。这里有几个常见的场景：

##### 场景1：保护共享变量

多个线程同时修改一个变量时，如果不加锁，结果可能会出错。互斥锁可以确保一次只有一个线程能操作这个变量，避免数据错乱。

```c++

pthread_mutex_lock(&lock);   // 获取锁
shared_variable++;           // 安全地修改共享变量
pthread_mutex_unlock(&lock); // 释放锁
```

##### 场景2：保护关键资源或临界区

临界区是指多线程需要访问的、可能会导致冲突的资源或代码块。例如，文件句柄、数据库连接、网络资源等需要严格管理的资源。如果多个线程同时访问这些资源，可能导致资源泄露或程序崩溃。使用互斥锁可以保证一次只有一个线程使用该资源，其他线程必须等待锁被释放。

```c++

pthread_mutex_lock(&lock);   // 获取锁
// 这里是临界区代码，比如访问数据库、文件操作或其他关键资源
pthread_mutex_unlock(&lock); // 释放锁
```

互斥锁可以确保多线程环境中共享变量和关键资源的安全访问，防止数据错乱、资源冲突等问题。

### 7. 互斥锁的优缺点

##### 优点

1. **数据一致性**：互斥锁防止多个线程同时访问共享资源，从而保持数据的完整性。
2. **简洁高效**：对于多线程的临界区管理，互斥锁是较简单的方式。
3. **通用性强**：适用于绝大多数多线程的共享资源保护场景。

##### 缺点

1. **阻塞等待**：如果一个线程获取锁后时间过长，其他线程会处于等待状态，可能导致性能下降。
2. **死锁风险**：如果一个线程忘记释放锁，其他线程会一直等待下去，造成死锁。
3. **增加复杂性**：锁的管理需要注意，过度使用锁会增加代码的复杂性。

### 8. 小结：牢记锁的三要素

1. **上锁前后**：确保锁是在进入代码块前获取，并且在离开代码块后释放，避免资源一直被占用。
2. **唯一性**：同一时间只能有一个线程持有锁，确保“厕所”（共享资源）只能一个人（一个线程）使用。
3. **自动释放**：在C++中使用`std::lock_guard`来管理锁，保证作用域结束时锁自动释放，即使发生异常也不会忘记解锁。

### 9. 总结：一把锁让多线程的世界井然有序

互斥锁（Mutex Lock）就是多线程编程中的“秩序保障器”，用它给共享资源加上“反锁的门”，避免混乱。程序就好比家里的生活空间，而锁则确保每个人（线程）都能有序、独立地使用“公共资源”。

希望大家看完这篇文章后，能对互斥锁有一个清晰的理解：它不仅是代码里的一行“技术命令”，更是多线程编程中的“安全管家”，让你的程序“井然有序”地运行！


## 最后：

如果这篇文章帮你轻松搞懂了互斥锁，记得点个在看和赞👍，也可以分享给身边的小伙伴，让更多人一起进步！另外，欢迎关注我的公众号「**跟着小康学编程**」，这里会持续更新更多编程干货，每周带你轻松掌握各种技术难点！


#### 关注我能学到什么？

- 这里分享 Linux C、C++、Go 开发、计算机基础知识 和 编程面试干货等，内容深入浅出，让技术学习变得轻松有趣。

- 无论您是备战面试，还是想提升编程技能，这里都致力于提供实用、有趣、有深度的技术分享。快来关注，让我们一起成长！

#### 怎么关注我的公众号？

**非常简单！扫描下方二维码即可一键关注。**

![](https://files.mdnice.com/user/48364/65158d3c-cd38-4604-861a-8f0379066dc0.png)

此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！

![](https://files.mdnice.com/user/48364/971ccaa3-8f57-4e33-8bc9-d0863eeade81.png)




