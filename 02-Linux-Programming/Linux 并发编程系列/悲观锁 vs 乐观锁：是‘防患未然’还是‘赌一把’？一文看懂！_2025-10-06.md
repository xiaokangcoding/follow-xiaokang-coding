### 前言

在程序世界里，控制并发是门大学问。当多个线程或用户同时访问同一个数据时，如何防止数据被“你方改了我改，改得一团乱”是我们必须面对的问题。而在各种锁机制中，有两位特别有个性的“选手”：**乐观锁**和**悲观锁**。

今天就带大家来看看，这两种锁到底有啥不同，啥场景用谁更合适。保证一看就懂！

### 一、什么是乐观锁？什么是悲观锁？

在生活中，如果你借了本书，有些人会先担心别人可能也想看这本书，直接把书“占着不放”；而有些人则心态很好，觉得别人未必会来拿，只有真被抢了再想办法。乐观锁和悲观锁的理念就有点像这两种人。

#### 悲观锁：小心为上，防范为先

悲观锁的心态很“谨慎”：它认为每次操作共享数据时，别人都可能来“抢”，所以**直接上锁，让别人都等着**，直到自己操作完成再放开。

**现实中的例子**：就像你去图书馆借书，如果你担心有人跟你抢这本书，那你会直接把书抱在手里，直到看完了才放回去，这样其他人只能等着。悲观锁的操作方式就是如此：一次只允许一个人使用资源，其他人都得等着。

**程序中的悲观锁**： 在程序里，悲观锁适合那些写操作多的场景，因为写操作会修改数据，竞争较激烈时更容易出错。通过锁住资源，它可以确保数据一致性。

```sql

-- SQL示例：悲观锁
BEGIN TRANSACTION;
SELECT * FROM products WHERE id = 1 FOR UPDATE; -- 加悲观锁
UPDATE products SET stock = stock - 1 WHERE id = 1;
COMMIT;
```

在这个SQL例子中，`FOR UPDATE`相当于把数据“锁住”，让其他事务等到当前事务结束再访问。这样可以防止其他操作抢先修改数据，确保数据安全。

#### 乐观锁：心态轻松，冲突再说
乐观锁的理念正好相反，它对操作数据很“乐观”，**假设大多数时候不会有冲突**。乐观锁允许多个线程同时操作，只有在最后更新数据时检查是否有冲突，如果有冲突则重试。

**生活中的例子**：你去图书馆借书，不会担心别人会和你抢这本书。你直接去借，如果发现书被别人借走了，再去调整计划，换本书。

**程序中的乐观锁**： 乐观锁适用于读多写少的场景，因为大部分操作只读数据，冲突概率低。它通常通过**版本号**或**时间戳**来控制。

```sql

-- SQL示例：乐观锁（版本号控制）
BEGIN TRANSACTION;
SELECT version FROM products WHERE id = 1; -- 读取当前版本号
-- 假设查询到的版本是 1
UPDATE products SET stock = stock - 1, version = version + 1 WHERE id = 1 AND version = 1; -- 更新数据并检查版本
COMMIT;
```

在这个例子中，我们用`version`字段来标记数据版本。只有在版本号没有变化的情况下，更新才会成功。如果版本号已改变（说明有其他人修改过），更新会失败，我们可以重新尝试。

### 二、代码示例对比
让我们来看看在Java中的代码实现。

#### Java 悲观锁示例（使用 `synchronized` 实现）
```java

public class PessimisticLockExample {
    private int stock = 10;

    public synchronized void decrementStock() {
        if (stock > 0) {
            stock--;
            System.out.println("悲观锁：库存减少，当前库存：" + stock);
        } else {
            System.out.println("库存不足，操作失败");
        }
    }
}
```

在这个悲观锁示例中，使用 `synchronized` 关键字确保 `decrementStock()` 方法在多线程下的互斥访问，防止并发修改 `stock` 值。其他线程在一个线程进入该方法时无法操作，确保了数据的安全性。


**java乐观锁实现**（CAS原理，乐观锁的常见实现）：

```java

import java.util.concurrent.atomic.AtomicInteger;

public class OptimisticLockExample {
    private AtomicInteger version = new AtomicInteger(1);

    public void updateData() {
        int currentVersion = version.get();
        // CAS操作：如果版本没有变化，则更新成功
        if (version.compareAndSet(currentVersion, currentVersion + 1)) {
            System.out.println("乐观锁：数据更新成功！");
        } else {
            System.out.println("乐观锁：数据冲突，重新尝试...");
        }
    }
}
```

在悲观锁例子中，加锁确保了只有一个线程可以操作，而乐观锁例子里，`compareAndSet`方法相当于检查版本，只有在没有冲突的情况下才能更新成功。

### 三、常见的乐观锁和悲观锁

#### 常见的乐观锁
1. **CAS（Compare-And-Swap）**：Java 的 `AtomicInteger` 和 `AtomicReference` 等类都使用 CAS 操作实现乐观锁。
2. **版本号控制**：通过数据库字段记录版本号，在更新时比对，确保数据的一致性。
3. **时间戳控制**：类似版本号控制，通过比较数据的上次更新时间戳，确保数据未被修改。

#### 常见的悲观锁
1. **行级锁**：在 SQL 中使用 `SELECT ... FOR UPDATE` 锁住记录，防止其他事务并发修改。
2. **表锁**：对整张表加锁，适合批量写操作，确保其他事务无法同时访问。
3. **互斥锁（Mutex）**：在编程中通过互斥锁确保资源的独占性，比如 Java 中的 `synchronized` 或 `ReentrantLock`。
4. **自旋锁**：在多核系统中，通过循环检测锁状态实现，在短时间等待时可以避免线程休眠和唤醒的开销。
5. **读写锁（Read-Write Lock）**：允许多个线程同时读数据，但写数据时需要独占锁，适合读多写少的场景，比如 Java 中的 ReentrantReadWriteLock。  

### 四、乐观锁和悲观锁对比：

| 特性 | 悲观锁 | 乐观锁 |
| --- | --- | --- |
| 特点 | 小心谨慎，锁住资源 | 轻松应对，先试试再说 |
| 适用场景 | 写多读少，数据改动频繁 | 读多写少，冲突少 |
| 并发性能 | 并发性能较低，开销大 | 并发性能高，适合高并发 |
| 实现方式 | 行级锁、表锁、互斥锁 | CAS、版本号控制、时间戳控制 |


### 五、总结：乐观还是悲观，场景选对才是关键
+ 如果你的场景是**写操作频繁**、竞争激烈，数据容易改动，悲观锁更适合；它能锁住资源，确保数据一致性，但可能会影响并发性能。
+ 如果你的场景是**读多写少**、数据冲突概率低，乐观锁则更合适。它不需要频繁加锁，通过版本号或 CAS 来检查冲突，性能更高。

记住，锁的选择没有绝对的好坏，最重要的是根据你的业务需求来选择合适的并发控制方案。希望今天的文章能让你对乐观锁和悲观锁有更清晰的认识！

## 最后：

如果这篇文章帮你轻松搞懂了互斥锁，记得点个在看和赞👍，也可以分享给身边的小伙伴，让更多人一起进步！另外，欢迎关注我的公众号「**跟着小康学编程**」，这里会持续更新更多编程干货，每周带你轻松掌握各种技术难点！


#### 关注我能学到什么？

- 这里分享 Linux C、C++、Go 开发、计算机基础知识 和 编程面试干货等，内容深入浅出，让技术学习变得轻松有趣。

- 无论您是备战面试，还是想提升编程技能，这里都致力于提供实用、有趣、有深度的技术分享。快来关注，让我们一起成长！

#### 怎么关注我的公众号？

**非常简单！扫描下方二维码即可一键关注。**

![](https://files.mdnice.com/user/48364/65158d3c-cd38-4604-861a-8f0379066dc0.png)

此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！

![](https://files.mdnice.com/user/48364/971ccaa3-8f57-4e33-8bc9-d0863eeade81.png)


