大家好，我是小康。

# 前言：自旋锁，其实一点也不复杂！

想象一下，你去上班，发现电梯坏了。站在电梯口等着，心里想着“它马上就会好吧？”。于是，你开始重复按着电梯按钮，一分钟又一分钟地等着，心里甚至有点烦躁。

这种状态就像 **“自旋”** 一样——你站在原地，做着重复的动作，不走开，等着电梯修好。

在计算机世界里，“自旋”指的就是线程**原地不断检查某个条件，直到条件满足**的行为。今天，我们就来聊聊 **自旋锁（Spinlock）** 是什么，为啥要用它，它又是怎么工作的。


想获取更多 Linux 并发、C/C++、Go 后端开发干货，欢迎关注我的公众号「**跟着小康编程**」。有问题也可以添加我的个人微信交流讨论。

> 💡 学习建议：建议边看边动手实践，把自旋锁结合小程序练一遍，你会发现线程同步并不难。
>
> 如果在学习过程中遇到问题，或者想获取更多 Linux、C/C++、Go 后端开发等技术干货，欢迎关注我的公众号「跟着小康学编程」。有问题也可以添加我的个人微信交流讨论。
> 
> <table>
> <tr>
> <td align="center">
> <img src="https://github.com/xiaokangcoding/follow-xiaokang-coding/raw/main/images/qrcode-wechat-official.png" width="200">
> <br>
> <em>公众号「跟着学小康编程」</em>
> </td>
> <td align="center">
> <img src="https://github.com/xiaokangcoding/follow-xiaokang-coding/raw/main/images/qrcode-personal-wechat.png" width="200">
> <br>
> <em>个人微信（备注：加群）</em>
> </td>
> </tr>
> </table>

### 一、自旋是什么？
在多线程编程中，如果多个线程要访问同一个资源，就必须协调好，不能一起上去“抢”。为了避免数据混乱，我们常用锁机制来管理这些资源，而“自旋锁”就是其中一种特殊的锁。

#### 那么，什么是“自旋”呢？
自旋的本质，就是一个“等”的动作。某个线程在等待资源解锁时，不去睡眠、不去做别的任务，而是持续检查——“资源解锁了吗？解锁了吗？”。这种重复检查、原地等待的动作，就是“自旋”。当资源解锁时，它可以立刻进入使用，而不用浪费时间重新“醒过来”。

### 二、形象化理解：小区公共健身器材

想象你住的小区，有一套公共健身器材，比如单杠。周末你想去玩单杠，但到了发现前面有人在用。你很想尽快上去，但也不想离开，万一人家马上玩完了呢？于是，你站在一旁，随时准备上场。

这时，有两种选择：

+ **选项A：** 站在旁边等，眼睛紧盯着单杠，直到前面那人下来，立马冲上去！这就是“自旋锁”的方式。
+ **选项B：** 先去跑个圈、做点别的，等回来再看前面的人走没走，这种叫“休眠锁”，类似于互斥锁。

在选项A中，你会一直“自旋”等待着机会，但这种方式只有在“前面那个人快要结束”的情况下才有意义，否则一直站着等，既浪费时间又累。所以，自旋锁适用于等待时间短、资源即将释放的场景。

### 三、 自旋锁和互斥锁的区别是什么？
自旋锁和互斥锁（Mutex）都能保证同一时间只有一个线程能访问共享资源，但它们的区别在于：

+ **互斥锁**：如果线程没有拿到锁，它会进入休眠状态，等锁释放后再唤醒，可能会产生一些“调度开销”。
+ **自旋锁**：如果线程没有拿到锁，它不会休眠，而是“原地自旋”等待锁的释放，减少了调度的开销。

因此，自旋锁特别适合那种“等待时间很短”的情况，比如一段代码块执行非常快，线程只需稍微等一下就能拿到锁，这时自旋锁就能显著减少开销。  

### 四、先了解自旋锁的基本接口
在 Linux 的`pthread`库中，我们可以用`pthread_spin_init`来初始化一个自旋锁，用`pthread_spin_lock`和`pthread_spin_unlock`来上锁和解锁。  


注意，自旋锁与互斥锁不同，自旋锁不允许等待的线程进入“休眠”，而是不断检查锁是否可用。

```c++

pthread_spinlock_t spin;
pthread_spin_init(&spin, 0);  // 初始化自旋锁

pthread_spin_lock(&spin);     // 自旋等待获取锁
// 访问共享资源
pthread_spin_unlock(&spin);   // 释放锁

pthread_spin_destroy(&spin);  // 销毁自旋锁
```

### 五、实际代码示例
在 Linux 内核或多线程编程中，自旋锁是一种重要的同步机制。以下是一个简单的自旋锁代码示例，用于模拟多线程的共享资源访问：

```c++

#include <pthread.h>
#include <stdio.h>

int shared_data = 0;
pthread_spinlock_t spinlock;

void* increment_data(void* arg) {
    pthread_spin_lock(&spinlock);  // 加锁，开始“自旋”
    shared_data++;
    printf("Thread %d: shared_data = %d\n", *(int*)arg, shared_data);
    pthread_spin_unlock(&spinlock);  // 解锁，停止“自旋”
    return NULL;
}

int main() {
    pthread_t threads[5];
    pthread_spin_init(&spinlock, 0);  // 初始化自旋锁

    int thread_ids[5] = {0, 1, 2, 3, 4};
    for (int i = 0; i < 5; i++) {
        pthread_create(&threads[i], NULL, increment_data, &thread_ids[i]);
    }

    for (int i = 0; i < 5; i++) {
        pthread_join(threads[i], NULL);
    }

    pthread_spin_destroy(&spinlock);  // 销毁自旋锁
    return 0;
}
```

在上面的代码中，每个线程都尝试去访问`shared_data`这个共享变量。通过自旋锁机制，线程会一直“等”到其他线程释放锁，确保每次只有一个线程可以修改`shared_data`，避免了数据混乱。

### 六、 自旋锁的应用场景：什么时候用自旋锁？
自旋锁的特点，就是“急”，不愿意浪费时间等待。它适合那些**等待时间短、需要快速响应**的情况，常见的场景有这些：

1. **小任务**：比如你只是要读取或修改一个小变量，操作很快完成，没必要让线程进入休眠再醒来，这种情况下自旋锁很合适。它能让线程马上完成任务，释放锁，保持流程流畅。
2. **多核系统**：在多核系统里，自旋锁更有优势，因为一个核在“忙等”时，其他核还能正常工作。这样线程不被阻塞，能有效提高整个系统的运行效率。
3. **操作系统内核的关键任务**：在操作系统内核中，很多任务要求速度快、等待时间短，自旋锁的特性就很适用。自旋锁能确保关键资源在被短时间锁定时，不产生过多的调度开销。

总之，自旋锁适合那些“等一小会儿就能用到”的情况，如果任务很简单、耗时很短，用它就能提高效率。但如果任务复杂、需要长时间锁定资源，还是换成别的锁更靠谱(比如互斥锁)。

### 七、自旋锁的陷阱：CPU高占用
自旋锁的主要风险是会导致 CPU 高占用。假设一个线程长时间持有锁，其他线程就会一直自旋等待，浪费 CPU。

#### 解决方法：设置最大等待次数
可以给自旋锁设置一个“最多等几次”的限制。比如，如果等了5次还没拿到锁，那就放弃，不再继续浪费CPU。这种方式在 Linux 的 `pthread_spin_trylock` 实现中经常被使用。

#### 简单代码示例
以下是一个带限制的自旋锁示例：

```c++

int try_spinlock_with_limit(pthread_spinlock_t *lock, int max_attempts) {
    int attempt = 0;
    while (attempt < max_attempts) {
        if (pthread_spin_trylock(lock) == 0) {  // 成功拿到锁
            return 0;
        }
        attempt++;
    }
    return -1;  // 达到最大次数，放弃
}
```

这里每次加锁最多等 5 次，没拿到锁就直接放弃。这样可以避免CPU一直空耗在等待上，提升效率。

### 八、自旋锁的优缺点
#### 优点
1. **快速响应**：自旋锁不涉及上下文切换的开销，在资源会快速释放的情况下，自旋等待更节省时间。
2. **适合多核处理**：在多核系统中，一个核的线程“自旋”等待时，另一个核的线程可以继续工作，实现更好的并行性。

#### 缺点
1. **CPU占用高**：自旋锁的线程不会释放CPU资源，所以等待时间长时会浪费CPU。
2. **只能短期等待**：如果锁被长期占用，自旋锁会导致资源浪费，还不如直接睡眠。这个时候使用互斥锁可能会更好。

### 九、C++ 如何实现自旋锁？
在 C/C++ 编程中,目前只有 Linux`pthread` 库提供了自旋锁相关接口，而在 C++ 中，并没有直接提供自旋锁（spinlock）的接口。不过，你可以使用 `std::atomic_flag` 来实现一个简单的自旋锁，因为 `std::atomic_flag` 是一个轻量级的原子布尔标志，非常适合构建自旋锁。

下面是一个使用 `std::atomic_flag` 实现自旋锁的示例：

```c++

#include <atomic>
#include <thread>

class SpinLock {
private:
    std::atomic_flag flag = ATOMIC_FLAG_INIT;

public:
    void lock() {
        while (flag.test_and_set(std::memory_order_acquire)) {
            // 自旋等待，直到获得锁
        }
    }

    void unlock() {
        flag.clear(std::memory_order_release);
    }
};
```

#### 使用方法
```c++

SpinLock spinlock;

void critical_section() {
    spinlock.lock();
    // 临界区代码
    spinlock.unlock();
}
```

#### 说明
+ **自旋锁的实现**：`lock()` 方法中使用了 `test_and_set`，它会不断尝试将 `flag` 设置为 `true`，直到成功获取锁。如果锁已经被其他线程占用，它会进入自旋等待状态，持续尝试获取锁。
+ **释放锁**：`unlock()` 方法通过 `clear` 将 `flag` 设为 `false`，释放锁，使其他线程可以进入临界区。

### 十、总结

自旋锁其实就是一种“死磕到底”的锁，适用于那种“等一下就能用”的情况。现实生活中也有很多类似的场景，比如公共健身器材的排队，等电梯，等等。理解了“自旋”其实就是一种“忙等”方式，才能更好地应对面试中的各种多线程问题。

希望这篇文章让你对“自旋锁”有了更全面、清晰的理解。下次面试时，再遇到这个面试题，你一定能从容应答，既讲清原理，又能结合实际应用，轻松拿下！  

## 最后：

如果这篇文章帮你轻松搞懂了自旋锁，记得点个在看和赞👍，也可以分享给身边的小伙伴，让更多人一起进步！另外，欢迎关注我的公众号「**跟着小康学编程**」，这里会持续更新更多编程干货，每周带你轻松掌握各种技术难点！


#### 关注我能学到什么？

- 这里分享 Linux C、C++、Go 开发、计算机基础知识 和 编程面试干货等，内容深入浅出，让技术学习变得轻松有趣。

- 无论您是备战面试，还是想提升编程技能，这里都致力于提供实用、有趣、有深度的技术分享。快来关注，让我们一起成长！

#### 怎么关注我的公众号？

**非常简单！扫描下方二维码即可一键关注。**

![](https://files.mdnice.com/user/48364/65158d3c-cd38-4604-861a-8f0379066dc0.png)

此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！

![](https://files.mdnice.com/user/48364/971ccaa3-8f57-4e33-8bc9-d0863eeade81.png)
