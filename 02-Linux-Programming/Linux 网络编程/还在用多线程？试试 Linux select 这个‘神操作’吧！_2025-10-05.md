大家好，我是小康。

上次聊完多线程，感觉处理并发是不是轻松了不少？今天咱们再升一级，来点更高效的—**I/O 复用技术**，让你写的服务器“多任务处理”更上一层楼！

说到 I/O 复用，可能你会觉得有点抽象。其实它的原理很简单—让服务器在处理多个客户端时更聪明，不再傻等一个连接处理完再去看其他连接，这样就不会浪费时间！这篇文章我们就聚焦 I/O 复用中的“元老级选手” `select`，带你轻松掌握它的原理和使用方法。话不多说，咱们一起开干！

#### 1、什么是 I/O 复用？它凭啥让服务器更快？

 打个比方：假设你是一个收银员，负责为多个顾客结账。传统的方式可能是一个顾客接着一个顾客地排队结账，如果顾客多了，就会排成很长的队伍。I/O 复用就像是给你增加了一种能力：你可以同时关注多个顾客，不用等每一个都排好队才服务。而是每次轮流问一遍哪些顾客准备好了，只要有顾客需要结账，你就马上服务他。 

在 Linux 中，select 就是一种经典的 I/O 复用机制。它允许服务器在一个线程内监控多个 I/O 事件（比如多个客户端的连接状态）。当服务器调用 select()，它会依次“询问”每个连接是否有事件发生，如果有事件发生了就立即处理。这样，服务器不需要为每个连接创建线程，使用单线程就可以服务于多个客户端，从而节省了资源，提升了效率。  

#### 2、为什么不用多线程？`select` 的优势是什么？

有人会问：“既然有多线程，为啥还要搞这么复杂？”好问题！其实多线程和 I/O 复用各有优势：

+ **多线程**：让每个连接有专属线程服务，代码容易理解，但线程多了会耗费系统资源，还容易因为切换而影响性能。
+ **I/O 复用**：让一个线程同时监控多个连接，一旦某个连接有事件发生，立刻响应处理，而无需多个线程并发的资源消耗，适合需要处理大量连接但数据交换不频繁的情况。

总之，`select` 能让服务器在单进程下应对大量连接，特别适合轻量级的并发场景，比如聊天服务器、轻量级游戏服务器等。

#### 3、select 函数和 fd_set 相关接口
在实际使用 `select` 时，我们会用到几个重要的函数和宏，分别是 `select()` 本身，以及操作 `fd_set` 结构的 `FD_ZERO`、`FD_SET`、`FD_CLR`、`FD_ISSET` 等宏函数。

### 3.1 `select()` 函数
`select()` 是 `I/O` 复用的核心函数，用来等待多个文件描述符的状态变化。

**函数原型**：

```c++

int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
```

**参数说明**：

+ `nfds`：要监控的文件描述符的数量，通常是 `fd_set` 中最大的文件描述符值加 1。
+ `readfds`：监控是否有数据可读的文件描述符集合。
+ `writefds`：监控是否有数据可写的文件描述符集合。
+ `exceptfds`：监控异常事件的文件描述符集合。
+ `timeout`：超时时间，`NULL` 表示无限等待，超时后 `select` 返回 0。

**返回值**：

+ 返回值为 0：表示超时时间到，没有文件描述符发生事件。
+ 返回值大于 0：表示有文件描述符发生了事件，具体可以通过 `fd_set` 检查。
+ 返回值为 -1：表示调用失败，`errno` 记录了具体的错误。

### 3.2 `fd_set` 相关宏函数
在 `select` 中，我们使用 `fd_set` 结构来标记哪些文件描述符需要被监控。这里有几个重要的宏函数，用于操作 `fd_set`。

+ `FD_ZERO(&fd_set)`：将 `fd_set` 清空，所有位清零。
+ `FD_SET(fd, &fd_set)`：将指定的文件描述符 `fd` 加入 `fd_set`，即把 `fd_set` 中 `fd` 的位设置为 1。
+ `FD_CLR(fd, &fd_set)`：将指定的文件描述符 `fd` 从 `fd_set` 中移除，即把 `fd_set` 中 `fd` 的位清零。
+ `FD_ISSET(fd, &fd_set)`：检查 `fd_set` 中指定的文件描述符 `fd` 是否被设置为 1，若为 1 表示该文件描述符有事件发生。

### 3.3 代码示例：初始化和操作 `fd_set`
```c++

#include <sys/select.h>
#include <stdio.h>

int main() {
    fd_set read_fds;       // 声明一个 fd_set 变量
    FD_ZERO(&read_fds);    // 初始化 fd_set，将所有位清零

    // 将文件描述符 3、4、5 设置为 1，表示需要监控它们
    FD_SET(3, &read_fds);
    FD_SET(4, &read_fds);
    FD_SET(5, &read_fds);

    // 调用 select() 监控这些文件描述符的事件
    int max_fd = 5;
    int activity = select(max_fd + 1, &read_fds, NULL, NULL, NULL);

    // 检查哪些文件描述符有事件发生
    if (FD_ISSET(3, &read_fds)) printf("fd 3 有事件发生\n");
    if (FD_ISSET(4, &read_fds)) printf("fd 4 有事件发生\n");
    if (FD_ISSET(5, &read_fds)) printf("fd 5 有事件发生\n");

    return 0;
}
```

#### 4、select 是怎么工作的？（含工作流程图解）
接口我们熟悉了，我们再来看 `select` 究竟是如何让服务器变得更高效的。

在 `select` 里，我们将**所有需要监控的连接**放进一个“监控表”(fd_set)，然后调用 `select()` 函数。`select()` 会“盯”着这些连接，看看是否有事件发生（例如某个客户端发来了新消息）。一旦有事件，`select` 就返回这些连接的列表，程序立刻去处理它们。其他没有事件的连接，就不占用 CPU 资源了。

说得再直白一点：select 让我们可以不再死等一个客户端消息，而是“盯住”所有客户端，哪个有消息立马响应，不耽误时间！


下面我们以一个实际例子来看看 `select` 的实际流程和背后的原理，帮助你更直观地理解它是如何高效工作的。

### 假设场景：
假设我们有一个服务器，它正在监听多个客户端连接的状态。每个客户端连接用一个文件描述符（fd）来表示，比如 3、4 和 5。这些文件描述符分别代表不同的客户端连接。我们的目标是：只要有任何一个客户端发来了新消息，服务器就能第一时间知道并进行处理。为此，我们使用 `select` 来高效监控这些连接。

### Step 1：初始化用户空间的 “监控表” (`fd_set`)
在用户空间（也就是我们写的代码里，可以参考上面的代码示例），我们首先要创建一个 `fd_set`，也就是“监控表”，用来指定我们想监控的文件描述符。

```plain
用户空间的 fd_set:
[0, 0, 0, 1, 1, 1, ...]
(3, 4, 5 位被设置为 1，表示我们要监控这些文件描述符) 
```

这里的 `fd_set` 是一个位数组（bitmap），每个位代表一个文件描述符的位置。如果某个位被设置为 1，表示我们希望 `select` 监控这个文件描述符。在实际的代码里，我们一般使用 FD_SET 函数来设置。

**图示：**

```diff

// 将文件描述符 3、4、5 设置为 1，表示需要监控它们
FD_SET(3, &read_fds);
FD_SET(4, &read_fds);
FD_SET(5, &read_fds);

用户空间 fd_set 结构
+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 1 | 1 | 1 | 0 |...|
+---+---+---+---+---+---+---+---+
  0   1   2   3   4   5   6 ...
```

如图所示，3、4、5 位被设置为 1，表示我们要监控文件描述符 3、4 和 5。

### Step 2：调用 `select()` 函数
设置好 `fd_set` 后，我们调用 `select(fd_set)` 函数。这时，用户空间的 `fd_set` 就会被复制到内核空间。

+ 传递 `fd_set`：`select` 的作用就是告诉内核去“盯住”这些文件描述符，看看它们有没有新消息或事件发生。
+ 进入等待状态：在内核空间里，`select` 函数会暂时“挂起”，一直等到某个文件描述符有事件发生才返回。

### Step 3：内核开始“盯”住文件描述符（内核空间的 `fd_set`）
在内核空间，`select` 开始检查我们传入的这些文件描述符的状态（比如有没有新的数据到达，是否可读等）。它会监控所有被设置为 1 的文件描述符，等待其中的任何一个发生事件。

内核空间 `fd_set` 结构：

```diff
内核空间 fd_set 结构
+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 1 | 1 | 1 | 0 |...|
+---+---+---+---+---+---+---+---+
  0   1   2   3   4   5   6 ...
(内核监控文件描述符 3、4、5 的状态)
```

内核会“盯”着这些位置为 1 的文件描述符，看看哪个先有事件发生。假设文件描述符 4 有数据到达，内核就会标记这个事件。

> **小知识**：从上面的内容我们了解到，用户空间和内核空间的 fd_set 结构其实就是一个“位数组”（bitmap）。可以简单理解为一个只包含 0 和 1 的数组，用 1 来表示需要监控的文件描述符，用 0 表示不监控。

### Step 4：事件发生，内核更新 `fd_set`
一旦文件描述符 4 发生了事件（比如可读事件：客户连接到来或者客户有数据到来），内核会更新 `fd_set`，把文件描述符 4 的位保留为 1，其他没有事件的位清零。这样一来，只有发生了事件的文件描述符会被保留下来，其他的会被清零。

内核空间更新后的 `fd_set`：

```diff

内核空间 fd_set 更新
+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 0 | 1 | 0 | 0 |...|
+---+---+---+---+---+---+---+---+
  0   1   2   3   4   5   6 ...
(仅文件描述符 4 发生事件，保留 1)
```

在这个更新后的 `fd_set` 里，只有文件描述符 4 的位置仍然为 1，表示它有事件发生。

### Step 5：`select` 返回到用户空间
当 `select` 监测到事件并返回后，用户空间的 `fd_set` 也会被更新，保留发生事件的文件描述符。这样，用户程序就可以知道哪个文件描述符有事件发生，然后直接去处理它。

用户空间更新后的 `fd_set`：

```diff

用户空间 fd_set 更新
+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 0 | 1 | 0 | 0 |...|
+---+---+---+---+---+---+---+---+
  0   1   2   3   4   5   6 ...
```

在这个例子中，用户程序可以通过检查 `fd_set`，发现文件描述符 4 有事件发生，然后立刻读取数据并处理这个客户端的请求。

#### 5、如何编写 select 服务器程序？
让我们看下用 `select` 写一个小型服务器的流程，心里更有底：

1. **创建 socket 并绑定、监听**：服务器先创建 socket，绑定 IP 和端口，开始监听。
2. **初始化 `select` 的监控列表**：把服务器 socket 加入监控列表。服务器 socket 的作用是接收新客户端的连接请求。
3. **`select`** 等待事件：调用 `select()` 盯着这些连接，一旦有连接发来消息或请求，返回这些活跃的连接。
4. **处理事件**：根据返回的连接，区分是新连接还是已有连接的消息，分别处理。
5. **循环等待**：继续调用 `select()` 等待新事件，直到服务器关闭。

### select 实战代码示例

话不多说，直接上代码。这个示例会展示如何用 `select` 实现一个简单的并发服务器，监控多个客户端的连接。为了大家更容易理解，这里我给出伪代码。

```c++
int main() {
    int server_fd = setup_server();      // 创建、绑定、监听服务器 socket
    int client_fds[MAX_CLIENTS] = {0};   // 存储客户端连接的文件描述符
    fd_set read_fds;                     // 文件描述符集合

    while (1) {
        FD_ZERO(&read_fds);              // 清空集合
        FD_SET(server_fd, &read_fds);    // 将服务器 socket 加入集合
        int max_fd = server_fd;          // 记录最大文件描述符

        // 将所有已连接的客户端 socket 加入集合
        for (每个 client_fds[i]) {
            如果 client_fds[i] 有效 {
                FD_SET(client_fds[i], &read_fds);
                更新 max_fd;
            }
        }

        // 使用 select 监控所有连接的读事件
        select(max_fd + 1, &read_fds, NULL, NULL, NULL);

        // 检查是否有新客户端连接
        如果服务器 socket 有事件 {
            接受新连接并存储到 client_fds;
        }

        // 检查各个客户端 socket 是否有数据
        for (每个 client_fds[i]) {
            如果 client_fds[i] 有事件 {
                读取数据;
                如果收到数据 {
                    处理数据并回复;
                } 否则 {
                    关闭连接并清除 client_fds[i];
                }
            }
        }
    }
    return 0;
}
```


伪代码说明：

+ 初始化：服务器 socket 创建、绑定和监听。
+ 设置 `fd_set`  ：清空集合，将服务器 socket 和所有有效的客户端 socket 加入 `read_fds`。
+ 调用 `select`：等待任何一个文件描述符发生事件。
+ 新连接处理：如果服务器 socket 有事件，接收新客户端并将其存储到 `client_fds`。
+ 数据处理：检查各个客户端 socket 是否有事件，处理数据或关闭连接。

为了不让篇幅过长，我将 select 实现的并发服务器和客户端代码放在公众号后台了，有需要的小伙伴可以微信搜索「**跟着小康学编程**」关注公众号后，在后台回复「**select**」即可获取完整代码示例。

或者点击下方公众号名片关注:

#### 6、Select 的小贴士

+ **连接数限制**：`select` 在一些系统中最多支持 1024 个连接，如果并发特别多，可以考虑 `poll` 或 `epoll`（更适合高并发场景）。
+ **事件返回**：`select()` 返回的是有事件的连接，而不是整个监控列表，这点要留意。
+ **灵活处理**：`select` 本身是阻塞的，会等待文件描述符上的事件。但如果将每个连接设置为非阻塞模式，`select` 返回后即使某个连接的读写操作无法立即完成，也不会阻塞整个程序，从而使服务器能够在多个连接之间灵活切换，更适合多连接的场景。  
+ **不再死等**：虽然 `select` 本身是阻塞的，但你可以设置一个超时时间，不让它“死等”。比如可以让 `select` 等 2 秒，如果没有事件，它就会返回继续干其他事情。这样一来，服务器不必死守某个连接，响应速度更快，用户体验更好！  

> **小建议**： 别让 `select` 一直跑来跑去！如果没啥特殊需求，别把 `timeout` 设得太短，不然 `select` 会频繁打扰 CPU，反复从用户态切到内核态、再切回来，忙得不可开交。给 `timeout` 设置稍微长一点，能让系统更省力，性能也更稳！  


#### 7、为什么选 select？I/O 复用的好处再总结
最后再来回顾一下为什么 `select` 这么香：

+ **效率高**：一个线程处理多个连接，节省系统资源。
+ **适合高并发**：轻松监控多客户端，哪个有消息先处理哪个。
+ **减少阻塞**：不再傻等每个连接，响应速度更快，用户体验更好。

#### 8、Select 的优缺点
`select` 作为经典的 I/O 复用技术，有它的亮点，但也有一些局限。让我们来看看它的优缺点。

### 优点
+ **跨平台兼容好**：`select` 是 POSIX 标准，几乎在所有操作系统上都能用，包括 Linux、Windows 和 macOS。写出来的代码移植性好。
+ **实现简单**：`select` 的接口相对简单，代码也易于编写和理解，适合作为 I/O 复用的入门技术。
+ **适合中等并发**：对于连接数不是特别多的场景，`select` 可以稳定地管理多个连接，不需要创建多个线程，节省资源。

### 缺点
+ **文件描述符上限**：在一些系统上，`select` 只能监控最多 1024 个文件描述符，这在高并发场景下会成为瓶颈。
+ **效率较低**：每次调用 `select` 都要扫描整个文件描述符列表，不管有多少连接发生了事件，都要一个个检查，这种轮询方式效率不高。
+ **需要重设 fd_set**：每次调用 `select` 后都要重新设置 `fd_set`，要重复填充列表，增加了操作上的小麻烦。

### 总结一下：
`select` 的亮点是简单、好用、兼容性好，但它的性能和连接数限制让它更适合中小规模的应用。

#### 9、Select 的适用场景
`select` 是多任务处理的好帮手，特别适合中小规模的多连接场景。下面是几个 `select` 的理想应用场景：

+ **小型聊天服务器**：比如一个轻量级的聊天室应用，连接数不多，`select` 可以帮你轻松管理多个客户端消息。
+ **小型文件或 HTTP 服务器**：对少量并发请求的服务器来说，`select` 完全够用，可以让服务器实现多任务处理。
+ **小游戏服务器**：用于管理少量的玩家连接，特别是那些实时性要求不是太高的小型多人游戏。
+ **设备输入监控**：`select` 也很适合监控多个输入设备（比如键盘、鼠标等），在一些图形界面或嵌入式设备开发中很常见。
+ **学习入门**：由于 `select` 的代码简单、逻辑清晰，非常适合学习 I/O 复用的基本概念。

### 需要注意的是：

如果你的应用需要处理大量并发连接（超过 1000 个），`select` 的性能瓶颈就会显现，这时可以考虑更高效的 `poll` 或 `epoll` 来替代。

#### 总结：轻松掌握 select

好了，今天我们聊了 Linux 的 `select`，这个经典的 I/O 复用神器！它让一个线程可以同时“盯住”多个连接，不再傻等某一个连接，整体效率直接提升。虽然 select 有它的缺点，但在中小规模的场景中，它的简单和易用性仍然让它大放异彩。

怎么样，这次是不是感觉又学到了新东西？希望大家通过这篇文章，对 Linux Socket 的 select 有了更清晰的了解。下次写服务器程序的时候，可以试试用 select 来让服务器变得更 "机智" 一点！

如果你觉得这篇文章对你有帮助，别忘了**点赞、在看、分享**一条龙哦！下次我们再聊聊 poll 和 epoll，看看它们和 select 有啥不一样，敬请期待吧~


还没关注我的公众号？赶紧微信搜索「**跟着小康学编程**」一键关注，更多编程实战干货等着你！

