大家好，我是小康。

# 前言：单进程太慢？让我们开启“多进程加速模式”！

大家好，我是小康。

在上一篇文章中，我们一起实现了一个 单进程 Socket 服务器。它能稳定地接收客户端请求、完成通信，看起来一切正常。
但是——当连接数一多、请求一复杂，你是不是发现服务器开始“卡顿”、响应慢、甚至假死？这就像是只有一个售票员的火车站，客户排成长队，一个慢半拍，全体崩溃。

没错，这就是单进程模型的天花板。它虽然简单，但无法同时处理多个客户端，一旦一个连接阻塞，其他请求统统得“干等着”。

所以，今天我们要让服务器进化——从“单线程打工人”，升级为“多进程千手观音”！
通过多进程模型，服务器可以在每个请求到来时创建一个独立的子进程，做到 并行处理、多路响应，性能和体验直接起飞 🚀。

别担心，这听起来很高级，但其实原理非常简单：

你只需要掌握 fork() 的使用，以及进程之间如何共享资源，就能轻松实现一个多进程服务器。

> 💡 学习建议：建议先阅读上一篇《Linux Socket 编程入门》，打好基础再上手本篇内容；
>
> 如果在学习过程中遇到问题，或者想获取更多 Linux、C/C++、Go 后端开发等技术干货，欢迎关注我的公众号「跟着小康学编程」。有问题也可以添加我的个人微信交流讨论。
> 
> <table>
> <tr>
> <td align="center">
> <img src="https://github.com/xiaokangcoding/follow-xiaokang-coding/raw/main/images/qrcode-wechat-official.png" width="200">
> <br>
> <em>公众号「跟着学小康编程」</em>
> </td>
> <td align="center">
> <img src="https://github.com/xiaokangcoding/follow-xiaokang-coding/raw/main/images/qrcode-personal-wechat.png" width="200">
> <br>
> <em>个人微信（备注：加群）</em>
> </td>
> </tr>
> </table>

准备好了吗？🚀

让我们一起从“排队式服务器”迈向“并行处理”的新时代，

看看多进程是如何让 Socket 服务器化身为高性能战士的！

### 1. 单进程服务器的局限：你为什么需要多进程？

咱们先复习一下上次那个“单进程”的 socket 服务器模型：服务器启动后监听端口，来了一个客户端，就开始处理，处理完再等下一个。这就像是卖票的窗口，只有一个售票员，客户只能老老实实排队。想想春运的时候，你排了几个小时好不容易轮到自己，结果前面的人非要跟售票员聊上两句，这种抓狂的感觉，就是你服务器被卡住时用户的真实体验。

如果你只有少数几个客户端，单进程还能应付得来。但如果连接数一多，尤其当某个客户端请求特别慢的时候，其他人就得原地发呆—而你的服务器，沦为了效率低下的“绊脚石”。

### 2. 多进程模型登场：化身千手观音，谁来都不怕！

于是，我们请来了多进程模型！所谓多进程，简单来说就是服务器不再是一个单独的售票员，而是每来一个客户端连接，服务器就创建一个新的子进程来专门处理这个客户端。这样每个客户都可以同时得到服务，再也不用排队苦等了。

这种方式大幅提高了服务器的响应速度，让它能轻松应对几十甚至上百的连接。想象一下，多个售票员各自独立处理客户，每个客户都可以同时被服务，不再需要排队等待，效率自然高了很多！

说到这里，大家可能会好奇，这么厉害的多进程模型在 Linux 上要怎么实现呢？别急，下面我就教你如何轻松搞定！  

### 3. Linux 中的多进程 socket 服务器：教你轻松实现

要搞清楚怎么在 Linux 下实现多进程 socket 服务器，其实很简单，我们只需要认识三个好朋友：

- fork()：这个函数就像分身术，可以复制出一个新的进程。想象你的服务器是一家咖啡店，fork() 就是让咖啡师“召唤”出一个新的咖啡师。当有顾客点单时，咖啡师会立刻“召唤”出一个新的咖啡师来专门负责这个顾客的订单，而原来的咖啡师继续接待其他顾客。这样，所有顾客都能得到快速的服务，而不必等待前面的咖啡做好后才轮到自己。

- accept()：accept() 就是咖啡师看到新顾客进店后接单的过程。当有新顾客进来时，某位咖啡师通过 accept() 接到这个订单，然后用 fork()“复制”出一个新的咖啡师来专门服务这个顾客，确保每位顾客都有专人服务，所有人都能同时得到关照。

- waitpid()：新咖啡师服务完顾客后就“下班”了，但我们需要有人把这些离开的咖啡师“清理”出去，不然店里会看起来乱糟糟的。waitpid() 就是管理者用来确认所有离职咖啡师状态的工具，确保店里的空间干净整洁，不会有“幽灵咖啡师”占据资源。

简单来说，fork() 就是召唤新的咖啡师来服务顾客，accept() 是接单的过程，而 waitpid() 则是管理者负责清理离岗的咖啡师。三者配合得当，就能让我们的多进程 socket 服务器高效运转，有效地处理每一个客户端连接。

### 4.多进程 socket 编程的工作流程：

在聊多进程之前，我们先来回顾下在前一篇文章讲的单进程服务器模型：

![](https://files.mdnice.com/user/71186/0a349906-209b-4e26-b493-e4588970bfcd.png)


单进程模型处理每个客户端请求的时候，服务器只能一个一个处理，这导致了效率的低下。

**那么多进程如何工作呢？先来看张图：**

![](https://files.mdnice.com/user/71186/a4966e4d-08f8-48e4-b0a0-fc0cc9c5c3ff.png)

通过上面的对比图，我们可以看到，多进程模型让服务器可以同时处理多个请求，而不再是单线程的“排队处理”。

咱们说的再具体一点，看看一个多进程的 socket 服务器如何工作的。以下是它的基本步骤：


1. **创建套接字**：服务器程序先创建一个 socket，作为电话机来接听所有的连接请求。
2. **绑定地址**：然后服务器把这个 socket 绑定到一个 IP 地址和端口上。
3. **监听连接**：接下来服务器开始监听，告诉大家 "喂，我在这里接电话哦"，然后等着客户端来连接它。
4. **接受连接**：当一个客户端拨号（发起连接）时，服务器接受连接，然后——关键来了——**服务器会 fork 出一个新的进程**，这个新进程就是用来专门和这个客户端聊聊天的。
5. **处理请求**：新进程负责和这个客户端进行通信，而原来的服务器进程则继续等待其他新的连接，这样就可以同时处理多个客户端了。
6. **关闭连接**：当聊天结束时，双方挂断电话（关闭连接），新进程的工作完成，自动退出，节省系统资源。



### 5. 代码示例：多进程 socket 服务器长啥样？

咱们直接上代码，采用 Linux C 来实现多进程服务器，帮助大家理解多进程模型的基本流程：

```c++
// 业务处理函数
void ProcessHandler(int client_socket) {
    char buffer[1024] = {0};
    while (1) {
        memset(buffer, 0, sizeof(buffer));  // 清空 buffer
        int valread = read(client_socket, buffer, 1024);
        if (valread <= 0) {
            break;
        }
        printf("Received: %s", buffer);
        char *message = "Hello from server!\n";
        send(client_socket, message, strlen(message), 0);
    }
    close(client_socket);
}

// 信号处理函数
void sigchld_handler(int sig) {
    while (waitpid(-1, NULL, WNOHANG) > 0);  // 非阻塞地回收所有已终止的子进程
}

int main() {
    int server_fd, new_socket;
    struct sockaddr_in address;
    int addrlen = sizeof(address);

    // 1. 创建 socket
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(8080);
    
    // 2. 绑定地址和端口
    bind(server_fd, (struct sockaddr *)&address, sizeof(address));
    // 3. 监听连接
    listen(server_fd, 3);

    // 捕捉 SIGCHLD 信号
    signal(SIGCHLD, sigchld_handler);
    
    while (1) {
        // 4. 接受连接
        new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen);
        
        // 5. 创建子进程
        if (fork() == 0) {   // 子进程部分
            ProcessHandler(new_socket);
        }
        else {		// 父进程部分
            close(new_socket); // 父进程不需要和客户端通信
        }
    }
    return 0;
}
```

上面的代码中，每次有新的客户端连接时，`fork()` 会创建一个新的子进程来处理这个连接，而父进程继续监听其他的连接请求，这就是多进程 socket 服务器的核心逻辑。

鉴于篇幅过长，我将多进程 socket 服务器和客户端代码放在公众号后台了，有需要的小伙伴可以微信搜索「**跟着小康学编程**」关注公众号后，在后台回复「**多进程**」即可获取完整代码示例。

### 6. 多进程模型的优缺点

当然，多进程模型不是万能的，它有自己的优缺点。

**优点：**

+ 独立性强：每个子进程互不干扰，一个客户端出问题不会影响其他的连接。
+ 简单易用：逻辑上比较简单，代码也容易理解。

**缺点：**

+ 资源消耗大：每创建一个子进程，都会占用系统的内存和CPU。如果有成千上万个客户端连接，这个时候服务器会被拖垮。

所以，多进程模型适合小规模并发处理，但当我们面对高并发时，可能需要考虑其他模型，比如线程池、IO复用或者异步I/O，当然这是后话了。

### 7. 适合场景

**什么时候用多进程模型？**

简单来说，就是**并发量不大但要求稳定的场景**。比如公司内部的一个服务系统，几十个人同时用，那就可以用多进程模型，不用太操心效率问题。而如果是面对互联网用户，比如一个要承载上百万用户访问的网站，那还是得有更高级的方案。

### 8. 小结：让服务器快起来，选择合适的模型！

Linux socket 编程中的多进程模型，实际上就是通过 fork() 给每个客户端分配一个“专属小弟”，让服务器能够并行处理多个请求，从而提高并发能力。这种模型简单、稳定，尤其适合初学者理解和使用。

当然，实际生产环境中，还有很多其他的并发模型，比如多线程、I/O 复用等，每种模型都有各自的适用场景，未来我们会逐一介绍。先把多进程玩明白，再去搞其他的，循序渐进，才是王道。

### 最后：

好了，今天的内容到这里就告一段落啦。希望大家通过这篇文章，对 Linux socket 的多进程模型有了一个清晰的了解。如果你觉得这篇文章对你有帮助，记得点赞、在看和分享哦！让更多人一起了解这些有趣的编程知识！下次我们会聊聊多线程并发模型，敬请期待~

顺便提下，还没关注我的公众号吗？别再错过啦，微信搜索「**跟着小康学编程**」即可关注，更多精彩编程知识等着你！让我们一起学习、进步，把 Linux 编程玩得更溜~


另外，小康最近新创建了一个技术交流群，大家如果在阅读的过程中有遇到问题或者有不理解的地方，欢迎大家加群询问或者评论区询问，我能解决的都尽可能给大家回复。

扫一扫小康的个人微信，备注「加群」即可。




