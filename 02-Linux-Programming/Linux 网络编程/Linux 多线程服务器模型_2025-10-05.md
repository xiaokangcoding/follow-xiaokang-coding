前言：从“多进程”到“多线程”，让服务器再提一档！

大家好，我是小康。

在上一篇文章中，我们聊了 多进程服务器模型 —— 每当有新客户端连接，服务器就创建一个独立进程来处理。这样一来，多个客户端可以并行通信，性能相比单进程提升不少。
但你可能也发现了：进程太多，系统开销也大！进程切换成本高，资源分配复杂，管理起来也不够灵活。

于是，Linux 世界里出现了更轻量的方案——多线程服务器模型。
它不像多进程那样“一个请求一个进程”，而是让多个线程共享同一片内存空间，通过合理调度和同步机制实现高效并发。

多线程的魅力在于：

🌱 创建开销小：线程切换速度远快于进程；

⚡ 共享数据方便：无需复杂的 IPC（进程间通信）机制；

💬 响应更快：每个客户端连接都能独立由线程服务，不卡主流程。

当然，好处的背后也有坑：多个线程共用同一块内存，一旦同步没做好，bug 可能“神出鬼没”，非常难排查。

所以这篇文章，我会带你从零开始：

- 搞懂多线程与多进程的区别；

- 学会用 pthread 编写多线程服务器；

> 💡 学习建议：

> 建议先阅读上一篇《Linux 多进程服务器模型》，理解基本的并发原理；

> 动手写一写 pthread_create、pthread_join 等关键函数；

> 多用 printf 打印线程 ID，观察线程调度变化，你会学得更快！
>
> 如果在学习过程中遇到问题，或者想获取更多 Linux、C/C++、Go 后端开发等技术干货，欢迎关注我的公众号「跟着小康学编程」。有问题也可以添加我的个人微信交流讨论。
> 
> <table>
> <tr>
> <td align="center">
> <img src="https://github.com/xiaokangcoding/follow-xiaokang-coding/raw/main/images/qrcode-wechat-official.png" width="200">
> <br>
> <em>公众号「跟着学小康编程」</em>
> </td>
> <td align="center">
> <img src="https://github.com/xiaokangcoding/follow-xiaokang-coding/raw/main/images/qrcode-personal-wechat.png" width="200">
> <br>
> <em>个人微信（备注：加群）</em>
> </td>
> </tr>
> </table>

今天我们就用简单有趣的方式来深入讲解 Linux 多线程服务器模型，看完这篇，保准你能自己写出一个轻松应对多个客户端请求的多线程服务器。  

#### 1. 多线程模型 VS 多进程模型

在深入多线程编程模型之前，先来个简单的“多线程 vs 多进程”小科普。

+ **多进程**：每个进程拥有自己独立的内存空间，可以避免数据互相干扰，但在进程间传递数据比较复杂。
+ **多线程**：线程之间共享同一块内存空间，这样在传递数据时效率更高，但需要处理数据同步问题，以避免数据“抢占”或“冲突”的情况。

如果把多进程比作“分开房间的同事”，那么多线程就是“住在同一个房间的室友”，大家共用一套资源，需要协调好才能高效协作。

#### 2. 什么是多线程服务器模型？

**多线程**和**多进程**看似相似，但细品后发现，它们各有千秋。简单来说，**多线程更轻便**，因为多个线程之间共享内存，可以快速切换。举个例子：你在咖啡店打工，几个朋友同时点咖啡。多进程就是开几家店分别做，而多线程则是你自己一个人，边做美式边泡奶茶—因为这些饮品可以共用咖啡豆、奶等原料。

所以，在多线程模型中，每个客户端连接会对应一个线程，大家共同在服务器里工作，线程切换效率更高。


**来看下多线程模型的图解，保证一看就懂！**


![](https://files.mdnice.com/user/71186/f8e7a6c6-e0ef-4da5-adb9-4b5752b7da2c.png)


#### 3. 多线程服务器模型的运作流程

### 流程示意图：

```markdown

                  服务器部分
+-----------+---------------------------+
| socket()                                  |
| bind()                                    |
| listen()                                  |
| accept()                                  |
+-----------+---------------------------+

    |                                 |                                  |
    | pthread_create()         | pthread_create()          | pthread_create()
    ↓                                 ↓                                  ↓

+-----------+              +-----------+                  +-----------+
| 线程 1    |              | 线程 2    |                  | 线程 3    |
| --------- |              | --------- |                  | --------- |
| read()    |              | read()    |                  | read()    |
| write()   |              | write()   |                  | write()   |
+-----------+              +-----------+                  +-----------+

    ↑                                 ↑                                  ↑
    |                                 |                                  |
    |                                 |                                  |
+----------+                  +----------+                  +----------+
| 客户端 1  |                  | 客户端 2  |                  | 客户端 3  |
| socket() |                  | socket()  |                  | socket()  |
| connect()|                  | connect() |                  | connect() |
| write()  |                  | write()   |                  | write()   |
| read()   |                  | read()    |                  | read()    |
+----------+                  +----------+                  +----------+


```

#### 每一步的解读：

1. **创建监听 Socket**：服务器使用 `socket()` 函数创建一个监听套接字，指定 IP 和端口。
2. **监听客户端连接**：通过 `listen()` 让服务器等待来自客户端的连接请求。
3. **接受连接请求**：当有客户端发来请求时，服务器会用 `accept()` 接收，获取客户端的信息。
4. **启动新线程**：服务器会通过 `phread_create` 为每个客户端开一个新线程，新线程就是一个“小工人”，专门负责处理该客户端的请求。
5. **处理请求**：在各自的线程中，小工人接收客户端发来的数据、进行处理，并将结果返回给客户端。
6. **关闭线程**：当客户端断开连接时，线程就结束了，资源也随之释放。

这样就形成了一个“多线程处理池”，每个线程独立工作，但又同时共享服务器的资源(CPU和内存)。

#### 4. 简单的代码 Demo（多线程服务器）

在实现多线程服务器之前，先熟悉下 `pthread_create` 接口：
```c
#include <pthread.h>

int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
```
**参数详解**：
- **thread**：指向 pthread_t 变量的指针，用于保存新创建线程的线程 ID，便于后续管理该线程。

- **attr**：线程属性指针，通常传 NULL 表示默认属性（如默认栈大小、默认调度策略）。

- **start_routine** ：线程函数的指针，新线程启动后将执行这个函数。函数类型为返回 void*、参数 void*，可以用来传递数据。

- **arg**：传给线程函数的参数，类型为 void*，支持任意数据类型的传递。无需参数时可设置为 NULL。

**返回值**：
- 成功：返回 0
- 失败：返回错误代码

下面是一个简单的代码示例，我们来实现一个多线程回射服务器（Echo Server）。在这个模型中，每当有新的客户端连接到服务器时，会创建一个新线程来处理该连接。

```c++
#include <pthread.h>

#define PORT 8080

// 线程函数：处理客户端请求
void* handle_client(void* socket_desc) {
    int new_socket = *(int*)socket_desc;
    char buffer[1024];

    while (1) {
        // 接收客户端消息
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(new_socket, buffer, sizeof(buffer), 0);
        
        // 检查是否接收到数据或连接关闭
        if (bytes_received <= 0) {
            printf("客户端断开连接。\n");
            break;
        }

        printf("客户端发来的消息：%s\n", buffer);

        // 响应客户端
        char* response = "Hello from server!";
        send(new_socket, response, strlen(response), 0);
    }

    // 关闭 socket
    close(new_socket);
    pthread_exit(NULL);
}

int main() {
    int server_fd, new_socket;
    struct sockaddr_in address;
    int addrlen = sizeof(address);

    // 创建服务器 socket
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);
    bind(server_fd, (struct sockaddr*)&address, sizeof(address));
    listen(server_fd, 3);

    while ((new_socket = accept(server_fd, (struct sockaddr*)&address, (socklen_t*)&addrlen)) >= 0) {
        pthread_t thread_id;
        int* new_sock = malloc(sizeof(int));
        *new_sock = new_socket; // 每个线程一个独立的 socket 描述符

        // 创建新线程处理客户端请求
        if (pthread_create(&thread_id, NULL, handle_client, (void*)new_sock) < 0) {
            perror("线程创建失败");
            return 1;
        }

        // 等待线程执行完成
        pthread_join(thread_id, NULL);

        // 释放 socket 描述符内存
        free(new_sock);
    }

    close(server_fd);
    return 0;
}
```

**代码解读**：

这段代码的核心逻辑就是：每当有客户端连接时，服务器创建一个新线程来处理该客户端的请求。具体步骤是：

1. 服务器接收到客户端连接后，为该连接创建一个新的线程。
2. 新线程运行 `handle_client` 函数，用于接收和响应客户端的消息，直到客户端断开连接。
3. `pthread_join` 确保每个线程完成后才释放资源。

这个示例就是一个典型的多线程并发模型，每个客户端对应一个线程，彼此不干扰，轻松实现并发处理！

为了不让篇幅过长，我将多线程 socket 服务器和客户端代码放在公众号后台了，有需要的小伙伴可以微信搜索「跟着小康学编程」关注公众号后，在后台回复「多线程」即可获取完整代码示例。

或者点击下方公众号名片关注:

#### 5. 多线程模型的优缺点

多线程模型同样有它的优势和局限，来看一下具体的优缺点。

### 优点：
+ **高效资源利用**：线程共用同一块内存空间，减少了资源分配和占用，能更高效地利用系统内存资源。
+ **轻量、切换快**：线程切换的开销比进程小，系统在处理高并发时更加轻量、高效，特别适合需要快速响应的场景。

### 缺点：
+ **数据竞争**：多个线程共享同一内存空间，容易发生数据冲突。可以用锁（mutex）来控制线程的访问，保证数据一致性。
+ **稳定性差**：所有线程共享同一个内存空间，如果一个线程出错，可能会导致整个进程崩溃，影响所有线程。  
+ **资源消耗过大**：如果每个连接都开一个线程，当请求急剧增加，线程数量会迅速增多，消耗大量系统资源。可以用线程池来控制线程数量，避免资源耗尽。

#### 6、适合场景

**什么时候用多线程模型？**

多线程模型适合中等量级的并发请求，尤其是需要较快响应的场景。比如，公司内部的消息推送服务、支持几十到几百人同时在线的聊天室，或是一个需要频繁更新的小型实时数据服务。这些场景通常并发请求不少，但还不至于达到“爆量”的情况，多线程可以很好地应对。

如果你的服务面对的是数百到一千的并发用户，像中小型的网络游戏、团队协作工具等，多线程模型能保持流畅的响应速度。但是，当并发量上升到成千上万甚至更高时，多线程单靠增加线程数往往会使系统资源被耗尽，导致性能下降。此时，最好结合线程池来控制线程数量，或采用更适合大规模并发的方案，比如异步 I/O、协程等，来保持高效运行。

#### 7、多线程 vs 多进程：选哪个？

多线程的好处很明显：轻量、高效、共享内存。但它也有一些缺点，比如线程之间共享内存，意味着如果一个线程崩了，可能会影响到其他线程，甚至整个服务器进程。所以在使用多线程的时候，我们需要格外小心地管理共享资源，避免产生竞争条件（race condition）。

相对于多进程来说，多线程更适合那些需要频繁访问共享数据、且对系统资源敏感的场景。而多进程则适合需要高稳定性、任务独立性强的情况，因为即便一个子进程崩了，其他子进程仍然能正常工作。

#### 总结：轻松掌握多线程模型

多线程服务器模型的精髓其实就是 "高效处理多个客户端请求"。通过分配多个线程，服务器可以同时处理大量请求，这样用户体验自然就好了。不过，线程之间的同步问题需要我们格外小心，避免出现 "踩脚" 的情况。

怎么样，这次是不是感觉比想象中简单一点呢？希望大家通过这篇文章，对 Linux Socket 多线程服务器模型有了更直观的了解。下次你在写服务器程序时，可以体验下多线程！

## 最后:

如果你觉得这篇文章对你有帮助，别忘了点赞、在看、分享一条龙哦！下次我们再聊聊大名鼎鼎的 IO 复用技术，敬请期待吧~

还没关注我的公众号吗？别再错过啦，微信搜索「**跟着小康学编程**」即可关注，更多精彩编程知识等着你！让我们一起学习、进步，把 Linux 编程玩得更溜~



## 关注我能学到什么？

- 这里分享 Linux C、C++、Go 开发、计算机基础知识 和 编程面试干货等，内容深入浅出，让技术学习变得轻松有趣。

- 无论您是备战面试，还是想提升编程技能，这里都致力于提供实用、有趣、有深度的技术分享。快来关注，让我们一起成长！

## 怎么关注我的公众号？

**非常简单！扫描下方二维码即可一键关注。**

![](https://files.mdnice.com/user/71186/0dde803d-d52f-4ed8-b74b-b7f3da5817b9.png)

另外我还建了个**技术交流群**，里面都是真正在写代码的同行，不聊虚的，只聊技术。有问题大家一起讨论，比一个人闷头学效率高多了。
  
![](https://files.mdnice.com/user/48364/4ebc72e9-e4bb-447a-9a92-8367a178df6d.png)

记住，技术这条路，一个人走容易迷路，一群人走才能走得更远。