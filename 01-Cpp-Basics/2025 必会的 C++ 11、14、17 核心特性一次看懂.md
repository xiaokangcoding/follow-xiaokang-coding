
各位小伙伴，大家好！我是小康。

随着现代C++的快速发展，C++11/14/17引入的新特性已经成为每个C++程序员必须掌握的核心技能。无论你是准备技术面试，还是想提升项目开发效率，这些新特性都是不可或缺的。

在我最近的 **C++项目实战课程**中，很多同学都反映对这些新特性的理解还不够深入，特别是在实际项目中如何应用。今天我就把课程中的核心内容分享给大家，帮助你们系统性地掌握这些重要特性。

这篇文章涵盖了**14个核心主题**，每个都配有详细的代码示例和实际应用场景。学完这些内容，你将能够：

+ ✅ 熟练使用现代C++的并发编程特性
+ ✅ 掌握智能指针和内存管理最佳实践
+ ✅ 理解移动语义和完美转发的精髓
+ ✅ 具备开发高性能C++项目的能力



**常见的 C++11/14/17 新特性包括：**

1. 线程库 (std::thread)
2. 互斥量和锁
3. 条件变量
4. Lambda 表达式
5. std::function 和 std::bind
6. std::atomic 原子操作
7. std::chrono 时间库
8. 智能指针
9. std::future 和 std::promise、std::packaged_task
10. 可变参数模板和完美转发
11. 移动语义和右值引用
12. std::make_tuple 和 std::apply
13. std::invoke_result 和 decltype
14. 异常处理和传播

>想系统学习更多 C++ 知识？欢迎关注我的公众号「**跟着小康编程**」，我会持续更新 C、 C++、Linux、后端开发等高质量技术文章。也可以加我的个人微信，一起进群讨论学习！
>
> 
> <table>
> <tr>
> <td align="center">
> <img src="https://github.com/xiaokangcoding/follow-xiaokang-coding/raw/main/images/qrcode-wechat-official.png" width="200">
> <br>
> <em>公众号「跟着学小康编程」</em>
> </td>
> <td align="center">
> <img src="https://github.com/xiaokangcoding/follow-xiaokang-coding/raw/main/images/qrcode-personal-wechat.png" width="200">
> <br>
> <em>个人微信（备注：加群）</em>
> </td>
> </tr>
> </table>

## 1. 线程库 (std::thread)
C++11首次在标准库中提供了对线程的原生支持，让我们可以创建和管理线程。

### 基本用法
```cpp
#include <iostream>
#include <thread>

void hello() {
    std::cout << "Hello from thread!" << std::endl;
}

int main() {
    // 创建线程
    std::thread t(hello);
    
    // 等待线程完成
    t.join();
    
    return 0;
}
```

### 向线程传递参数
```cpp
#include <iostream>
#include <thread>
#include <string>

void printMessage(int id, const std::string& message) {
    std::cout << "Thread " << id << ": " << message << std::endl;
}

int main() {
    // 向线程函数传递参数
    std::thread t(printMessage, 1, "Hello World");
    t.join();
    
    return 0;
}
```

### 线程方法
+ `join()`: 等待线程完成
+ `detach()`: 将线程与调用者分离，允许独立运行
+ `joinable()`: 检查线程是否可以join()
+ `get_id()`: 获取线程ID
+ `hardware_concurrency()`: 返回系统支持的并发线程数

### 注意事项
+ 必须在线程对象销毁前调用`join()`或`detach()`，否则程序会终止
+ 使用`detach()`后，必须确保线程访问的资源在线程结束前不会被销毁

## 2. 互斥量和锁 (std::mutex, std::lock_guard, std::unique_lock)
当多个线程访问共享资源时，需要互斥量来防止数据竞争。

### 基本的互斥量
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <vector>

std::mutex mtx;  // 保护共享数据的互斥量
std::vector<int> data;  // 共享数据

void addToVector(int value) {
    mtx.lock();  // 获取锁
    // 临界区域内的操作是安全的
    data.push_back(value);
    std::cout << "Added: " << value << std::endl;
    mtx.unlock();  // 释放锁
}

int main() {
    std::thread t1(addToVector, 10);
    std::thread t2(addToVector, 20);
    
    t1.join();
    t2.join();
    
    return 0;
}
```

### 使用RAII锁包装器
手动调用`lock()`和`unlock()`容易忘记释放锁或出现异常导致死锁。C++11引入了RAII锁包装器：

#### std::lock_guard（基本锁）
```cpp
void addToVector(int value) {
    // 构造时自动锁定，析构时自动解锁
    std::lock_guard<std::mutex> lock(mtx);
    data.push_back(value);
    std::cout << "Added: " << value << std::endl;
}
```

#### std::unique_lock（更灵活的锁）
```cpp
void processData() {
    // 比lock_guard更灵活，支持手动解锁和重新锁定
    std::unique_lock<std::mutex> lock(mtx);
    
    // 预处理工作
    
    // 临时释放锁，允许其他线程访问
    lock.unlock();
    
    // 执行不需要锁的计算
    
    // 重新获取锁
    lock.lock();
    
    // 更新共享数据
}
```

### 其他锁类型
+ `std::shared_lock`: 支持多个读线程的共享访问
+ `std::scoped_lock`(C++17): 同时锁定多个互斥量，防止死锁

## 3. 条件变量 (std::condition_variable)
条件变量用于线程间的通知机制，当某个条件满足时，一个线程可以通知其他等待的线程。

### 基本用法
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>

std::mutex mtx;
std::condition_variable cv;
std::queue<int> taskQueue;

// 消费者线程
void consumer() {
    while (true) {
        int task;
        
        {
            // 使用unique_lock，因为条件变量需要它
            std::unique_lock<std::mutex> lock(mtx);
            
            // 等待条件：队列非空
            cv.wait(lock, []{ return !taskQueue.empty(); });
            
            // 获取任务
            task = taskQueue.front();
            taskQueue.pop();
        }
        
        // 处理任务
        std::cout << "Processing task: " << task << std::endl;
        
        if (task == -1) break;  // 终止信号
    }
}

// 生产者线程
void producer() {
    for (int i = 1; i <= 5; ++i) {
        {
            std::lock_guard<std::mutex> lock(mtx);
            taskQueue.push(i);
            std::cout << "Added task: " << i << std::endl;
        }
        
        // 通知一个等待的线程
        cv.notify_one();
        
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    
    // 发送终止信号
    {
        std::lock_guard<std::mutex> lock(mtx);
        taskQueue.push(-1);
    }
    cv.notify_one();
}

int main() {
    std::thread con(consumer);
    std::thread prod(producer);
    
    prod.join();
    con.join();
    
    return 0;
}
```

### 条件变量方法
+ `wait()`: 等待通知，可以提供谓词条件
+ `wait_for()`: 等待通知，但最多等待指定的时间
+ `wait_until()`: 等待通知，直到指定的时间点
+ `notify_one()`: 通知一个等待的线程
+ `notify_all()`: 通知所有等待的线程

## 4. Lambda表达式
Lambda表达式是C++11中引入的一个强大特性，允许定义匿名函数对象。

### 基本语法
```cpp
[ capture-list ] ( parameters ) -> return-type { body }
```

+ `capture-list`：捕获外部变量的列表
+ `parameters`：参数列表
+ `return-type`：返回类型（可选，编译器通常可以推导）
+ `body`：函数体

### 示例
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    int factor = 2;
    
    // Lambda表达式，捕获外部变量factor
    auto multiply = [factor](int x) { return x * factor; };
    
    // 使用Lambda与算法
    std::transform(numbers.begin(), numbers.end(), numbers.begin(), multiply);
    
    // 打印结果
    for (int n : numbers) {
        std::cout << n << " ";
    }
    std::cout << std::endl;
    
    // 直接在算法中使用Lambda
    int sum = 0;
    std::for_each(numbers.begin(), numbers.end(), [&sum](int x) {
        sum += x;
    });
    
    std::cout << "Sum: " << sum << std::endl;
    
    return 0;
}
```

### 捕获列表
+ `[]`: 不捕获任何变量
+ `[=]`: 以值方式捕获所有外部变量
+ `[&]`: 以引用方式捕获所有外部变量
+ `[var]`: 以值方式捕获变量var
+ `[&var]`: 以引用方式捕获变量var
+ `[=, &var]`: 以值方式捕获所有变量，但var以引用方式捕获
+ `[&, var]`: 以引用方式捕获所有变量，但var以值方式捕获

### mutable关键字
默认情况下，以值方式捕获的变量在Lambda中是只读的。使用`mutable`可以修改它们的副本：

```cpp
int counter = 0;
auto increment = [counter]() mutable { return ++counter; };
```

## 5. std::function和std::bind
### std::function
`std::function`是一个函数包装器，可以存储、复制和调用任何可调用目标，如普通函数、Lambda表达式、函数对象等。

```cpp
#include <iostream>
#include <functional>

// 普通函数
int add(int a, int b) {
    return a + b;
}

// 函数对象
struct Multiplier {
    int operator()(int a, int b) const {
        return a * b;
    }
};

int main() {
    // 存储普通函数
    std::function<int(int, int)> operation = add;
    std::cout << "Add: " << operation(3, 4) << std::endl;
    
    // 存储Lambda表达式
    operation = [](int a, int b) { return a - b; };
    std::cout << "Subtract: " << operation(7, 3) << std::endl;
    
    // 存储函数对象
    operation = Multiplier();
    std::cout << "Multiply: " << operation(5, 6) << std::endl;
    
    return 0;
}
```

### std::bind
`std::bind`创建一个新的可调用对象，将参数绑定到指定的函数。

```cpp
#include <iostream>
#include <functional>

void print(int a, int b, int c) {
    std::cout << a << " " << b << " " << c << std::endl;
}

int main() {
    // 使用占位符_1, _2表示将来传入的参数
    using namespace std::placeholders;
    
    // 绑定第一个参数为100
    auto f1 = std::bind(print, 100, _1, _2);
    f1(200, 300);  // 打印: 100 200 300
    
    // 绑定第二个参数为200
    auto f2 = std::bind(print, _1, 200, _2);
    f2(100, 300);  // 打印: 100 200 300
    
    // 重新排序参数
    auto f3 = std::bind(print, _3, _1, _2);
    f3(100, 200, 300);  // 打印: 300 100 200
    
    return 0;
}

```

std::bind的优势在于它能让你灵活地调整函数调用方式，而不需要修改原函数。你可以预先固定某些参数值，改变参数顺序，或者将多参数函数转换成需要更少参数的新函数。这在回调机制、接口适配和部分函数应用（partial function application）场景中特别有用，让代码更简洁、灵活。

## 6. 原子操作 (std::atomic)
原子操作提供了一种不需要互斥量的线程同步方式，常用于计数器和标志位。

### 基本用法
```cpp
#include <iostream>
#include <thread>
#include <atomic>
#include <vector>

std::atomic<int> counter(0);  // 原子计数器

void increment() {
    for (int i = 0; i < 1000; ++i) {
        // 原子自增，无需互斥量
        counter++;
    }
}

int main() {
    std::vector<std::thread> threads;
    
    // 创建10个线程，每个线程增加counter 1000次
    for (int i = 0; i < 10; ++i) {
        threads.push_back(std::thread(increment));
    }
    
    // 等待所有线程完成
    for (auto& t : threads) {
        t.join();
    }
    
    // 结果应该是10000
    std::cout << "Counter: " << counter << std::endl;
    
    return 0;
}
```

### 原子标志位
```cpp
#include <iostream>
#include <thread>
#include <atomic>
#include <chrono>

std::atomic<bool> ready(false);

void worker() {
    // 等待ready变为true
    while (!ready) {
        // 空循环或使用yield放弃时间片
        std::this_thread::yield();
    }
    
    std::cout << "Worker started!" << std::endl;
}

int main() {
    std::thread t(worker);
    
    std::this_thread::sleep_for(std::chrono::seconds(1));
    
    // 通知worker线程开始工作
    ready = true;
    
    t.join();
    return 0;
}
```

### 内存顺序
`std::atomic`提供了不同的内存顺序选项，控制操作如何与其他原子操作同步：

```cpp
// 使用默认顺序（顺序一致性，最强但最慢）
counter++;

// 使用放松顺序（最弱但最快）
counter.fetch_add(1, std::memory_order_relaxed);

// 使用获取-释放顺序（适合生产者-消费者模式）
counter.fetch_add(1, std::memory_order_release);  // 生产者
int value = counter.load(std::memory_order_acquire);  // 消费者
```

## 7. std::chrono库
C++11引入了`std::chrono`库用于时间和计时。

### 时长 (duration)
```cpp
#include <iostream>
#include <chrono>
#include <thread>

int main() {
    // 时长类型
    std::chrono::seconds sec(1);  // 1秒
    std::chrono::milliseconds msec(1000);  // 1000毫秒
    std::chrono::microseconds usec = 2 * sec;  // 2秒转换为微秒
    
    // 休眠线程
    std::this_thread::sleep_for(std::chrono::milliseconds(500));
    
    // 计时操作
    auto start = std::chrono::high_resolution_clock::now();
    
    // 执行一些操作
    for (volatile int i = 0; i < 1000000; ++i) {}
    
    auto end = std::chrono::high_resolution_clock::now();
    
    // 计算经过的时间
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    std::cout << "Operation took " << duration.count() << " milliseconds" << std::endl;
    
    return 0;
}
```

---

本文介绍了实现线程池所需的C++11基础特性。在下一篇中，我们将继续学习更高级的特性，包括智能指针、future/promise、可变参数模板和移动语义等。

## 8. 智能指针
智能指针是C++11中的一项重要特性，用于自动管理动态分配的内存，避免内存泄漏。

### std::shared_ptr
`std::shared_ptr`实现共享所有权，多个智能指针可以指向同一个对象，当最后一个智能指针被销毁时，对象会被自动删除。

```cpp
#include <iostream>
#include <memory>

class Resource {
public:
    Resource() { std::cout << "Resource acquired\n"; }
    ~Resource() { std::cout << "Resource released\n"; }
    void use() { std::cout << "Resource used\n"; }
};

int main() {
    // 创建shared_ptr
    std::shared_ptr<Resource> sp1 = std::make_shared<Resource>();
    
    {
        // 创建另一个指向同一资源的shared_ptr
        std::shared_ptr<Resource> sp2 = sp1;
        std::cout << "Count: " << sp1.use_count() << std::endl;  // 输出2
        
        sp2->use();  // 使用资源
    }  // sp2离开作用域，但资源不会被释放
    
    std::cout << "Count: " << sp1.use_count() << std::endl;  // 输出1
    sp1->use();  // 资源仍然可用
    
    sp1.reset();  // 显式释放资源
    
    return 0;
}
```

### std::unique_ptr
`std::unique_ptr`实现独占所有权，一个资源只能由一个`unique_ptr`拥有，不能复制，但可以移动。

```cpp
#include <iostream>
#include <memory>
#include <vector>

class Resource {
public:
    Resource(int id) : id_(id) { 
        std::cout << "Resource " << id_ << " acquired\n"; 
    }
    ~Resource() { 
        std::cout << "Resource " << id_ << " released\n"; 
    }
    void use() { 
        std::cout << "Resource " << id_ << " used\n"; 
    }
private:
    int id_;
};

int main() {
    // 创建unique_ptr
    std::unique_ptr<Resource> up1 = std::make_unique<Resource>(1);
    
    // 使用资源
    up1->use();
    
    // 不能复制
    // std::unique_ptr<Resource> up2 = up1;  // 编译错误
    
    // 但可以移动
    std::unique_ptr<Resource> up2 = std::move(up1);// 移动操作实际上发生在赋值语句执行时，而不是在调用 std::move() 函数的时候。
    
    // 原指针现在为空
    if (!up1) {
        std::cout << "up1 is null\n";
    }
    
    // 新指针有效
    up2->use();
    
    // 在容器中存储unique_ptr
    std::vector<std::unique_ptr<Resource>> resources;
    resources.push_back(std::make_unique<Resource>(2));
    resources.push_back(std::make_unique<Resource>(3));
    
    // 使用容器中的资源
    for (const auto& res : resources) {
        res->use();
    }
    
    return 0;  // 所有资源自动释放
}
```

### std::weak_ptr
`std::weak_ptr`是一种不控制对象生命周期的智能指针，它指向一个由`shared_ptr`管理的对象，但不增加引用计数。

```cpp
#include <iostream>
#include <memory>

class Resource {
public:
    Resource() { std::cout << "Resource acquired\n"; }
    ~Resource() { std::cout << "Resource released\n"; }
    void use() { std::cout << "Resource used\n"; }
};

int main() {
    // 创建shared_ptr
    std::shared_ptr<Resource> sp = std::make_shared<Resource>();
    
    // 创建弱引用
    std::weak_ptr<Resource> wp = sp;
    
    std::cout << "Count: " << sp.use_count() << std::endl;  // 输出1，wp不增加计数
    
    // 检查资源是否还存在
    if (auto temp = wp.lock()) {
        temp->use();  // 使用资源
        std::cout << "Resource still exists\n";
    } else {
        std::cout << "Resource no longer exists\n";
    }
    
    // 释放shared_ptr
    sp.reset();
    
    // 再次检查资源
    if (auto temp = wp.lock()) {
        temp->use();
    } else {
        std::cout << "Resource no longer exists\n";
    }
    
    return 0;
}
```

## 9. std::future 和 std::promise
`std::future`和`std::promise`是C++11中用于异步编程的组件，允许从一个线程获取另一个线程的结果。

### 基本用法
```cpp
#include <iostream>
#include <future>
#include <thread>
#include <chrono>

void computeResult(std::promise<int> resultPromise) {
    // 模拟耗时计算
    std::this_thread::sleep_for(std::chrono::seconds(2));
    
    try {
        // 计算结果
        int result = 42;
        
        // 设置结果值
        resultPromise.set_value(result);
    } catch(...) {
        // 如果计算过程出现异常，设置异常
        resultPromise.set_exception(std::current_exception());
    }
}

int main() {
    // 创建promise和future
    std::promise<int> resultPromise;
    std::future<int> resultFuture = resultPromise.get_future();
    
    // 在另一个线程中进行计算
    std::thread t(computeResult, std::move(resultPromise));

    // 在等待结果期间执行其他业务逻辑
    // ...
    
    // 只有当需要结果时才阻塞等待
    int result = resultFuture.get();
    
    std::cout << "Result: " << result << std::endl;
    
    t.join();
    return 0;
}
```

### wait_for 和超时处理
```cpp
#include <iostream>
#include <future>
#include <chrono>

int main() {
    // 创建一个异步任务
    std::future<int> future = std::async(std::launch::async, []() {
        std::this_thread::sleep_for(std::chrono::seconds(3));
        return 42;
    });
    
    std::cout << "Waiting for result...\n";
    
    // 等待结果，但最多等待1秒
    auto status = future.wait_for(std::chrono::seconds(1));
    
    if (status == std::future_status::ready) {
        // 任务已完成
        std::cout << "Result: " << future.get() << std::endl;
    } else if (status == std::future_status::timeout) {
        // 超时
        std::cout << "Timeout! Task still running..." << std::endl;
        
        // 仍然可以等待完成
        std::cout << "Final result: " << future.get() << std::endl;
    } else {
        // 任务被延迟
        std::cout << "Task is deferred.\n";
    }
    
    return 0;
}
```

### std::packaged_task
`std::packaged_task`将可调用对象与`future`绑定，便于获取异步任务的结果。

```cpp
#include <iostream>
#include <future>
#include <thread>
#include <functional>

// 计算斐波那契数列
int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n-1) + fibonacci(n-2);
}

int main() {
    // 创建packaged_task
    std::packaged_task<int(int)> task(fibonacci);
    
    // 获取future
    std::future<int> result = task.get_future();
    
    // 在另一个线程上运行任务
    std::thread t(std::move(task), 20);
    t.detach();  // 分离线程
    
    std::cout << "Calculating fibonacci...\n";
    
    // 等待并获取结果
    std::cout << "Fibonacci(20) = " << result.get() << std::endl;
    
    return 0;
}
```

### std::async
`std::async`是一个更高级别的抽象，它结合了线程创建和future获取。

```cpp
#include <iostream>
#include <future>
#include <vector>
#include <numeric>

// 计算部分和
double calculatePartialSum(const std::vector<double>& data, size_t start, size_t end) {
    return std::accumulate(data.begin() + start, data.begin() + end, 0.0);
}

int main() {
    const size_t dataSize = 100000000;
    const size_t numThreads = 4;
    
    // 创建大数组
    std::vector<double> data(dataSize, 1.0);
    
    // 存储future
    std::vector<std::future<double>> futures;
    
    // 启动异步任务
    size_t chunkSize = dataSize / numThreads;
    for (size_t i = 0; i < numThreads; ++i) {
        size_t start = i * chunkSize;
        size_t end = (i == numThreads - 1) ? dataSize : (i + 1) * chunkSize;
        
        futures.push_back(
            std::async(std::launch::async, calculatePartialSum, std::ref(data), start, end)
        );
    }
    
    // 收集结果
    double sum = 0.0;
    for (auto& future : futures) {
        sum += future.get();
    }
    
    std::cout << "Sum: " << sum << std::endl;
    
    return 0;
}
```

## 10. 可变参数模板和完美转发
可变参数模板允许函数接受任意数量和类型的参数，而完美转发确保参数的值类别（左值/右值）得到保留。

### 基本的可变参数模板
```cpp
#include <iostream>

// 递归终止函数
void print() {
    std::cout << std::endl;
}

// 可变参数模板函数
template<typename T, typename... Args>
void print(T first, Args... args) {
    std::cout << first << " ";
    print(args...);  // 递归展开剩余参数
}

int main() {
    print(1, 2.5, "hello", 'a');  // 输出: 1 2.5 hello a
    
    return 0;
}
```

### 可变参数模板类
```cpp
#include <iostream>
#include <tuple>

// 可变参数模板类
template<typename... Types>
class Container {
public:
    Container(Types... args) : data(args...) {}
    
    template<size_t Index>
    auto get() -> decltype(std::get<Index>(data)) { // 尾返回类型
        return std::get<Index>(data);
    }
    
private:
    std::tuple<Types...> data;
};

int main() {
    Container<int, double, std::string> container(10, 3.14, "hello");
    
    std::cout << container.get<0>() << std::endl;  // 输出: 10
    std::cout << container.get<1>() << std::endl;  // 输出: 3.14
    std::cout << container.get<2>() << std::endl;  // 输出: hello
    
    return 0;
}
```

### 完美转发
完美转发使用`std::forward`保持参数的值类别（左值/右值）特性。

```cpp
#include <iostream>
#include <string>
#include <utility>

class Resource {
private:
    std::string data;
    
public:
    // 从字符串构造
    Resource(const std::string& s) : data(s) {
        std::cout << "复制构造: " << data << std::endl;
    }
    
    // 从右值字符串构造（移动）
    Resource(std::string&& s) : data(std::move(s)) {
        std::cout << "移动构造: " << data << std::endl;
    }
};

// 普通函数 - 总是复制参数
template<typename T>
void makeResource1(T arg) {
    Resource r(arg);  // arg 总是左值，只能复制
}

// 完美转发 - 保持参数的值类别
template<typename T>
void makeResource2(T&& arg) {
    Resource r(std::forward<T>(arg));  // 保持原始的左值/右值特性
}

int main() {
    std::string str = "Hello";
    
    std::cout << "=== 普通函数 ===" << std::endl;
    makeResource1(str);                    // 复制
    makeResource1(std::string("World"));   // 还是复制（右值被复制到参数）
    
    std::cout << "\n=== 完美转发 ===" << std::endl;
    makeResource2(str);                    // 复制（左值）
    makeResource2(std::string("World"));   // 移动（右值）
    
    return 0;
}
```

### std::forward 与 std::move
+ `std::forward` 是一个**条件性**的转换：它仅在参数被绑定到一个右值时，才将参数转换为右值
+ `std::move` 是**无条件的**：它总是将参数转换为右值，用于表示资源的所有权转移

```cpp
#include <iostream>
#include <utility>
#include <string>

void process(std::string& str) {
    std::cout << "Called with lvalue: " << str << std::endl;
}

void process(std::string&& str) {
    std::cout << "Called with rvalue: " << str << std::endl;
}

// 函数模板使用完美转发
template<typename T>
void forwardingFunction(T&& param) {
    std::cout << "Before forwarding: ";
    process(param);  // 总是调用左值版本
    
    std::cout << "After std::forward: ";
    process(std::forward<T>(param));  // 根据T的类型调用对应版本
    
    std::cout << "After std::move: ";
    process(std::move(param));  // 总是调用右值版本
}

int main() {
    std::string str = "Hello";
    
    std::cout << "Calling with lvalue:\n";
    forwardingFunction(str);
    
    std::cout << "\nCalling with rvalue:\n";
    forwardingFunction(std::string("World"));
    
    return 0;
}
```

## 11. 移动语义和右值引用
C++11引入了移动语义，允许资源（如动态内存）的所有权从一个对象转移到另一个对象，而不是复制这些资源。

### 右值引用基础
```cpp
#include <iostream>
#include <string>

// 接受左值引用的函数
void processLValue(std::string& str) {
    std::cout << "LValue: " << str << std::endl;
}

// 接受右值引用的函数
void processRValue(std::string&& str) {
    std::cout << "RValue: " << str << std::endl;
}

int main() {
    std::string hello = "Hello";
    
    processLValue(hello);  // 使用左值
    // processRValue(hello);  // 错误：不能将左值绑定到右值引用
    
    processRValue(std::move(hello));  // 将左值转换为右值
    processRValue("World");  // 字面量是右值
    processRValue(std::string("Temporary"));  // 临时对象是右值
    
    // 使用std::move后，不应再使用hello（除非重新赋值）
    std::cout << "After move: " << hello << std::endl;  // 可能为空或未定义状态
    
    return 0;
}
```

### 自定义类的移动语义
```cpp
#include <iostream>
#include <vector>
#include <utility>

class DataContainer {
public:
    // 构造函数
    DataContainer(size_t size) : data_(new int[size]), size_(size) {
        std::cout << "Constructor: allocated " << size << " integers at " << data_ << std::endl;
    }
    
    // 析构函数
    ~DataContainer() {
        if (data_) {
            std::cout << "Destructor: freeing memory at " << data_ << std::endl;
            delete[] data_;
        }
    }
    
    // 拷贝构造函数
    DataContainer(const DataContainer& other) 
        : data_(new int[other.size_]), size_(other.size_) {
        std::cout << "Copy constructor: copying " << size_ << " integers" << std::endl;
        std::copy(other.data_, other.data_ + size_, data_);
    }
    
    // 拷贝赋值运算符
    DataContainer& operator=(const DataContainer& other) {
        if (this != &other) {
            std::cout << "Copy assignment: copying " << other.size_ << " integers" << std::endl;
            delete[] data_;
            data_ = new int[other.size_];
            size_ = other.size_;
            std::copy(other.data_, other.data_ + size_, data_);
        }
        return *this;
    }
    
    // 移动构造函数
    DataContainer(DataContainer&& other) noexcept 
        : data_(other.data_), size_(other.size_) {
        std::cout << "Move constructor: stealing " << size_ << " integers from " << other.data_ << std::endl;
        // 将源对象置于有效但可析构的状态
        other.data_ = nullptr;
        other.size_ = 0;
    }
    
    // 移动赋值运算符
    DataContainer& operator=(DataContainer&& other) noexcept {
        if (this != &other) {
            std::cout << "Move assignment: stealing " << other.size_ << " integers from " << other.data_ << std::endl;
            delete[] data_;
            // 转移资源
            data_ = other.data_;
            size_ = other.size_;
            // 将源对象置于有效但可析构的状态
            other.data_ = nullptr;
            other.size_ = 0;
        }
        return *this;
    }
    
    // 获取数据指针（仅作示例）
    int* data() const { return data_; }
    
    // 获取大小
    size_t size() const { return size_; }
    
private:
    int* data_;
    size_t size_;
};

int main() {
    // 创建对象
    DataContainer d1(10);
    
    // 拷贝构造
    DataContainer d2 = d1;  // 调用拷贝构造函数
    
    // 移动构造
    DataContainer d3 = std::move(d1);  // 调用移动构造函数
    
    // 验证d1已被移动
    std::cout << "d1 data: " << d1.data() << ", size: " << d1.size() << std::endl;
    
    // 拷贝赋值
    DataContainer d4(5);
    d4 = d2;  // 调用拷贝赋值运算符
    
    // 移动赋值
    DataContainer d5(5);
    d5 = std::move(d2);  // 调用移动赋值运算符
    
    // 验证d2已被移动
    std::cout << "d2 data: " << d2.data() << ", size: " << d2.size() << std::endl;
    
    return 0;
}
```

## 12. std::tuple、std::apply
`std::tuple`是一个固定大小的异构值集合，而`std::apply`允许将函数应用于元组的所有元素。

### std::tuple基础
```cpp
#include <iostream>
#include <tuple>
#include <string>

int main() {
    // 创建元组
    std::tuple<int, double, std::string> t1(42, 3.14, "Hello");
    
    // 使用std::make_tuple
    auto t2 = std::make_tuple(10, 2.5, "World");
    
    // 获取元素
    std::cout << "t1 elements: " 
              << std::get<0>(t1) << ", " 
              << std::get<1>(t1) << ", " 
              << std::get<2>(t1) << std::endl;
    
    // 使用类型索引（C++14）
    std::cout << "t1 string element: " << std::get<std::string>(t1) << std::endl;
    
    // 修改元素
    std::get<0>(t1) = 100;
    
    // 解包元组
    int i;
    double d;
    std::string s;
    std::tie(i, d, s) = t1;
    
    std::cout << "Unpacked: " << i << ", " << d << ", " << s << std::endl;
    
    // 合并元组
    auto t3 = std::tuple_cat(t1, t2);
    
    // 获取元组大小
    std::cout << "t3 size: " << std::tuple_size<decltype(t3)>::value << std::endl;
    
    return 0;
}
```

### std::apply（C++17）
虽然`std::apply`是C++17引入的，但这里提前介绍，因为在线程池实现中经常会用到类似功能：

```cpp
#include <iostream>
#include <tuple>
#include <functional>

int sum(int a, int b, int c) {
    return a + b + c;
}

int main() {
    auto t = std::make_tuple(1, 2, 3);
    
    // 使用std::apply (C++17)
    int result = std::apply(sum, t);
    std::cout << "Sum: " << result << std::endl;
    
    return 0;
}
```

std::apply是一个函数，它接受一个可调用对象和一个元组，然后将元组中的元素解包作为参数传递给可调用对象。简单来说，它能把元组中的每个元素"应用"到函数的对应参数位置上，免去了手动解包元组的麻烦。在线程池实现中，这非常有用，因为我们经常需要将存储在元组中的参数传递给任务函数。

## 13. std::invoke_result 和 decltype
### std::invoke_result
`std::invoke_result` 是 C++17 引入的类型特征（type trait），它用于获取调用可调用对象（函数、函数指针、函数对象、lambda 表达式等）的返回类型。它是 C++11 中引入的 `std::result_of` 的改进版本。

```cpp
#include <iostream>
#include <functional>
#include <type_traits>
#include <string>

// 示例函数
int add(int a, int b) {
    return a + b;
}

class Calculator {
public:
double multiply(double a, double b) const {
    return a * b;
}
};

int main() {
    // 获取普通函数的返回类型
    using AddResult = std::invoke_result<decltype(add), int, int>::type;
    static_assert(std::is_same_v<AddResult, int>, "Add should return int");

    // 获取成员函数的返回类型
    Calculator calc;
    using MultResult = std::invoke_result<decltype(&Calculator::multiply), Calculator, double, double
        >::type;
    static_assert(std::is_same_v<MultResult, double>, "Multiply should return double");

    // 获取lambda的返回类型
    auto strConcat = [](const std::string& a, const std::string& b) {
        return a + b;
    };
    using ConcatResult = std::invoke_result<decltype(strConcat), std::string, std::string
        >::type;

    // 使用推导出的类型
    AddResult sum = add(5, 3);
    MultResult product = calc.multiply(2.5, 4.0);
    ConcatResult fullName = strConcat("John", "Doe");

    std::cout << "Sum: " << sum << std::endl;
    std::cout << "Product: " << product << std::endl;
    std::cout << "Full name: " << fullName << std::endl;

    return 0;
}
```

在模板编程和泛型代码中，`std::invoke_result` 特别有用，它可以让我们提前知道调用某个函数会得到什么类型的结果，从而在编译期做出相应决策。在线程池实现中，这可以帮助我们正确处理任务的返回值类型。

### 区别与联系？
`decltype` 和 `std::invoke_result` 虽然都用于类型推导，但它们有明显的区别：

#### 用途不同： 
+ `decltype` 是一个通用的类型获取工具，可用于任何表达式
+ `std::invoke_result` 专门用于获取调用可调用对象时的返回类型

#### 语法不同： 
+ `decltype` 是语言级别的关键字，直接作用于表达式
+ `std::invoke_result` 是一个模板元编程工具，需要指定可调用对象和参数类型

#### 使用场景： 
+ 当你有一个表达式并想知道它的类型时，使用 `decltype`
+ 当你有一个函数/可调用对象，想在不调用它的情况下知道其返回类型时，使用 `std::invoke_result`

这两个工具在现代 C++ 中都是类型系统和模板元编程的重要组成部分，掌握它们有助于编写更灵活、类型安全的代码。

## 14. 异常处理与传播
在线程池中，异常处理是一个重要方面，尤其是在异步任务中如何传播异常。

### 基本异常处理
```cpp
#include <iostream>
#include <stdexcept>

void riskyFunction(int value) {
    if (value < 0) {
        throw std::invalid_argument("Value cannot be negative");
    } else if (value == 0) {
        throw std::runtime_error("Value cannot be zero");
    }
    std::cout << "Processing value: " << value << std::endl;
}

int main() {
    try {
        riskyFunction(5);  // 正常执行
        riskyFunction(0);  // 抛出runtime_error
    } catch (const std::invalid_argument& e) {
        std::cerr << "Invalid argument: " << e.what() << std::endl;
    } catch (const std::runtime_error& e) {
        std::cerr << "Runtime error: " << e.what() << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Standard exception: " << e.what() << std::endl;
    } catch (...) {
        std::cerr << "Unknown exception caught" << std::endl;
    }
    
    return 0;
}
```

### 异常在线程间的传播
线程中的异常不会自动传播到其他线程。我们可以使用`std::promise`和`std::future`来传递异常：

```cpp
#include <iostream>
#include <thread>
#include <future>
#include <stdexcept>

void threadFunction(std::promise<int> resultPromise) {
    try {
        // 模拟计算
        throw std::runtime_error("Something went wrong");
        
        // 正常情况下设置结果
        resultPromise.set_value(42);
    } catch (...) {
        // 捕获所有异常并通过promise传递
        resultPromise.set_exception(std::current_exception());
    }
}

int main() {
    std::promise<int> promise;
    std::future<int> future = promise.get_future();
    
    std::thread t(threadFunction, std::move(promise));
    
    try {
        // 尝试获取结果
        int result = future.get();
        std::cout << "Result: " << result << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Exception from thread: " << e.what() << std::endl;
    }
    
    t.join();
    return 0;
}
```

### std::current_exception 和 std::rethrow_exception
这些函数可以捕获和重新抛出异常，在线程池中很有用：

```cpp
#include <iostream>
#include <exception>

void processSafely(const std::function<void()>& func) {
    try {
        func();
    } catch (...) {
        // 保存当前异常
        std::exception_ptr eptr = std::current_exception();
        
        // 记录异常信息
        try {
            if (eptr) {
                std::rethrow_exception(eptr);
            }
        } catch (const std::exception& e) {
            std::cerr << "Caught exception: " << e.what() << std::endl;
        }
    }
}

int main() {
    processSafely([]() {
        throw std::runtime_error("Test exception");
    });
    
    return 0;
}
```



## 结尾

### 进阶实战课程推荐

学会了这些C++11/14/17新特性，下一步就是在实际项目中应用它们！

我目前开设了两个项目实战课程，正好用到了今天介绍的大部分特性：

🔥 **C++高性能线程池项目实战**

+  7天从零实现工业级线程池，突破任务调度、异步编程、异常处理三大难点  

🔥 **MySQL连接池项目实战**

+  8天搭建高性能连接池，攻克负载均衡、自动重连、性能监控核心技术  

**详情可访问**:


两个课程都是从零开始手写代码，逐行解析设计思路，非常适合想要提升项目实战能力的同学。

---

希望这篇文章对你有帮助！**关注我，持续分享C++干货** 💪



## 🚀 跟我学，你能收获啥？

在这里，你不仅能看到干货，还能真正学到能用的技能：

+ **Linux 实战技巧**：服务器调优、常用命令、Shell 脚本，让你像高手一样操作系统。
+ **C/C++ 后台开发**：从基础语法到高性能编程，带你写出稳、快、可维护的服务端代码。
+ **C/C++ 项目实战**：真实项目案例，教你从需求到上线完整流程，掌握开发套路和最佳实践。
+ **常用开发工具**：调试、版本控制、构建工具、性能分析工具，让开发效率大幅提升。
+ **性能优化**：CPU/内存/IO 调优技巧，定位瓶颈，让你的程序跑得更快更稳。
+ **项目架构设计**：微服务、分层架构、模块设计思路，帮你构建可扩展、易维护的系统。
+ **Go 后端开发**：微服务、云原生实战，教你用 Go 搭建高并发、高可用系统。
+ **编程面试干货 & 算法**：核心算法套路、面试高频题解析，让你不再手忙脚乱。
+ **计算机基础梳理**：操作系统、网络、数据结构、并发原理，知识体系清晰明了。
+ **成长路线图**：系统规划你的学习路径，从初学到高级，帮你少走弯路。

内容**深入浅出、实用有趣**，再也不用看书看到睡着。  
无论是面试冲刺，还是技能升级，这里都是你的“技术加油站”。


## 👀 想加入？很简单！
**扫一扫下面二维码**，一键关注公众号，开启你的技术学习之旅！

![](https://files.mdnice.com/user/71186/0dde803d-d52f-4ed8-b74b-b7f3da5817b9.png)

另外，我还建了一个**技术交流群**，里面都是认真写代码的小伙伴，不吹牛、不闲聊，只聊技术。  
有问题？大家一块儿讨论，比一个人闷头学效率高多了！

![](https://files.mdnice.com/user/48364/4ebc72e9-e4bb-447a-9a92-8367a178df6d.png)

技术这条路，一个人走容易迷路，一群人走才有方向。  
跟上节奏，我们一起变强 💪

