
å„ä½å°ä¼™ä¼´ï¼Œå¤§å®¶å¥½ï¼æˆ‘æ˜¯å°åº·ã€‚

éšç€ç°ä»£C++çš„å¿«é€Ÿå‘å±•ï¼ŒC++11/14/17å¼•å…¥çš„æ–°ç‰¹æ€§å·²ç»æˆä¸ºæ¯ä¸ªC++ç¨‹åºå‘˜å¿…é¡»æŒæ¡çš„æ ¸å¿ƒæŠ€èƒ½ã€‚æ— è®ºä½ æ˜¯å‡†å¤‡æŠ€æœ¯é¢è¯•ï¼Œè¿˜æ˜¯æƒ³æå‡é¡¹ç›®å¼€å‘æ•ˆç‡ï¼Œè¿™äº›æ–°ç‰¹æ€§éƒ½æ˜¯ä¸å¯æˆ–ç¼ºçš„ã€‚

åœ¨æˆ‘æœ€è¿‘çš„ **C++é¡¹ç›®å®æˆ˜è¯¾ç¨‹**ä¸­ï¼Œå¾ˆå¤šåŒå­¦éƒ½åæ˜ å¯¹è¿™äº›æ–°ç‰¹æ€§çš„ç†è§£è¿˜ä¸å¤Ÿæ·±å…¥ï¼Œç‰¹åˆ«æ˜¯åœ¨å®é™…é¡¹ç›®ä¸­å¦‚ä½•åº”ç”¨ã€‚ä»Šå¤©æˆ‘å°±æŠŠè¯¾ç¨‹ä¸­çš„æ ¸å¿ƒå†…å®¹åˆ†äº«ç»™å¤§å®¶ï¼Œå¸®åŠ©ä½ ä»¬ç³»ç»Ÿæ€§åœ°æŒæ¡è¿™äº›é‡è¦ç‰¹æ€§ã€‚

è¿™ç¯‡æ–‡ç« æ¶µç›–äº†**14ä¸ªæ ¸å¿ƒä¸»é¢˜**ï¼Œæ¯ä¸ªéƒ½é…æœ‰è¯¦ç»†çš„ä»£ç ç¤ºä¾‹å’Œå®é™…åº”ç”¨åœºæ™¯ã€‚å­¦å®Œè¿™äº›å†…å®¹ï¼Œä½ å°†èƒ½å¤Ÿï¼š

+ âœ… ç†Ÿç»ƒä½¿ç”¨ç°ä»£C++çš„å¹¶å‘ç¼–ç¨‹ç‰¹æ€§
+ âœ… æŒæ¡æ™ºèƒ½æŒ‡é’ˆå’Œå†…å­˜ç®¡ç†æœ€ä½³å®è·µ
+ âœ… ç†è§£ç§»åŠ¨è¯­ä¹‰å’Œå®Œç¾è½¬å‘çš„ç²¾é«“
+ âœ… å…·å¤‡å¼€å‘é«˜æ€§èƒ½C++é¡¹ç›®çš„èƒ½åŠ›



**å¸¸è§çš„ C++11/14/17 æ–°ç‰¹æ€§åŒ…æ‹¬ï¼š**

1. çº¿ç¨‹åº“ (std::thread)
2. äº’æ–¥é‡å’Œé”
3. æ¡ä»¶å˜é‡
4. Lambda è¡¨è¾¾å¼
5. std::function å’Œ std::bind
6. std::atomic åŸå­æ“ä½œ
7. std::chrono æ—¶é—´åº“
8. æ™ºèƒ½æŒ‡é’ˆ
9. std::future å’Œ std::promiseã€std::packaged_task
10. å¯å˜å‚æ•°æ¨¡æ¿å’Œå®Œç¾è½¬å‘
11. ç§»åŠ¨è¯­ä¹‰å’Œå³å€¼å¼•ç”¨
12. std::make_tuple å’Œ std::apply
13. std::invoke_result å’Œ decltype
14. å¼‚å¸¸å¤„ç†å’Œä¼ æ’­

>æƒ³ç³»ç»Ÿå­¦ä¹ æ›´å¤š C++ çŸ¥è¯†ï¼Ÿæ¬¢è¿å…³æ³¨æˆ‘çš„å…¬ä¼—å·ã€Œ**è·Ÿç€å°åº·ç¼–ç¨‹**ã€ï¼Œæˆ‘ä¼šæŒç»­æ›´æ–° Cã€ C++ã€Linuxã€åç«¯å¼€å‘ç­‰é«˜è´¨é‡æŠ€æœ¯æ–‡ç« ã€‚ä¹Ÿå¯ä»¥åŠ æˆ‘çš„ä¸ªäººå¾®ä¿¡ï¼Œä¸€èµ·è¿›ç¾¤è®¨è®ºå­¦ä¹ ï¼
>
> 
> <table>
> <tr>
> <td align="center">
> <img src="https://github.com/xiaokangcoding/follow-xiaokang-coding/raw/main/images/qrcode-wechat-official.png" width="200">
> <br>
> <em>å…¬ä¼—å·ã€Œè·Ÿç€å­¦å°åº·ç¼–ç¨‹ã€</em>
> </td>
> <td align="center">
> <img src="https://github.com/xiaokangcoding/follow-xiaokang-coding/raw/main/images/qrcode-personal-wechat.png" width="200">
> <br>
> <em>ä¸ªäººå¾®ä¿¡ï¼ˆå¤‡æ³¨ï¼šåŠ ç¾¤ï¼‰</em>
> </td>
> </tr>
> </table>

## 1. çº¿ç¨‹åº“ (std::thread)
C++11é¦–æ¬¡åœ¨æ ‡å‡†åº“ä¸­æä¾›äº†å¯¹çº¿ç¨‹çš„åŸç”Ÿæ”¯æŒï¼Œè®©æˆ‘ä»¬å¯ä»¥åˆ›å»ºå’Œç®¡ç†çº¿ç¨‹ã€‚

### åŸºæœ¬ç”¨æ³•
```cpp
#include <iostream>
#include <thread>

void hello() {
    std::cout << "Hello from thread!" << std::endl;
}

int main() {
    // åˆ›å»ºçº¿ç¨‹
    std::thread t(hello);
    
    // ç­‰å¾…çº¿ç¨‹å®Œæˆ
    t.join();
    
    return 0;
}
```

### å‘çº¿ç¨‹ä¼ é€’å‚æ•°
```cpp
#include <iostream>
#include <thread>
#include <string>

void printMessage(int id, const std::string& message) {
    std::cout << "Thread " << id << ": " << message << std::endl;
}

int main() {
    // å‘çº¿ç¨‹å‡½æ•°ä¼ é€’å‚æ•°
    std::thread t(printMessage, 1, "Hello World");
    t.join();
    
    return 0;
}
```

### çº¿ç¨‹æ–¹æ³•
+ `join()`: ç­‰å¾…çº¿ç¨‹å®Œæˆ
+ `detach()`: å°†çº¿ç¨‹ä¸è°ƒç”¨è€…åˆ†ç¦»ï¼Œå…è®¸ç‹¬ç«‹è¿è¡Œ
+ `joinable()`: æ£€æŸ¥çº¿ç¨‹æ˜¯å¦å¯ä»¥join()
+ `get_id()`: è·å–çº¿ç¨‹ID
+ `hardware_concurrency()`: è¿”å›ç³»ç»Ÿæ”¯æŒçš„å¹¶å‘çº¿ç¨‹æ•°

### æ³¨æ„äº‹é¡¹
+ å¿…é¡»åœ¨çº¿ç¨‹å¯¹è±¡é”€æ¯å‰è°ƒç”¨`join()`æˆ–`detach()`ï¼Œå¦åˆ™ç¨‹åºä¼šç»ˆæ­¢
+ ä½¿ç”¨`detach()`åï¼Œå¿…é¡»ç¡®ä¿çº¿ç¨‹è®¿é—®çš„èµ„æºåœ¨çº¿ç¨‹ç»“æŸå‰ä¸ä¼šè¢«é”€æ¯

## 2. äº’æ–¥é‡å’Œé” (std::mutex, std::lock_guard, std::unique_lock)
å½“å¤šä¸ªçº¿ç¨‹è®¿é—®å…±äº«èµ„æºæ—¶ï¼Œéœ€è¦äº’æ–¥é‡æ¥é˜²æ­¢æ•°æ®ç«äº‰ã€‚

### åŸºæœ¬çš„äº’æ–¥é‡
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <vector>

std::mutex mtx;  // ä¿æŠ¤å…±äº«æ•°æ®çš„äº’æ–¥é‡
std::vector<int> data;  // å…±äº«æ•°æ®

void addToVector(int value) {
    mtx.lock();  // è·å–é”
    // ä¸´ç•ŒåŒºåŸŸå†…çš„æ“ä½œæ˜¯å®‰å…¨çš„
    data.push_back(value);
    std::cout << "Added: " << value << std::endl;
    mtx.unlock();  // é‡Šæ”¾é”
}

int main() {
    std::thread t1(addToVector, 10);
    std::thread t2(addToVector, 20);
    
    t1.join();
    t2.join();
    
    return 0;
}
```

### ä½¿ç”¨RAIIé”åŒ…è£…å™¨
æ‰‹åŠ¨è°ƒç”¨`lock()`å’Œ`unlock()`å®¹æ˜“å¿˜è®°é‡Šæ”¾é”æˆ–å‡ºç°å¼‚å¸¸å¯¼è‡´æ­»é”ã€‚C++11å¼•å…¥äº†RAIIé”åŒ…è£…å™¨ï¼š

#### std::lock_guardï¼ˆåŸºæœ¬é”ï¼‰
```cpp
void addToVector(int value) {
    // æ„é€ æ—¶è‡ªåŠ¨é”å®šï¼Œææ„æ—¶è‡ªåŠ¨è§£é”
    std::lock_guard<std::mutex> lock(mtx);
    data.push_back(value);
    std::cout << "Added: " << value << std::endl;
}
```

#### std::unique_lockï¼ˆæ›´çµæ´»çš„é”ï¼‰
```cpp
void processData() {
    // æ¯”lock_guardæ›´çµæ´»ï¼Œæ”¯æŒæ‰‹åŠ¨è§£é”å’Œé‡æ–°é”å®š
    std::unique_lock<std::mutex> lock(mtx);
    
    // é¢„å¤„ç†å·¥ä½œ
    
    // ä¸´æ—¶é‡Šæ”¾é”ï¼Œå…è®¸å…¶ä»–çº¿ç¨‹è®¿é—®
    lock.unlock();
    
    // æ‰§è¡Œä¸éœ€è¦é”çš„è®¡ç®—
    
    // é‡æ–°è·å–é”
    lock.lock();
    
    // æ›´æ–°å…±äº«æ•°æ®
}
```

### å…¶ä»–é”ç±»å‹
+ `std::shared_lock`: æ”¯æŒå¤šä¸ªè¯»çº¿ç¨‹çš„å…±äº«è®¿é—®
+ `std::scoped_lock`(C++17): åŒæ—¶é”å®šå¤šä¸ªäº’æ–¥é‡ï¼Œé˜²æ­¢æ­»é”

## 3. æ¡ä»¶å˜é‡ (std::condition_variable)
æ¡ä»¶å˜é‡ç”¨äºçº¿ç¨‹é—´çš„é€šçŸ¥æœºåˆ¶ï¼Œå½“æŸä¸ªæ¡ä»¶æ»¡è¶³æ—¶ï¼Œä¸€ä¸ªçº¿ç¨‹å¯ä»¥é€šçŸ¥å…¶ä»–ç­‰å¾…çš„çº¿ç¨‹ã€‚

### åŸºæœ¬ç”¨æ³•
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>

std::mutex mtx;
std::condition_variable cv;
std::queue<int> taskQueue;

// æ¶ˆè´¹è€…çº¿ç¨‹
void consumer() {
    while (true) {
        int task;
        
        {
            // ä½¿ç”¨unique_lockï¼Œå› ä¸ºæ¡ä»¶å˜é‡éœ€è¦å®ƒ
            std::unique_lock<std::mutex> lock(mtx);
            
            // ç­‰å¾…æ¡ä»¶ï¼šé˜Ÿåˆ—éç©º
            cv.wait(lock, []{ return !taskQueue.empty(); });
            
            // è·å–ä»»åŠ¡
            task = taskQueue.front();
            taskQueue.pop();
        }
        
        // å¤„ç†ä»»åŠ¡
        std::cout << "Processing task: " << task << std::endl;
        
        if (task == -1) break;  // ç»ˆæ­¢ä¿¡å·
    }
}

// ç”Ÿäº§è€…çº¿ç¨‹
void producer() {
    for (int i = 1; i <= 5; ++i) {
        {
            std::lock_guard<std::mutex> lock(mtx);
            taskQueue.push(i);
            std::cout << "Added task: " << i << std::endl;
        }
        
        // é€šçŸ¥ä¸€ä¸ªç­‰å¾…çš„çº¿ç¨‹
        cv.notify_one();
        
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    
    // å‘é€ç»ˆæ­¢ä¿¡å·
    {
        std::lock_guard<std::mutex> lock(mtx);
        taskQueue.push(-1);
    }
    cv.notify_one();
}

int main() {
    std::thread con(consumer);
    std::thread prod(producer);
    
    prod.join();
    con.join();
    
    return 0;
}
```

### æ¡ä»¶å˜é‡æ–¹æ³•
+ `wait()`: ç­‰å¾…é€šçŸ¥ï¼Œå¯ä»¥æä¾›è°“è¯æ¡ä»¶
+ `wait_for()`: ç­‰å¾…é€šçŸ¥ï¼Œä½†æœ€å¤šç­‰å¾…æŒ‡å®šçš„æ—¶é—´
+ `wait_until()`: ç­‰å¾…é€šçŸ¥ï¼Œç›´åˆ°æŒ‡å®šçš„æ—¶é—´ç‚¹
+ `notify_one()`: é€šçŸ¥ä¸€ä¸ªç­‰å¾…çš„çº¿ç¨‹
+ `notify_all()`: é€šçŸ¥æ‰€æœ‰ç­‰å¾…çš„çº¿ç¨‹

## 4. Lambdaè¡¨è¾¾å¼
Lambdaè¡¨è¾¾å¼æ˜¯C++11ä¸­å¼•å…¥çš„ä¸€ä¸ªå¼ºå¤§ç‰¹æ€§ï¼Œå…è®¸å®šä¹‰åŒ¿åå‡½æ•°å¯¹è±¡ã€‚

### åŸºæœ¬è¯­æ³•
```cpp
[ capture-list ] ( parameters ) -> return-type { body }
```

+ `capture-list`ï¼šæ•è·å¤–éƒ¨å˜é‡çš„åˆ—è¡¨
+ `parameters`ï¼šå‚æ•°åˆ—è¡¨
+ `return-type`ï¼šè¿”å›ç±»å‹ï¼ˆå¯é€‰ï¼Œç¼–è¯‘å™¨é€šå¸¸å¯ä»¥æ¨å¯¼ï¼‰
+ `body`ï¼šå‡½æ•°ä½“

### ç¤ºä¾‹
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    int factor = 2;
    
    // Lambdaè¡¨è¾¾å¼ï¼Œæ•è·å¤–éƒ¨å˜é‡factor
    auto multiply = [factor](int x) { return x * factor; };
    
    // ä½¿ç”¨Lambdaä¸ç®—æ³•
    std::transform(numbers.begin(), numbers.end(), numbers.begin(), multiply);
    
    // æ‰“å°ç»“æœ
    for (int n : numbers) {
        std::cout << n << " ";
    }
    std::cout << std::endl;
    
    // ç›´æ¥åœ¨ç®—æ³•ä¸­ä½¿ç”¨Lambda
    int sum = 0;
    std::for_each(numbers.begin(), numbers.end(), [&sum](int x) {
        sum += x;
    });
    
    std::cout << "Sum: " << sum << std::endl;
    
    return 0;
}
```

### æ•è·åˆ—è¡¨
+ `[]`: ä¸æ•è·ä»»ä½•å˜é‡
+ `[=]`: ä»¥å€¼æ–¹å¼æ•è·æ‰€æœ‰å¤–éƒ¨å˜é‡
+ `[&]`: ä»¥å¼•ç”¨æ–¹å¼æ•è·æ‰€æœ‰å¤–éƒ¨å˜é‡
+ `[var]`: ä»¥å€¼æ–¹å¼æ•è·å˜é‡var
+ `[&var]`: ä»¥å¼•ç”¨æ–¹å¼æ•è·å˜é‡var
+ `[=, &var]`: ä»¥å€¼æ–¹å¼æ•è·æ‰€æœ‰å˜é‡ï¼Œä½†varä»¥å¼•ç”¨æ–¹å¼æ•è·
+ `[&, var]`: ä»¥å¼•ç”¨æ–¹å¼æ•è·æ‰€æœ‰å˜é‡ï¼Œä½†varä»¥å€¼æ–¹å¼æ•è·

### mutableå…³é”®å­—
é»˜è®¤æƒ…å†µä¸‹ï¼Œä»¥å€¼æ–¹å¼æ•è·çš„å˜é‡åœ¨Lambdaä¸­æ˜¯åªè¯»çš„ã€‚ä½¿ç”¨`mutable`å¯ä»¥ä¿®æ”¹å®ƒä»¬çš„å‰¯æœ¬ï¼š

```cpp
int counter = 0;
auto increment = [counter]() mutable { return ++counter; };
```

## 5. std::functionå’Œstd::bind
### std::function
`std::function`æ˜¯ä¸€ä¸ªå‡½æ•°åŒ…è£…å™¨ï¼Œå¯ä»¥å­˜å‚¨ã€å¤åˆ¶å’Œè°ƒç”¨ä»»ä½•å¯è°ƒç”¨ç›®æ ‡ï¼Œå¦‚æ™®é€šå‡½æ•°ã€Lambdaè¡¨è¾¾å¼ã€å‡½æ•°å¯¹è±¡ç­‰ã€‚

```cpp
#include <iostream>
#include <functional>

// æ™®é€šå‡½æ•°
int add(int a, int b) {
    return a + b;
}

// å‡½æ•°å¯¹è±¡
struct Multiplier {
    int operator()(int a, int b) const {
        return a * b;
    }
};

int main() {
    // å­˜å‚¨æ™®é€šå‡½æ•°
    std::function<int(int, int)> operation = add;
    std::cout << "Add: " << operation(3, 4) << std::endl;
    
    // å­˜å‚¨Lambdaè¡¨è¾¾å¼
    operation = [](int a, int b) { return a - b; };
    std::cout << "Subtract: " << operation(7, 3) << std::endl;
    
    // å­˜å‚¨å‡½æ•°å¯¹è±¡
    operation = Multiplier();
    std::cout << "Multiply: " << operation(5, 6) << std::endl;
    
    return 0;
}
```

### std::bind
`std::bind`åˆ›å»ºä¸€ä¸ªæ–°çš„å¯è°ƒç”¨å¯¹è±¡ï¼Œå°†å‚æ•°ç»‘å®šåˆ°æŒ‡å®šçš„å‡½æ•°ã€‚

```cpp
#include <iostream>
#include <functional>

void print(int a, int b, int c) {
    std::cout << a << " " << b << " " << c << std::endl;
}

int main() {
    // ä½¿ç”¨å ä½ç¬¦_1, _2è¡¨ç¤ºå°†æ¥ä¼ å…¥çš„å‚æ•°
    using namespace std::placeholders;
    
    // ç»‘å®šç¬¬ä¸€ä¸ªå‚æ•°ä¸º100
    auto f1 = std::bind(print, 100, _1, _2);
    f1(200, 300);  // æ‰“å°: 100 200 300
    
    // ç»‘å®šç¬¬äºŒä¸ªå‚æ•°ä¸º200
    auto f2 = std::bind(print, _1, 200, _2);
    f2(100, 300);  // æ‰“å°: 100 200 300
    
    // é‡æ–°æ’åºå‚æ•°
    auto f3 = std::bind(print, _3, _1, _2);
    f3(100, 200, 300);  // æ‰“å°: 300 100 200
    
    return 0;
}

```

std::bindçš„ä¼˜åŠ¿åœ¨äºå®ƒèƒ½è®©ä½ çµæ´»åœ°è°ƒæ•´å‡½æ•°è°ƒç”¨æ–¹å¼ï¼Œè€Œä¸éœ€è¦ä¿®æ”¹åŸå‡½æ•°ã€‚ä½ å¯ä»¥é¢„å…ˆå›ºå®šæŸäº›å‚æ•°å€¼ï¼Œæ”¹å˜å‚æ•°é¡ºåºï¼Œæˆ–è€…å°†å¤šå‚æ•°å‡½æ•°è½¬æ¢æˆéœ€è¦æ›´å°‘å‚æ•°çš„æ–°å‡½æ•°ã€‚è¿™åœ¨å›è°ƒæœºåˆ¶ã€æ¥å£é€‚é…å’Œéƒ¨åˆ†å‡½æ•°åº”ç”¨ï¼ˆpartial function applicationï¼‰åœºæ™¯ä¸­ç‰¹åˆ«æœ‰ç”¨ï¼Œè®©ä»£ç æ›´ç®€æ´ã€çµæ´»ã€‚

## 6. åŸå­æ“ä½œ (std::atomic)
åŸå­æ“ä½œæä¾›äº†ä¸€ç§ä¸éœ€è¦äº’æ–¥é‡çš„çº¿ç¨‹åŒæ­¥æ–¹å¼ï¼Œå¸¸ç”¨äºè®¡æ•°å™¨å’Œæ ‡å¿—ä½ã€‚

### åŸºæœ¬ç”¨æ³•
```cpp
#include <iostream>
#include <thread>
#include <atomic>
#include <vector>

std::atomic<int> counter(0);  // åŸå­è®¡æ•°å™¨

void increment() {
    for (int i = 0; i < 1000; ++i) {
        // åŸå­è‡ªå¢ï¼Œæ— éœ€äº’æ–¥é‡
        counter++;
    }
}

int main() {
    std::vector<std::thread> threads;
    
    // åˆ›å»º10ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªçº¿ç¨‹å¢åŠ counter 1000æ¬¡
    for (int i = 0; i < 10; ++i) {
        threads.push_back(std::thread(increment));
    }
    
    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
    for (auto& t : threads) {
        t.join();
    }
    
    // ç»“æœåº”è¯¥æ˜¯10000
    std::cout << "Counter: " << counter << std::endl;
    
    return 0;
}
```

### åŸå­æ ‡å¿—ä½
```cpp
#include <iostream>
#include <thread>
#include <atomic>
#include <chrono>

std::atomic<bool> ready(false);

void worker() {
    // ç­‰å¾…readyå˜ä¸ºtrue
    while (!ready) {
        // ç©ºå¾ªç¯æˆ–ä½¿ç”¨yieldæ”¾å¼ƒæ—¶é—´ç‰‡
        std::this_thread::yield();
    }
    
    std::cout << "Worker started!" << std::endl;
}

int main() {
    std::thread t(worker);
    
    std::this_thread::sleep_for(std::chrono::seconds(1));
    
    // é€šçŸ¥workerçº¿ç¨‹å¼€å§‹å·¥ä½œ
    ready = true;
    
    t.join();
    return 0;
}
```

### å†…å­˜é¡ºåº
`std::atomic`æä¾›äº†ä¸åŒçš„å†…å­˜é¡ºåºé€‰é¡¹ï¼Œæ§åˆ¶æ“ä½œå¦‚ä½•ä¸å…¶ä»–åŸå­æ“ä½œåŒæ­¥ï¼š

```cpp
// ä½¿ç”¨é»˜è®¤é¡ºåºï¼ˆé¡ºåºä¸€è‡´æ€§ï¼Œæœ€å¼ºä½†æœ€æ…¢ï¼‰
counter++;

// ä½¿ç”¨æ”¾æ¾é¡ºåºï¼ˆæœ€å¼±ä½†æœ€å¿«ï¼‰
counter.fetch_add(1, std::memory_order_relaxed);

// ä½¿ç”¨è·å–-é‡Šæ”¾é¡ºåºï¼ˆé€‚åˆç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼ï¼‰
counter.fetch_add(1, std::memory_order_release);  // ç”Ÿäº§è€…
int value = counter.load(std::memory_order_acquire);  // æ¶ˆè´¹è€…
```

## 7. std::chronoåº“
C++11å¼•å…¥äº†`std::chrono`åº“ç”¨äºæ—¶é—´å’Œè®¡æ—¶ã€‚

### æ—¶é•¿ (duration)
```cpp
#include <iostream>
#include <chrono>
#include <thread>

int main() {
    // æ—¶é•¿ç±»å‹
    std::chrono::seconds sec(1);  // 1ç§’
    std::chrono::milliseconds msec(1000);  // 1000æ¯«ç§’
    std::chrono::microseconds usec = 2 * sec;  // 2ç§’è½¬æ¢ä¸ºå¾®ç§’
    
    // ä¼‘çœ çº¿ç¨‹
    std::this_thread::sleep_for(std::chrono::milliseconds(500));
    
    // è®¡æ—¶æ“ä½œ
    auto start = std::chrono::high_resolution_clock::now();
    
    // æ‰§è¡Œä¸€äº›æ“ä½œ
    for (volatile int i = 0; i < 1000000; ++i) {}
    
    auto end = std::chrono::high_resolution_clock::now();
    
    // è®¡ç®—ç»è¿‡çš„æ—¶é—´
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    std::cout << "Operation took " << duration.count() << " milliseconds" << std::endl;
    
    return 0;
}
```

---

æœ¬æ–‡ä»‹ç»äº†å®ç°çº¿ç¨‹æ± æ‰€éœ€çš„C++11åŸºç¡€ç‰¹æ€§ã€‚åœ¨ä¸‹ä¸€ç¯‡ä¸­ï¼Œæˆ‘ä»¬å°†ç»§ç»­å­¦ä¹ æ›´é«˜çº§çš„ç‰¹æ€§ï¼ŒåŒ…æ‹¬æ™ºèƒ½æŒ‡é’ˆã€future/promiseã€å¯å˜å‚æ•°æ¨¡æ¿å’Œç§»åŠ¨è¯­ä¹‰ç­‰ã€‚

## 8. æ™ºèƒ½æŒ‡é’ˆ
æ™ºèƒ½æŒ‡é’ˆæ˜¯C++11ä¸­çš„ä¸€é¡¹é‡è¦ç‰¹æ€§ï¼Œç”¨äºè‡ªåŠ¨ç®¡ç†åŠ¨æ€åˆ†é…çš„å†…å­˜ï¼Œé¿å…å†…å­˜æ³„æ¼ã€‚

### std::shared_ptr
`std::shared_ptr`å®ç°å…±äº«æ‰€æœ‰æƒï¼Œå¤šä¸ªæ™ºèƒ½æŒ‡é’ˆå¯ä»¥æŒ‡å‘åŒä¸€ä¸ªå¯¹è±¡ï¼Œå½“æœ€åä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆè¢«é”€æ¯æ—¶ï¼Œå¯¹è±¡ä¼šè¢«è‡ªåŠ¨åˆ é™¤ã€‚

```cpp
#include <iostream>
#include <memory>

class Resource {
public:
    Resource() { std::cout << "Resource acquired\n"; }
    ~Resource() { std::cout << "Resource released\n"; }
    void use() { std::cout << "Resource used\n"; }
};

int main() {
    // åˆ›å»ºshared_ptr
    std::shared_ptr<Resource> sp1 = std::make_shared<Resource>();
    
    {
        // åˆ›å»ºå¦ä¸€ä¸ªæŒ‡å‘åŒä¸€èµ„æºçš„shared_ptr
        std::shared_ptr<Resource> sp2 = sp1;
        std::cout << "Count: " << sp1.use_count() << std::endl;  // è¾“å‡º2
        
        sp2->use();  // ä½¿ç”¨èµ„æº
    }  // sp2ç¦»å¼€ä½œç”¨åŸŸï¼Œä½†èµ„æºä¸ä¼šè¢«é‡Šæ”¾
    
    std::cout << "Count: " << sp1.use_count() << std::endl;  // è¾“å‡º1
    sp1->use();  // èµ„æºä»ç„¶å¯ç”¨
    
    sp1.reset();  // æ˜¾å¼é‡Šæ”¾èµ„æº
    
    return 0;
}
```

### std::unique_ptr
`std::unique_ptr`å®ç°ç‹¬å æ‰€æœ‰æƒï¼Œä¸€ä¸ªèµ„æºåªèƒ½ç”±ä¸€ä¸ª`unique_ptr`æ‹¥æœ‰ï¼Œä¸èƒ½å¤åˆ¶ï¼Œä½†å¯ä»¥ç§»åŠ¨ã€‚

```cpp
#include <iostream>
#include <memory>
#include <vector>

class Resource {
public:
    Resource(int id) : id_(id) { 
        std::cout << "Resource " << id_ << " acquired\n"; 
    }
    ~Resource() { 
        std::cout << "Resource " << id_ << " released\n"; 
    }
    void use() { 
        std::cout << "Resource " << id_ << " used\n"; 
    }
private:
    int id_;
};

int main() {
    // åˆ›å»ºunique_ptr
    std::unique_ptr<Resource> up1 = std::make_unique<Resource>(1);
    
    // ä½¿ç”¨èµ„æº
    up1->use();
    
    // ä¸èƒ½å¤åˆ¶
    // std::unique_ptr<Resource> up2 = up1;  // ç¼–è¯‘é”™è¯¯
    
    // ä½†å¯ä»¥ç§»åŠ¨
    std::unique_ptr<Resource> up2 = std::move(up1);// ç§»åŠ¨æ“ä½œå®é™…ä¸Šå‘ç”Ÿåœ¨èµ‹å€¼è¯­å¥æ‰§è¡Œæ—¶ï¼Œè€Œä¸æ˜¯åœ¨è°ƒç”¨ std::move() å‡½æ•°çš„æ—¶å€™ã€‚
    
    // åŸæŒ‡é’ˆç°åœ¨ä¸ºç©º
    if (!up1) {
        std::cout << "up1 is null\n";
    }
    
    // æ–°æŒ‡é’ˆæœ‰æ•ˆ
    up2->use();
    
    // åœ¨å®¹å™¨ä¸­å­˜å‚¨unique_ptr
    std::vector<std::unique_ptr<Resource>> resources;
    resources.push_back(std::make_unique<Resource>(2));
    resources.push_back(std::make_unique<Resource>(3));
    
    // ä½¿ç”¨å®¹å™¨ä¸­çš„èµ„æº
    for (const auto& res : resources) {
        res->use();
    }
    
    return 0;  // æ‰€æœ‰èµ„æºè‡ªåŠ¨é‡Šæ”¾
}
```

### std::weak_ptr
`std::weak_ptr`æ˜¯ä¸€ç§ä¸æ§åˆ¶å¯¹è±¡ç”Ÿå‘½å‘¨æœŸçš„æ™ºèƒ½æŒ‡é’ˆï¼Œå®ƒæŒ‡å‘ä¸€ä¸ªç”±`shared_ptr`ç®¡ç†çš„å¯¹è±¡ï¼Œä½†ä¸å¢åŠ å¼•ç”¨è®¡æ•°ã€‚

```cpp
#include <iostream>
#include <memory>

class Resource {
public:
    Resource() { std::cout << "Resource acquired\n"; }
    ~Resource() { std::cout << "Resource released\n"; }
    void use() { std::cout << "Resource used\n"; }
};

int main() {
    // åˆ›å»ºshared_ptr
    std::shared_ptr<Resource> sp = std::make_shared<Resource>();
    
    // åˆ›å»ºå¼±å¼•ç”¨
    std::weak_ptr<Resource> wp = sp;
    
    std::cout << "Count: " << sp.use_count() << std::endl;  // è¾“å‡º1ï¼Œwpä¸å¢åŠ è®¡æ•°
    
    // æ£€æŸ¥èµ„æºæ˜¯å¦è¿˜å­˜åœ¨
    if (auto temp = wp.lock()) {
        temp->use();  // ä½¿ç”¨èµ„æº
        std::cout << "Resource still exists\n";
    } else {
        std::cout << "Resource no longer exists\n";
    }
    
    // é‡Šæ”¾shared_ptr
    sp.reset();
    
    // å†æ¬¡æ£€æŸ¥èµ„æº
    if (auto temp = wp.lock()) {
        temp->use();
    } else {
        std::cout << "Resource no longer exists\n";
    }
    
    return 0;
}
```

## 9. std::future å’Œ std::promise
`std::future`å’Œ`std::promise`æ˜¯C++11ä¸­ç”¨äºå¼‚æ­¥ç¼–ç¨‹çš„ç»„ä»¶ï¼Œå…è®¸ä»ä¸€ä¸ªçº¿ç¨‹è·å–å¦ä¸€ä¸ªçº¿ç¨‹çš„ç»“æœã€‚

### åŸºæœ¬ç”¨æ³•
```cpp
#include <iostream>
#include <future>
#include <thread>
#include <chrono>

void computeResult(std::promise<int> resultPromise) {
    // æ¨¡æ‹Ÿè€—æ—¶è®¡ç®—
    std::this_thread::sleep_for(std::chrono::seconds(2));
    
    try {
        // è®¡ç®—ç»“æœ
        int result = 42;
        
        // è®¾ç½®ç»“æœå€¼
        resultPromise.set_value(result);
    } catch(...) {
        // å¦‚æœè®¡ç®—è¿‡ç¨‹å‡ºç°å¼‚å¸¸ï¼Œè®¾ç½®å¼‚å¸¸
        resultPromise.set_exception(std::current_exception());
    }
}

int main() {
    // åˆ›å»ºpromiseå’Œfuture
    std::promise<int> resultPromise;
    std::future<int> resultFuture = resultPromise.get_future();
    
    // åœ¨å¦ä¸€ä¸ªçº¿ç¨‹ä¸­è¿›è¡Œè®¡ç®—
    std::thread t(computeResult, std::move(resultPromise));

    // åœ¨ç­‰å¾…ç»“æœæœŸé—´æ‰§è¡Œå…¶ä»–ä¸šåŠ¡é€»è¾‘
    // ...
    
    // åªæœ‰å½“éœ€è¦ç»“æœæ—¶æ‰é˜»å¡ç­‰å¾…
    int result = resultFuture.get();
    
    std::cout << "Result: " << result << std::endl;
    
    t.join();
    return 0;
}
```

### wait_for å’Œè¶…æ—¶å¤„ç†
```cpp
#include <iostream>
#include <future>
#include <chrono>

int main() {
    // åˆ›å»ºä¸€ä¸ªå¼‚æ­¥ä»»åŠ¡
    std::future<int> future = std::async(std::launch::async, []() {
        std::this_thread::sleep_for(std::chrono::seconds(3));
        return 42;
    });
    
    std::cout << "Waiting for result...\n";
    
    // ç­‰å¾…ç»“æœï¼Œä½†æœ€å¤šç­‰å¾…1ç§’
    auto status = future.wait_for(std::chrono::seconds(1));
    
    if (status == std::future_status::ready) {
        // ä»»åŠ¡å·²å®Œæˆ
        std::cout << "Result: " << future.get() << std::endl;
    } else if (status == std::future_status::timeout) {
        // è¶…æ—¶
        std::cout << "Timeout! Task still running..." << std::endl;
        
        // ä»ç„¶å¯ä»¥ç­‰å¾…å®Œæˆ
        std::cout << "Final result: " << future.get() << std::endl;
    } else {
        // ä»»åŠ¡è¢«å»¶è¿Ÿ
        std::cout << "Task is deferred.\n";
    }
    
    return 0;
}
```

### std::packaged_task
`std::packaged_task`å°†å¯è°ƒç”¨å¯¹è±¡ä¸`future`ç»‘å®šï¼Œä¾¿äºè·å–å¼‚æ­¥ä»»åŠ¡çš„ç»“æœã€‚

```cpp
#include <iostream>
#include <future>
#include <thread>
#include <functional>

// è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—
int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n-1) + fibonacci(n-2);
}

int main() {
    // åˆ›å»ºpackaged_task
    std::packaged_task<int(int)> task(fibonacci);
    
    // è·å–future
    std::future<int> result = task.get_future();
    
    // åœ¨å¦ä¸€ä¸ªçº¿ç¨‹ä¸Šè¿è¡Œä»»åŠ¡
    std::thread t(std::move(task), 20);
    t.detach();  // åˆ†ç¦»çº¿ç¨‹
    
    std::cout << "Calculating fibonacci...\n";
    
    // ç­‰å¾…å¹¶è·å–ç»“æœ
    std::cout << "Fibonacci(20) = " << result.get() << std::endl;
    
    return 0;
}
```

### std::async
`std::async`æ˜¯ä¸€ä¸ªæ›´é«˜çº§åˆ«çš„æŠ½è±¡ï¼Œå®ƒç»“åˆäº†çº¿ç¨‹åˆ›å»ºå’Œfutureè·å–ã€‚

```cpp
#include <iostream>
#include <future>
#include <vector>
#include <numeric>

// è®¡ç®—éƒ¨åˆ†å’Œ
double calculatePartialSum(const std::vector<double>& data, size_t start, size_t end) {
    return std::accumulate(data.begin() + start, data.begin() + end, 0.0);
}

int main() {
    const size_t dataSize = 100000000;
    const size_t numThreads = 4;
    
    // åˆ›å»ºå¤§æ•°ç»„
    std::vector<double> data(dataSize, 1.0);
    
    // å­˜å‚¨future
    std::vector<std::future<double>> futures;
    
    // å¯åŠ¨å¼‚æ­¥ä»»åŠ¡
    size_t chunkSize = dataSize / numThreads;
    for (size_t i = 0; i < numThreads; ++i) {
        size_t start = i * chunkSize;
        size_t end = (i == numThreads - 1) ? dataSize : (i + 1) * chunkSize;
        
        futures.push_back(
            std::async(std::launch::async, calculatePartialSum, std::ref(data), start, end)
        );
    }
    
    // æ”¶é›†ç»“æœ
    double sum = 0.0;
    for (auto& future : futures) {
        sum += future.get();
    }
    
    std::cout << "Sum: " << sum << std::endl;
    
    return 0;
}
```

## 10. å¯å˜å‚æ•°æ¨¡æ¿å’Œå®Œç¾è½¬å‘
å¯å˜å‚æ•°æ¨¡æ¿å…è®¸å‡½æ•°æ¥å—ä»»æ„æ•°é‡å’Œç±»å‹çš„å‚æ•°ï¼Œè€Œå®Œç¾è½¬å‘ç¡®ä¿å‚æ•°çš„å€¼ç±»åˆ«ï¼ˆå·¦å€¼/å³å€¼ï¼‰å¾—åˆ°ä¿ç•™ã€‚

### åŸºæœ¬çš„å¯å˜å‚æ•°æ¨¡æ¿
```cpp
#include <iostream>

// é€’å½’ç»ˆæ­¢å‡½æ•°
void print() {
    std::cout << std::endl;
}

// å¯å˜å‚æ•°æ¨¡æ¿å‡½æ•°
template<typename T, typename... Args>
void print(T first, Args... args) {
    std::cout << first << " ";
    print(args...);  // é€’å½’å±•å¼€å‰©ä½™å‚æ•°
}

int main() {
    print(1, 2.5, "hello", 'a');  // è¾“å‡º: 1 2.5 hello a
    
    return 0;
}
```

### å¯å˜å‚æ•°æ¨¡æ¿ç±»
```cpp
#include <iostream>
#include <tuple>

// å¯å˜å‚æ•°æ¨¡æ¿ç±»
template<typename... Types>
class Container {
public:
    Container(Types... args) : data(args...) {}
    
    template<size_t Index>
    auto get() -> decltype(std::get<Index>(data)) { // å°¾è¿”å›ç±»å‹
        return std::get<Index>(data);
    }
    
private:
    std::tuple<Types...> data;
};

int main() {
    Container<int, double, std::string> container(10, 3.14, "hello");
    
    std::cout << container.get<0>() << std::endl;  // è¾“å‡º: 10
    std::cout << container.get<1>() << std::endl;  // è¾“å‡º: 3.14
    std::cout << container.get<2>() << std::endl;  // è¾“å‡º: hello
    
    return 0;
}
```

### å®Œç¾è½¬å‘
å®Œç¾è½¬å‘ä½¿ç”¨`std::forward`ä¿æŒå‚æ•°çš„å€¼ç±»åˆ«ï¼ˆå·¦å€¼/å³å€¼ï¼‰ç‰¹æ€§ã€‚

```cpp
#include <iostream>
#include <string>
#include <utility>

class Resource {
private:
    std::string data;
    
public:
    // ä»å­—ç¬¦ä¸²æ„é€ 
    Resource(const std::string& s) : data(s) {
        std::cout << "å¤åˆ¶æ„é€ : " << data << std::endl;
    }
    
    // ä»å³å€¼å­—ç¬¦ä¸²æ„é€ ï¼ˆç§»åŠ¨ï¼‰
    Resource(std::string&& s) : data(std::move(s)) {
        std::cout << "ç§»åŠ¨æ„é€ : " << data << std::endl;
    }
};

// æ™®é€šå‡½æ•° - æ€»æ˜¯å¤åˆ¶å‚æ•°
template<typename T>
void makeResource1(T arg) {
    Resource r(arg);  // arg æ€»æ˜¯å·¦å€¼ï¼Œåªèƒ½å¤åˆ¶
}

// å®Œç¾è½¬å‘ - ä¿æŒå‚æ•°çš„å€¼ç±»åˆ«
template<typename T>
void makeResource2(T&& arg) {
    Resource r(std::forward<T>(arg));  // ä¿æŒåŸå§‹çš„å·¦å€¼/å³å€¼ç‰¹æ€§
}

int main() {
    std::string str = "Hello";
    
    std::cout << "=== æ™®é€šå‡½æ•° ===" << std::endl;
    makeResource1(str);                    // å¤åˆ¶
    makeResource1(std::string("World"));   // è¿˜æ˜¯å¤åˆ¶ï¼ˆå³å€¼è¢«å¤åˆ¶åˆ°å‚æ•°ï¼‰
    
    std::cout << "\n=== å®Œç¾è½¬å‘ ===" << std::endl;
    makeResource2(str);                    // å¤åˆ¶ï¼ˆå·¦å€¼ï¼‰
    makeResource2(std::string("World"));   // ç§»åŠ¨ï¼ˆå³å€¼ï¼‰
    
    return 0;
}
```

### std::forward ä¸ std::move
+ `std::forward` æ˜¯ä¸€ä¸ª**æ¡ä»¶æ€§**çš„è½¬æ¢ï¼šå®ƒä»…åœ¨å‚æ•°è¢«ç»‘å®šåˆ°ä¸€ä¸ªå³å€¼æ—¶ï¼Œæ‰å°†å‚æ•°è½¬æ¢ä¸ºå³å€¼
+ `std::move` æ˜¯**æ— æ¡ä»¶çš„**ï¼šå®ƒæ€»æ˜¯å°†å‚æ•°è½¬æ¢ä¸ºå³å€¼ï¼Œç”¨äºè¡¨ç¤ºèµ„æºçš„æ‰€æœ‰æƒè½¬ç§»

```cpp
#include <iostream>
#include <utility>
#include <string>

void process(std::string& str) {
    std::cout << "Called with lvalue: " << str << std::endl;
}

void process(std::string&& str) {
    std::cout << "Called with rvalue: " << str << std::endl;
}

// å‡½æ•°æ¨¡æ¿ä½¿ç”¨å®Œç¾è½¬å‘
template<typename T>
void forwardingFunction(T&& param) {
    std::cout << "Before forwarding: ";
    process(param);  // æ€»æ˜¯è°ƒç”¨å·¦å€¼ç‰ˆæœ¬
    
    std::cout << "After std::forward: ";
    process(std::forward<T>(param));  // æ ¹æ®Tçš„ç±»å‹è°ƒç”¨å¯¹åº”ç‰ˆæœ¬
    
    std::cout << "After std::move: ";
    process(std::move(param));  // æ€»æ˜¯è°ƒç”¨å³å€¼ç‰ˆæœ¬
}

int main() {
    std::string str = "Hello";
    
    std::cout << "Calling with lvalue:\n";
    forwardingFunction(str);
    
    std::cout << "\nCalling with rvalue:\n";
    forwardingFunction(std::string("World"));
    
    return 0;
}
```

## 11. ç§»åŠ¨è¯­ä¹‰å’Œå³å€¼å¼•ç”¨
C++11å¼•å…¥äº†ç§»åŠ¨è¯­ä¹‰ï¼Œå…è®¸èµ„æºï¼ˆå¦‚åŠ¨æ€å†…å­˜ï¼‰çš„æ‰€æœ‰æƒä»ä¸€ä¸ªå¯¹è±¡è½¬ç§»åˆ°å¦ä¸€ä¸ªå¯¹è±¡ï¼Œè€Œä¸æ˜¯å¤åˆ¶è¿™äº›èµ„æºã€‚

### å³å€¼å¼•ç”¨åŸºç¡€
```cpp
#include <iostream>
#include <string>

// æ¥å—å·¦å€¼å¼•ç”¨çš„å‡½æ•°
void processLValue(std::string& str) {
    std::cout << "LValue: " << str << std::endl;
}

// æ¥å—å³å€¼å¼•ç”¨çš„å‡½æ•°
void processRValue(std::string&& str) {
    std::cout << "RValue: " << str << std::endl;
}

int main() {
    std::string hello = "Hello";
    
    processLValue(hello);  // ä½¿ç”¨å·¦å€¼
    // processRValue(hello);  // é”™è¯¯ï¼šä¸èƒ½å°†å·¦å€¼ç»‘å®šåˆ°å³å€¼å¼•ç”¨
    
    processRValue(std::move(hello));  // å°†å·¦å€¼è½¬æ¢ä¸ºå³å€¼
    processRValue("World");  // å­—é¢é‡æ˜¯å³å€¼
    processRValue(std::string("Temporary"));  // ä¸´æ—¶å¯¹è±¡æ˜¯å³å€¼
    
    // ä½¿ç”¨std::moveåï¼Œä¸åº”å†ä½¿ç”¨helloï¼ˆé™¤éé‡æ–°èµ‹å€¼ï¼‰
    std::cout << "After move: " << hello << std::endl;  // å¯èƒ½ä¸ºç©ºæˆ–æœªå®šä¹‰çŠ¶æ€
    
    return 0;
}
```

### è‡ªå®šä¹‰ç±»çš„ç§»åŠ¨è¯­ä¹‰
```cpp
#include <iostream>
#include <vector>
#include <utility>

class DataContainer {
public:
    // æ„é€ å‡½æ•°
    DataContainer(size_t size) : data_(new int[size]), size_(size) {
        std::cout << "Constructor: allocated " << size << " integers at " << data_ << std::endl;
    }
    
    // ææ„å‡½æ•°
    ~DataContainer() {
        if (data_) {
            std::cout << "Destructor: freeing memory at " << data_ << std::endl;
            delete[] data_;
        }
    }
    
    // æ‹·è´æ„é€ å‡½æ•°
    DataContainer(const DataContainer& other) 
        : data_(new int[other.size_]), size_(other.size_) {
        std::cout << "Copy constructor: copying " << size_ << " integers" << std::endl;
        std::copy(other.data_, other.data_ + size_, data_);
    }
    
    // æ‹·è´èµ‹å€¼è¿ç®—ç¬¦
    DataContainer& operator=(const DataContainer& other) {
        if (this != &other) {
            std::cout << "Copy assignment: copying " << other.size_ << " integers" << std::endl;
            delete[] data_;
            data_ = new int[other.size_];
            size_ = other.size_;
            std::copy(other.data_, other.data_ + size_, data_);
        }
        return *this;
    }
    
    // ç§»åŠ¨æ„é€ å‡½æ•°
    DataContainer(DataContainer&& other) noexcept 
        : data_(other.data_), size_(other.size_) {
        std::cout << "Move constructor: stealing " << size_ << " integers from " << other.data_ << std::endl;
        // å°†æºå¯¹è±¡ç½®äºæœ‰æ•ˆä½†å¯ææ„çš„çŠ¶æ€
        other.data_ = nullptr;
        other.size_ = 0;
    }
    
    // ç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦
    DataContainer& operator=(DataContainer&& other) noexcept {
        if (this != &other) {
            std::cout << "Move assignment: stealing " << other.size_ << " integers from " << other.data_ << std::endl;
            delete[] data_;
            // è½¬ç§»èµ„æº
            data_ = other.data_;
            size_ = other.size_;
            // å°†æºå¯¹è±¡ç½®äºæœ‰æ•ˆä½†å¯ææ„çš„çŠ¶æ€
            other.data_ = nullptr;
            other.size_ = 0;
        }
        return *this;
    }
    
    // è·å–æ•°æ®æŒ‡é’ˆï¼ˆä»…ä½œç¤ºä¾‹ï¼‰
    int* data() const { return data_; }
    
    // è·å–å¤§å°
    size_t size() const { return size_; }
    
private:
    int* data_;
    size_t size_;
};

int main() {
    // åˆ›å»ºå¯¹è±¡
    DataContainer d1(10);
    
    // æ‹·è´æ„é€ 
    DataContainer d2 = d1;  // è°ƒç”¨æ‹·è´æ„é€ å‡½æ•°
    
    // ç§»åŠ¨æ„é€ 
    DataContainer d3 = std::move(d1);  // è°ƒç”¨ç§»åŠ¨æ„é€ å‡½æ•°
    
    // éªŒè¯d1å·²è¢«ç§»åŠ¨
    std::cout << "d1 data: " << d1.data() << ", size: " << d1.size() << std::endl;
    
    // æ‹·è´èµ‹å€¼
    DataContainer d4(5);
    d4 = d2;  // è°ƒç”¨æ‹·è´èµ‹å€¼è¿ç®—ç¬¦
    
    // ç§»åŠ¨èµ‹å€¼
    DataContainer d5(5);
    d5 = std::move(d2);  // è°ƒç”¨ç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦
    
    // éªŒè¯d2å·²è¢«ç§»åŠ¨
    std::cout << "d2 data: " << d2.data() << ", size: " << d2.size() << std::endl;
    
    return 0;
}
```

## 12. std::tupleã€std::apply
`std::tuple`æ˜¯ä¸€ä¸ªå›ºå®šå¤§å°çš„å¼‚æ„å€¼é›†åˆï¼Œè€Œ`std::apply`å…è®¸å°†å‡½æ•°åº”ç”¨äºå…ƒç»„çš„æ‰€æœ‰å…ƒç´ ã€‚

### std::tupleåŸºç¡€
```cpp
#include <iostream>
#include <tuple>
#include <string>

int main() {
    // åˆ›å»ºå…ƒç»„
    std::tuple<int, double, std::string> t1(42, 3.14, "Hello");
    
    // ä½¿ç”¨std::make_tuple
    auto t2 = std::make_tuple(10, 2.5, "World");
    
    // è·å–å…ƒç´ 
    std::cout << "t1 elements: " 
              << std::get<0>(t1) << ", " 
              << std::get<1>(t1) << ", " 
              << std::get<2>(t1) << std::endl;
    
    // ä½¿ç”¨ç±»å‹ç´¢å¼•ï¼ˆC++14ï¼‰
    std::cout << "t1 string element: " << std::get<std::string>(t1) << std::endl;
    
    // ä¿®æ”¹å…ƒç´ 
    std::get<0>(t1) = 100;
    
    // è§£åŒ…å…ƒç»„
    int i;
    double d;
    std::string s;
    std::tie(i, d, s) = t1;
    
    std::cout << "Unpacked: " << i << ", " << d << ", " << s << std::endl;
    
    // åˆå¹¶å…ƒç»„
    auto t3 = std::tuple_cat(t1, t2);
    
    // è·å–å…ƒç»„å¤§å°
    std::cout << "t3 size: " << std::tuple_size<decltype(t3)>::value << std::endl;
    
    return 0;
}
```

### std::applyï¼ˆC++17ï¼‰
è™½ç„¶`std::apply`æ˜¯C++17å¼•å…¥çš„ï¼Œä½†è¿™é‡Œæå‰ä»‹ç»ï¼Œå› ä¸ºåœ¨çº¿ç¨‹æ± å®ç°ä¸­ç»å¸¸ä¼šç”¨åˆ°ç±»ä¼¼åŠŸèƒ½ï¼š

```cpp
#include <iostream>
#include <tuple>
#include <functional>

int sum(int a, int b, int c) {
    return a + b + c;
}

int main() {
    auto t = std::make_tuple(1, 2, 3);
    
    // ä½¿ç”¨std::apply (C++17)
    int result = std::apply(sum, t);
    std::cout << "Sum: " << result << std::endl;
    
    return 0;
}
```

std::applyæ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒæ¥å—ä¸€ä¸ªå¯è°ƒç”¨å¯¹è±¡å’Œä¸€ä¸ªå…ƒç»„ï¼Œç„¶åå°†å…ƒç»„ä¸­çš„å…ƒç´ è§£åŒ…ä½œä¸ºå‚æ•°ä¼ é€’ç»™å¯è°ƒç”¨å¯¹è±¡ã€‚ç®€å•æ¥è¯´ï¼Œå®ƒèƒ½æŠŠå…ƒç»„ä¸­çš„æ¯ä¸ªå…ƒç´ "åº”ç”¨"åˆ°å‡½æ•°çš„å¯¹åº”å‚æ•°ä½ç½®ä¸Šï¼Œå…å»äº†æ‰‹åŠ¨è§£åŒ…å…ƒç»„çš„éº»çƒ¦ã€‚åœ¨çº¿ç¨‹æ± å®ç°ä¸­ï¼Œè¿™éå¸¸æœ‰ç”¨ï¼Œå› ä¸ºæˆ‘ä»¬ç»å¸¸éœ€è¦å°†å­˜å‚¨åœ¨å…ƒç»„ä¸­çš„å‚æ•°ä¼ é€’ç»™ä»»åŠ¡å‡½æ•°ã€‚

## 13. std::invoke_result å’Œ decltype
### std::invoke_result
`std::invoke_result` æ˜¯ C++17 å¼•å…¥çš„ç±»å‹ç‰¹å¾ï¼ˆtype traitï¼‰ï¼Œå®ƒç”¨äºè·å–è°ƒç”¨å¯è°ƒç”¨å¯¹è±¡ï¼ˆå‡½æ•°ã€å‡½æ•°æŒ‡é’ˆã€å‡½æ•°å¯¹è±¡ã€lambda è¡¨è¾¾å¼ç­‰ï¼‰çš„è¿”å›ç±»å‹ã€‚å®ƒæ˜¯ C++11 ä¸­å¼•å…¥çš„ `std::result_of` çš„æ”¹è¿›ç‰ˆæœ¬ã€‚

```cpp
#include <iostream>
#include <functional>
#include <type_traits>
#include <string>

// ç¤ºä¾‹å‡½æ•°
int add(int a, int b) {
    return a + b;
}

class Calculator {
public:
double multiply(double a, double b) const {
    return a * b;
}
};

int main() {
    // è·å–æ™®é€šå‡½æ•°çš„è¿”å›ç±»å‹
    using AddResult = std::invoke_result<decltype(add), int, int>::type;
    static_assert(std::is_same_v<AddResult, int>, "Add should return int");

    // è·å–æˆå‘˜å‡½æ•°çš„è¿”å›ç±»å‹
    Calculator calc;
    using MultResult = std::invoke_result<decltype(&Calculator::multiply), Calculator, double, double
        >::type;
    static_assert(std::is_same_v<MultResult, double>, "Multiply should return double");

    // è·å–lambdaçš„è¿”å›ç±»å‹
    auto strConcat = [](const std::string& a, const std::string& b) {
        return a + b;
    };
    using ConcatResult = std::invoke_result<decltype(strConcat), std::string, std::string
        >::type;

    // ä½¿ç”¨æ¨å¯¼å‡ºçš„ç±»å‹
    AddResult sum = add(5, 3);
    MultResult product = calc.multiply(2.5, 4.0);
    ConcatResult fullName = strConcat("John", "Doe");

    std::cout << "Sum: " << sum << std::endl;
    std::cout << "Product: " << product << std::endl;
    std::cout << "Full name: " << fullName << std::endl;

    return 0;
}
```

åœ¨æ¨¡æ¿ç¼–ç¨‹å’Œæ³›å‹ä»£ç ä¸­ï¼Œ`std::invoke_result` ç‰¹åˆ«æœ‰ç”¨ï¼Œå®ƒå¯ä»¥è®©æˆ‘ä»¬æå‰çŸ¥é“è°ƒç”¨æŸä¸ªå‡½æ•°ä¼šå¾—åˆ°ä»€ä¹ˆç±»å‹çš„ç»“æœï¼Œä»è€Œåœ¨ç¼–è¯‘æœŸåšå‡ºç›¸åº”å†³ç­–ã€‚åœ¨çº¿ç¨‹æ± å®ç°ä¸­ï¼Œè¿™å¯ä»¥å¸®åŠ©æˆ‘ä»¬æ­£ç¡®å¤„ç†ä»»åŠ¡çš„è¿”å›å€¼ç±»å‹ã€‚

### åŒºåˆ«ä¸è”ç³»ï¼Ÿ
`decltype` å’Œ `std::invoke_result` è™½ç„¶éƒ½ç”¨äºç±»å‹æ¨å¯¼ï¼Œä½†å®ƒä»¬æœ‰æ˜æ˜¾çš„åŒºåˆ«ï¼š

#### ç”¨é€”ä¸åŒï¼š 
+ `decltype` æ˜¯ä¸€ä¸ªé€šç”¨çš„ç±»å‹è·å–å·¥å…·ï¼Œå¯ç”¨äºä»»ä½•è¡¨è¾¾å¼
+ `std::invoke_result` ä¸“é—¨ç”¨äºè·å–è°ƒç”¨å¯è°ƒç”¨å¯¹è±¡æ—¶çš„è¿”å›ç±»å‹

#### è¯­æ³•ä¸åŒï¼š 
+ `decltype` æ˜¯è¯­è¨€çº§åˆ«çš„å…³é”®å­—ï¼Œç›´æ¥ä½œç”¨äºè¡¨è¾¾å¼
+ `std::invoke_result` æ˜¯ä¸€ä¸ªæ¨¡æ¿å…ƒç¼–ç¨‹å·¥å…·ï¼Œéœ€è¦æŒ‡å®šå¯è°ƒç”¨å¯¹è±¡å’Œå‚æ•°ç±»å‹

#### ä½¿ç”¨åœºæ™¯ï¼š 
+ å½“ä½ æœ‰ä¸€ä¸ªè¡¨è¾¾å¼å¹¶æƒ³çŸ¥é“å®ƒçš„ç±»å‹æ—¶ï¼Œä½¿ç”¨ `decltype`
+ å½“ä½ æœ‰ä¸€ä¸ªå‡½æ•°/å¯è°ƒç”¨å¯¹è±¡ï¼Œæƒ³åœ¨ä¸è°ƒç”¨å®ƒçš„æƒ…å†µä¸‹çŸ¥é“å…¶è¿”å›ç±»å‹æ—¶ï¼Œä½¿ç”¨ `std::invoke_result`

è¿™ä¸¤ä¸ªå·¥å…·åœ¨ç°ä»£ C++ ä¸­éƒ½æ˜¯ç±»å‹ç³»ç»Ÿå’Œæ¨¡æ¿å…ƒç¼–ç¨‹çš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼ŒæŒæ¡å®ƒä»¬æœ‰åŠ©äºç¼–å†™æ›´çµæ´»ã€ç±»å‹å®‰å…¨çš„ä»£ç ã€‚

## 14. å¼‚å¸¸å¤„ç†ä¸ä¼ æ’­
åœ¨çº¿ç¨‹æ± ä¸­ï¼Œå¼‚å¸¸å¤„ç†æ˜¯ä¸€ä¸ªé‡è¦æ–¹é¢ï¼Œå°¤å…¶æ˜¯åœ¨å¼‚æ­¥ä»»åŠ¡ä¸­å¦‚ä½•ä¼ æ’­å¼‚å¸¸ã€‚

### åŸºæœ¬å¼‚å¸¸å¤„ç†
```cpp
#include <iostream>
#include <stdexcept>

void riskyFunction(int value) {
    if (value < 0) {
        throw std::invalid_argument("Value cannot be negative");
    } else if (value == 0) {
        throw std::runtime_error("Value cannot be zero");
    }
    std::cout << "Processing value: " << value << std::endl;
}

int main() {
    try {
        riskyFunction(5);  // æ­£å¸¸æ‰§è¡Œ
        riskyFunction(0);  // æŠ›å‡ºruntime_error
    } catch (const std::invalid_argument& e) {
        std::cerr << "Invalid argument: " << e.what() << std::endl;
    } catch (const std::runtime_error& e) {
        std::cerr << "Runtime error: " << e.what() << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Standard exception: " << e.what() << std::endl;
    } catch (...) {
        std::cerr << "Unknown exception caught" << std::endl;
    }
    
    return 0;
}
```

### å¼‚å¸¸åœ¨çº¿ç¨‹é—´çš„ä¼ æ’­
çº¿ç¨‹ä¸­çš„å¼‚å¸¸ä¸ä¼šè‡ªåŠ¨ä¼ æ’­åˆ°å…¶ä»–çº¿ç¨‹ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨`std::promise`å’Œ`std::future`æ¥ä¼ é€’å¼‚å¸¸ï¼š

```cpp
#include <iostream>
#include <thread>
#include <future>
#include <stdexcept>

void threadFunction(std::promise<int> resultPromise) {
    try {
        // æ¨¡æ‹Ÿè®¡ç®—
        throw std::runtime_error("Something went wrong");
        
        // æ­£å¸¸æƒ…å†µä¸‹è®¾ç½®ç»“æœ
        resultPromise.set_value(42);
    } catch (...) {
        // æ•è·æ‰€æœ‰å¼‚å¸¸å¹¶é€šè¿‡promiseä¼ é€’
        resultPromise.set_exception(std::current_exception());
    }
}

int main() {
    std::promise<int> promise;
    std::future<int> future = promise.get_future();
    
    std::thread t(threadFunction, std::move(promise));
    
    try {
        // å°è¯•è·å–ç»“æœ
        int result = future.get();
        std::cout << "Result: " << result << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Exception from thread: " << e.what() << std::endl;
    }
    
    t.join();
    return 0;
}
```

### std::current_exception å’Œ std::rethrow_exception
è¿™äº›å‡½æ•°å¯ä»¥æ•è·å’Œé‡æ–°æŠ›å‡ºå¼‚å¸¸ï¼Œåœ¨çº¿ç¨‹æ± ä¸­å¾ˆæœ‰ç”¨ï¼š

```cpp
#include <iostream>
#include <exception>

void processSafely(const std::function<void()>& func) {
    try {
        func();
    } catch (...) {
        // ä¿å­˜å½“å‰å¼‚å¸¸
        std::exception_ptr eptr = std::current_exception();
        
        // è®°å½•å¼‚å¸¸ä¿¡æ¯
        try {
            if (eptr) {
                std::rethrow_exception(eptr);
            }
        } catch (const std::exception& e) {
            std::cerr << "Caught exception: " << e.what() << std::endl;
        }
    }
}

int main() {
    processSafely([]() {
        throw std::runtime_error("Test exception");
    });
    
    return 0;
}
```



## ç»“å°¾

### è¿›é˜¶å®æˆ˜è¯¾ç¨‹æ¨è

å­¦ä¼šäº†è¿™äº›C++11/14/17æ–°ç‰¹æ€§ï¼Œä¸‹ä¸€æ­¥å°±æ˜¯åœ¨å®é™…é¡¹ç›®ä¸­åº”ç”¨å®ƒä»¬ï¼

æˆ‘ç›®å‰å¼€è®¾äº†ä¸¤ä¸ªé¡¹ç›®å®æˆ˜è¯¾ç¨‹ï¼Œæ­£å¥½ç”¨åˆ°äº†ä»Šå¤©ä»‹ç»çš„å¤§éƒ¨åˆ†ç‰¹æ€§ï¼š

ğŸ”¥ **C++é«˜æ€§èƒ½çº¿ç¨‹æ± é¡¹ç›®å®æˆ˜**

+  7å¤©ä»é›¶å®ç°å·¥ä¸šçº§çº¿ç¨‹æ± ï¼Œçªç ´ä»»åŠ¡è°ƒåº¦ã€å¼‚æ­¥ç¼–ç¨‹ã€å¼‚å¸¸å¤„ç†ä¸‰å¤§éš¾ç‚¹  

ğŸ”¥ **MySQLè¿æ¥æ± é¡¹ç›®å®æˆ˜**

+  8å¤©æ­å»ºé«˜æ€§èƒ½è¿æ¥æ± ï¼Œæ”»å…‹è´Ÿè½½å‡è¡¡ã€è‡ªåŠ¨é‡è¿ã€æ€§èƒ½ç›‘æ§æ ¸å¿ƒæŠ€æœ¯  

**è¯¦æƒ…å¯è®¿é—®**:


ä¸¤ä¸ªè¯¾ç¨‹éƒ½æ˜¯ä»é›¶å¼€å§‹æ‰‹å†™ä»£ç ï¼Œé€è¡Œè§£æè®¾è®¡æ€è·¯ï¼Œéå¸¸é€‚åˆæƒ³è¦æå‡é¡¹ç›®å®æˆ˜èƒ½åŠ›çš„åŒå­¦ã€‚

---

å¸Œæœ›è¿™ç¯‡æ–‡ç« å¯¹ä½ æœ‰å¸®åŠ©ï¼**å…³æ³¨æˆ‘ï¼ŒæŒç»­åˆ†äº«C++å¹²è´§** ğŸ’ª



## ğŸš€ è·Ÿæˆ‘å­¦ï¼Œä½ èƒ½æ”¶è·å•¥ï¼Ÿ

åœ¨è¿™é‡Œï¼Œä½ ä¸ä»…èƒ½çœ‹åˆ°å¹²è´§ï¼Œè¿˜èƒ½çœŸæ­£å­¦åˆ°èƒ½ç”¨çš„æŠ€èƒ½ï¼š

+ **Linux å®æˆ˜æŠ€å·§**ï¼šæœåŠ¡å™¨è°ƒä¼˜ã€å¸¸ç”¨å‘½ä»¤ã€Shell è„šæœ¬ï¼Œè®©ä½ åƒé«˜æ‰‹ä¸€æ ·æ“ä½œç³»ç»Ÿã€‚
+ **C/C++ åå°å¼€å‘**ï¼šä»åŸºç¡€è¯­æ³•åˆ°é«˜æ€§èƒ½ç¼–ç¨‹ï¼Œå¸¦ä½ å†™å‡ºç¨³ã€å¿«ã€å¯ç»´æŠ¤çš„æœåŠ¡ç«¯ä»£ç ã€‚
+ **C/C++ é¡¹ç›®å®æˆ˜**ï¼šçœŸå®é¡¹ç›®æ¡ˆä¾‹ï¼Œæ•™ä½ ä»éœ€æ±‚åˆ°ä¸Šçº¿å®Œæ•´æµç¨‹ï¼ŒæŒæ¡å¼€å‘å¥—è·¯å’Œæœ€ä½³å®è·µã€‚
+ **å¸¸ç”¨å¼€å‘å·¥å…·**ï¼šè°ƒè¯•ã€ç‰ˆæœ¬æ§åˆ¶ã€æ„å»ºå·¥å…·ã€æ€§èƒ½åˆ†æå·¥å…·ï¼Œè®©å¼€å‘æ•ˆç‡å¤§å¹…æå‡ã€‚
+ **æ€§èƒ½ä¼˜åŒ–**ï¼šCPU/å†…å­˜/IO è°ƒä¼˜æŠ€å·§ï¼Œå®šä½ç“¶é¢ˆï¼Œè®©ä½ çš„ç¨‹åºè·‘å¾—æ›´å¿«æ›´ç¨³ã€‚
+ **é¡¹ç›®æ¶æ„è®¾è®¡**ï¼šå¾®æœåŠ¡ã€åˆ†å±‚æ¶æ„ã€æ¨¡å—è®¾è®¡æ€è·¯ï¼Œå¸®ä½ æ„å»ºå¯æ‰©å±•ã€æ˜“ç»´æŠ¤çš„ç³»ç»Ÿã€‚
+ **Go åç«¯å¼€å‘**ï¼šå¾®æœåŠ¡ã€äº‘åŸç”Ÿå®æˆ˜ï¼Œæ•™ä½ ç”¨ Go æ­å»ºé«˜å¹¶å‘ã€é«˜å¯ç”¨ç³»ç»Ÿã€‚
+ **ç¼–ç¨‹é¢è¯•å¹²è´§ & ç®—æ³•**ï¼šæ ¸å¿ƒç®—æ³•å¥—è·¯ã€é¢è¯•é«˜é¢‘é¢˜è§£æï¼Œè®©ä½ ä¸å†æ‰‹å¿™è„šä¹±ã€‚
+ **è®¡ç®—æœºåŸºç¡€æ¢³ç†**ï¼šæ“ä½œç³»ç»Ÿã€ç½‘ç»œã€æ•°æ®ç»“æ„ã€å¹¶å‘åŸç†ï¼ŒçŸ¥è¯†ä½“ç³»æ¸…æ™°æ˜äº†ã€‚
+ **æˆé•¿è·¯çº¿å›¾**ï¼šç³»ç»Ÿè§„åˆ’ä½ çš„å­¦ä¹ è·¯å¾„ï¼Œä»åˆå­¦åˆ°é«˜çº§ï¼Œå¸®ä½ å°‘èµ°å¼¯è·¯ã€‚

å†…å®¹**æ·±å…¥æµ…å‡ºã€å®ç”¨æœ‰è¶£**ï¼Œå†ä¹Ÿä¸ç”¨çœ‹ä¹¦çœ‹åˆ°ç¡ç€ã€‚  
æ— è®ºæ˜¯é¢è¯•å†²åˆºï¼Œè¿˜æ˜¯æŠ€èƒ½å‡çº§ï¼Œè¿™é‡Œéƒ½æ˜¯ä½ çš„â€œæŠ€æœ¯åŠ æ²¹ç«™â€ã€‚


## ğŸ‘€ æƒ³åŠ å…¥ï¼Ÿå¾ˆç®€å•ï¼
**æ‰«ä¸€æ‰«ä¸‹é¢äºŒç»´ç **ï¼Œä¸€é”®å…³æ³¨å…¬ä¼—å·ï¼Œå¼€å¯ä½ çš„æŠ€æœ¯å­¦ä¹ ä¹‹æ—…ï¼

![](https://files.mdnice.com/user/71186/0dde803d-d52f-4ed8-b74b-b7f3da5817b9.png)

å¦å¤–ï¼Œæˆ‘è¿˜å»ºäº†ä¸€ä¸ª**æŠ€æœ¯äº¤æµç¾¤**ï¼Œé‡Œé¢éƒ½æ˜¯è®¤çœŸå†™ä»£ç çš„å°ä¼™ä¼´ï¼Œä¸å¹ç‰›ã€ä¸é—²èŠï¼ŒåªèŠæŠ€æœ¯ã€‚  
æœ‰é—®é¢˜ï¼Ÿå¤§å®¶ä¸€å—å„¿è®¨è®ºï¼Œæ¯”ä¸€ä¸ªäººé—·å¤´å­¦æ•ˆç‡é«˜å¤šäº†ï¼

![](https://files.mdnice.com/user/48364/4ebc72e9-e4bb-447a-9a92-8367a178df6d.png)

æŠ€æœ¯è¿™æ¡è·¯ï¼Œä¸€ä¸ªäººèµ°å®¹æ˜“è¿·è·¯ï¼Œä¸€ç¾¤äººèµ°æ‰æœ‰æ–¹å‘ã€‚  
è·Ÿä¸ŠèŠ‚å¥ï¼Œæˆ‘ä»¬ä¸€èµ·å˜å¼º ğŸ’ª

