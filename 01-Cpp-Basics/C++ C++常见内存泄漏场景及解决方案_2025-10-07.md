ğŸ¤” ä½ æ˜¯å¦é‡åˆ°è¿‡è¿™æ ·çš„æƒ…å†µï¼š 

ç¨‹åºè¿è¡Œä¸€æ®µæ—¶é—´åè«åå…¶å¦™å˜å¾—è¶Šæ¥è¶Šæ…¢ï¼Œ 

åº”ç”¨ç¨‹åºå†…å­˜å ç”¨å±…é«˜ä¸ä¸‹ï¼Œ æœ€åä¸å¾—ä¸é‡å¯ç¨‹åºï¼Ÿ

é‚£ä¹ˆæ­å–œä½ ï¼Œä½ å¯èƒ½é‡åˆ°äº†å†…å­˜æ³„æ¼ï¼

å¤§å®¶å¥½å•Šï¼Œæˆ‘æ˜¯å°åº·ã€‚ä»Šå¤©å’±ä»¬å°±æ¥èŠèŠ C++ ä¸­çš„å†…å­˜æ³„æ¼è¿™ä¸ªè€å¤§éš¾é—®é¢˜ã€‚åˆ«çœ‹è¿™ä¸ªè¯é¢˜å¬èµ·æ¥æŒºé«˜å¤§ä¸Šçš„ï¼Œä½†å…¶å®å°±è·Ÿæ—¥å¸¸ç”Ÿæ´»ä¸­çš„"æ¼æ°´"ä¸€æ ·ç®€å•ã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œä½ å®¶æ°´é¾™å¤´æ²¡å…³ç´§ï¼Œæ°´ä¸€ç›´åœ¨æ»´ï¼Œæ—¶é—´é•¿äº†æ°´è´¹è‚¯å®šå“—å“—å¾€ä¸Šæ¶¨ï¼Œè¿™å°±æ˜¯å†…å­˜æ³„æ¼çš„çœŸå®å†™ç…§ï¼

## ä»€ä¹ˆæ˜¯å†…å­˜æ³„æ¼ï¼Ÿ

ç”¨å¤§ç™½è¯è¯´å°±æ˜¯ï¼šä½ å‘ç³»ç»Ÿç”³è¯·äº†ä¸€å—å†…å­˜ç©ºé—´ï¼ˆæ¯”å¦‚ç”¨ new å…³é”®å­—ï¼‰ï¼Œç”¨å®Œä¹‹åå¿˜è®°è¿˜ç»™ç³»ç»Ÿäº†ï¼ˆå¿˜è®°ç”¨ delete é‡Šæ”¾ï¼‰ã€‚è¿™å—å†…å­˜å°±ä¼šä¸€ç›´è¢«å ç€ï¼Œè°ä¹Ÿç”¨ä¸äº†ï¼Œæ—¶é—´é•¿äº†ï¼Œå†…å­˜å°±ä¼šè¶Šå è¶Šå¤šï¼Œç³»ç»Ÿå°±ä¼šå˜å¾—è¶Šæ¥è¶Šæ…¢ã€‚

å°±åƒä½ å€Ÿäº†åˆ«äººçš„ä¸œè¥¿ä¸è¿˜ä¸€æ ·ï¼Œæ—¶é—´é•¿äº†ï¼Œåˆ«äººå®¶ä¸œè¥¿è¶Šæ¥è¶Šå°‘ï¼Œè€Œä½ è¿™è¾¹å´å †æ»¡äº†ç”¨ä¸ä¸Šçš„ä¸œè¥¿ï¼Œè¿™å°±æ˜¯å†…å­˜æ³„æ¼ï¼


**æ¥ä¸‹æ¥æˆ‘ä»¬æ¥çœ‹çœ‹æœ€å¸¸è§çš„å†…å­˜æ³„æ¼åœºæ™¯ï¼š**

## ä¸€ã€åŸºç¡€æ“ä½œé”™è¯¯
### 1. å¿˜è®°é‡Šæ”¾å†…å­˜
```c++
void forgetToDelete() {
    int* p = new int(42);  // ç”³è¯·äº†å†…å­˜
    // å’¦ï¼Ÿå¿˜è®° delete äº†
    // æ­£ç¡®åšæ³•ï¼šdelete p;
}
```

è¿™å°±åƒä½ ä»å›¾ä¹¦é¦†å€Ÿäº†æœ¬ä¹¦ï¼Œç”¨å®Œåå¿˜è®°è¿˜ï¼Œè¿™æœ¬ä¹¦å°±ä¸€ç›´è¢«ä½ å ç€ã€‚ä¸ä»…ä½ çœ‹å®Œåç”¨ä¸ä¸Šäº†ï¼Œå…¶ä»–äººä¹Ÿå€Ÿä¸åˆ°è¿™æœ¬ä¹¦ï¼

**æ­£ç¡®åšæ³•**ï¼š

```c++
void correctDelete() {
    // æ–¹æ³•ï¼šç›´æ¥ä½¿ç”¨unique_ptr
    std::unique_ptr<int> p(new int(42));
    
    // ç”¨æ™ºèƒ½æŒ‡é’ˆï¼Œç¦»å¼€ä½œç”¨åŸŸè‡ªåŠ¨é‡Šæ”¾å†…å­˜
}
```

### 2. æŒ‡é’ˆé‡æ–°èµ‹å€¼
```c++
void pointerReassignment() {
    int* p = new int(42);
    p = new int(73);  // åŸæ¥æŒ‡å‘çš„å†…å­˜ä¸¢å¤±äº†ï¼Œé€ æˆæ³„æ¼
    delete p;  // åªèƒ½é‡Šæ”¾ç¬¬äºŒæ¬¡åˆ†é…çš„å†…å­˜
}
```

è¿™å°±åƒä½ åœ¨è¶…å¸‚å¯„å­˜äº†ä¸€ä¸ªèƒŒåŒ…ï¼Œæ‹¿åˆ°äº†å¯„å­˜ç‰Œã€‚ä½†åæ¥ä½ åˆå¯„å­˜äº†ç¬¬äºŒä¸ªèƒŒåŒ…ï¼Œå·¥ä½œäººå‘˜ç»™äº†ä½ æ–°çš„å¯„å­˜ç‰Œï¼Œè€Œä½ æŠŠæ—§çš„å¯„å­˜ç‰Œå¼„ä¸¢äº†ã€‚è¿™æ ·ä½ å°±æ°¸è¿œæ‰¾ä¸å›ç¬¬ä¸€ä¸ªèƒŒåŒ…äº†ï¼Œå®ƒä¼šä¸€ç›´å ç€æŸœå­ï¼

**æ­£ç¡®åšæ³•**ï¼š

```c++
void correctReassignment() {
    std::unique_ptr<int> p(new int(42));
    p.reset(new int(73));  // æˆ–è€…ç”¨ p = std::unique_ptr<int>(new int(73));
}
```

### 3. new/deleteä½¿ç”¨ä¸å½“
ä½¿ç”¨é”™è¯¯çš„deleteæ–¹å¼ï¼Œæˆ–è€…é‡å¤deleteã€‚

```c++
void wrongDelete() {
    // é”™è¯¯ç¤ºä¾‹1ï¼šå¯¹æ•°ç»„ä½¿ç”¨æ™®é€šdelete
    int* numbers = new int[100];  // åˆ›å»ºä¸€ä¸ªæ•°ç»„
    delete numbers;               // é”™è¯¯ï¼åº”è¯¥ç”¨delete[]
    
    // é”™è¯¯ç¤ºä¾‹2ï¼šå¯¹æ™®é€šæŒ‡é’ˆä½¿ç”¨delete[]
    int* single = new int(20);
    delete[] single;             // é”™è¯¯ï¼åº”è¯¥ç”¨delete
    
    // é”™è¯¯ç¤ºä¾‹3ï¼šé‡å¤delete
    int* data = new int(10);
    delete data;
    delete data;                 // é”™è¯¯ï¼é‡å¤åˆ é™¤åŒä¸€å†…å­˜
}
```

è¿™å°±åƒä½ ï¼š

1. ç§Ÿäº†ä¸€æ’å‚¨ç‰©æŸœï¼Œä½†åªé€€æ‰äº†ç¬¬ä¸€ä¸ª
2. ç§Ÿäº†ä¸€ä¸ªå‚¨ç‰©æŸœï¼Œä½†æƒ³é€€æ‰ä¸€æ’
3. åŒä¸€ä¸ªå‚¨ç‰©æŸœé€€ç§Ÿäº†ä¸¤æ¬¡

**æ­£ç¡®çš„åšæ³•**ï¼š

```c++
void correctDelete() {
    // æ­£ç¡®ç¤ºä¾‹1ï¼šä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆè‡ªåŠ¨ç®¡ç†æ•°ç»„
    std::unique_ptr<int[]> numbers(new int[100]);
    // æ›´ç®€å•çš„æ–¹å¼å¯ä»¥ä½¿ç”¨ vector ç®¡ç†åŠ¨æ€æ•°ç»„
    std::vector<int> numbers(100);  // åˆ›å»ºåŒ…å«100ä¸ªæ•´æ•°çš„vector
    
    // æ­£ç¡®ç¤ºä¾‹2ï¼šä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆè‡ªåŠ¨ç®¡ç†å•ä¸ªå¯¹è±¡
    std::unique_ptr<int> single(new int(20));
    
    // æ­£ç¡®ç¤ºä¾‹3ï¼šé¿å…é‡å¤deleteçš„é—®é¢˜
    {
        std::unique_ptr<int> data(new int(20));
        // ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨é‡Šæ”¾ä¸€æ¬¡ï¼Œä¸ä¼šé‡å¤é‡Šæ”¾
    }
}
```

### ğŸ’¡ å°è´´å£«
+ ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆä»£æ›¿åŸå§‹æŒ‡é’ˆï¼Œè®©å†…å­˜ç®¡ç†å˜å¾—è‡ªåŠ¨åŒ– 
+ å…»æˆé…å¯¹ä¹ æƒ¯ï¼šæ¯ä¸ª`new`å¯¹åº”ä¸€ä¸ª`delete`ï¼Œæ¯ä¸ª`new[]`å¯¹åº”ä¸€ä¸ª`delete[]`
+ é‡æ–°èµ‹å€¼æŒ‡é’ˆå‰ï¼Œå…ˆä¿å­˜å¹¶é‡Šæ”¾åŸæ¥æŒ‡å‘çš„å†…å­˜ 

## äºŒã€æ§åˆ¶æµå¯¼è‡´çš„æ³„æ¼
### 1. å¾ªç¯ä¸­çš„å†…å­˜æ³„æ¼
åœ¨å¾ªç¯ä¸­åˆ†é…å†…å­˜ä½†å¿˜è®°é‡Šæ”¾ï¼Œæ¯æ¬¡å¾ªç¯éƒ½ä¼šäº§ç”Ÿæ–°çš„æ³„æ¼ã€‚

```c++
class DataProcessor {
public:
    void processData(int count) {
        for(int i = 0; i < count; i++) {
            int* data = new int[1000];  // æ¯æ¬¡å¾ªç¯åˆ†é…æ–°å†…å­˜
            // å¤„ç†æ•°æ®...
            if(data[0] < 0) {
                continue;  // ç‰¹æ®Šæƒ…å†µç›´æ¥è·³è¿‡ï¼Œå¿˜è®°é‡Šæ”¾å†…å­˜äº†ï¼
            }
            // å¤„ç†æ›´å¤šæ•°æ®...
            // ç³Ÿç³•ï¼Œå¿˜è®°delete[]äº†ï¼
        }
    }
};
```
**æ­£ç¡®åšæ³•**ï¼š

```c++
class DataProcessor {
public:
    void processData(int count) {
        // ä½¿ç”¨vectoræ›¿ä»£åŸå§‹æ•°ç»„
        std::vector<int> data(1000);  // åˆ›å»ºä¸€ä¸ªåŒ…å«1000ä¸ªæ•´æ•°çš„vector
        // ä¹Ÿå¯ä»¥ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ
        // std::unique_ptr<int[]> data(new int[1000]);
        
        for(int i = 0; i < count; i++) {
            // å¤„ç†æ•°æ®...
            if(data[0] < 0) {
                continue;  // å®‰å…¨ï¼ä¸ä¼šé€ æˆå†…å­˜æ³„æ¼
            }
            // å¤„ç†æ›´å¤šæ•°æ®...
        }
        // vectorè‡ªåŠ¨ç®¡ç†å†…å­˜ï¼Œç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨é‡Šæ”¾
    }
};
```

### 2. æ¡ä»¶åˆ†æ”¯å¯¼è‡´çš„æ³„æ¼
åœ¨ifæˆ–switchè¯­å¥ä¸­æå‰è¿”å›ï¼Œå¯¼è‡´åé¢çš„deleteæ— æ³•æ‰§è¡Œã€‚

```c++
class FileParser {
    char* buffer;
public:
    bool parseFile(const char* filename) {
        buffer = new char[1024];  // åˆ†é…ç¼“å†²åŒº
        
        if(!openFile(filename)) {
            return false;  // é”™è¯¯ï¼æå‰è¿”å›å¿˜è®°é‡Šæ”¾buffer
        }
        
        if(fileIsEmpty()) {
            return false;  // è¿™é‡Œä¹Ÿå¿˜è®°é‡Šæ”¾bufferäº†ï¼
        }
        
        // æ­£å¸¸å¤„ç†...
        delete[] buffer;
        return true;
    }
};
```

è¿™å°±åƒä½ ä¸´æ—¶ç§Ÿäº†å‚¨ç‰©æŸœå‡†å¤‡å­˜ä¸œè¥¿ï¼Œä½†å‘ç°ä¸œè¥¿å¸¦é”™äº†å°±ç›´æ¥å›å®¶äº†ï¼Œå®Œå…¨å¿˜è®°é€€ç§Ÿå‚¨ç‰©æŸœã€‚åˆ«äººä¹Ÿå­˜ä¸äº†äº†ã€‚

**æ­£ç¡®çš„åšæ³•**ï¼š 

```c++
class FileParser {
    // æ–¹æ³•1ï¼šä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ
    std::unique_ptr<char[]> buffer;
    // æ–¹æ³•2ï¼šä½¿ç”¨ string 
    string buffer;
public:
    
    bool parseFile(const char* filename) {
        buffer.reset(new char[1024]);  // C++11å†™æ³•
        if(!openFile(filename)) {
            return false;  // å®‰å…¨ï¼bufferä¼šè‡ªåŠ¨é‡Šæ”¾
        }
        
        if(fileIsEmpty()) {
            return false;  // bufferä¹Ÿä¼šè‡ªåŠ¨é‡Šæ”¾
        }
        
        // æ­£å¸¸å¤„ç†...
        return true;  // ç¦»å¼€å‡½æ•°æ—¶bufferè‡ªåŠ¨é‡Šæ”¾
    }
    
    //æ–¹æ³•2ï¼šä½¿ç”¨ string 
    bool parseFile(const char* filename) {
        buffer.resize(1024);  // é¢„åˆ†é…ç©ºé—´
        
        if(!openFile(filename)) {
            return false;  // å®‰å…¨ï¼stringè‡ªåŠ¨ç®¡ç†å†…å­˜
        }
        
        if(fileIsEmpty()) {
            return false;  // stringè‡ªåŠ¨æ¸…ç†
        }
        
        // æ­£å¸¸å¤„ç†...
        return true;  // stringè‡ªåŠ¨ç®¡ç†ç”Ÿå‘½å‘¨æœŸ
    }
};
```

### 3. å¼‚å¸¸å¤„ç†ä¸å½“

åœ¨å¯èƒ½æŠ›å‡ºå¼‚å¸¸çš„ä»£ç åé¢å†™deleteï¼Œå¯¼è‡´å¼‚å¸¸å‘ç”Ÿæ—¶å†…å­˜æ³„æ¼ã€‚

```c++
class DataHandler {
public:
    void processData() {
        int* data = new int[1000];  // åˆ†é…å¤§é‡å†…å­˜
        
        // å¯èƒ½æŠ›å‡ºå¼‚å¸¸çš„æ“ä½œ
        doRiskyOperation();  // å¦‚æœè¿™é‡ŒæŠ›å¼‚å¸¸
        
        delete[] data;       // è¿™è¡Œä»£ç æ°¸è¿œä¸ä¼šæ‰§è¡Œåˆ°ï¼
    }
    
    void doRiskyOperation() {
        if(rand() % 2 == 0) {
            throw std::runtime_error("æ“ä½œå¤±è´¥");
        }
    }
};
```

**æ­£ç¡®çš„åšæ³•**ï¼š

```c++
class DataHandler {
public:
    void processData() {
        std::unique_ptr<int[]> data(new int[1000]);
        // å³ä½¿å‘ç”Ÿå¼‚å¸¸ï¼Œdataä¹Ÿä¼šè¢«æ­£ç¡®é‡Šæ”¾
        doRiskyOperation();
        
        // æ­£å¸¸å¤„ç†æ•°æ®...
    }
    
    void doRiskyOperation() {
        if(rand() % 2 == 0) {
            throw std::runtime_error("æ“ä½œå¤±è´¥");
        }
    }
};
```

### ğŸ’¡ å°è´´å£«
+ åœ¨å¾ªç¯ä¸­ç¡®ä¿å†…å­˜åˆ†é…å’Œé‡Šæ”¾åœ¨åŒä¸€è¿­ä»£ä¸­å®Œæˆï¼Œæˆ–è€…ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆæ¥æ›¿ä»£æ‰‹åŠ¨ç®¡ç†ã€‚
+ åœ¨æ¡ä»¶åˆ†æ”¯æˆ–å¼‚å¸¸ä¸­ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆé¿å…æå‰è¿”å›é€ æˆçš„æ³„æ¼ã€‚

## ä¸‰ã€ç±»å’Œå¯¹è±¡ç›¸å…³
### 3.1 ç±»æˆå‘˜ç®¡ç†ä¸å½“
#### 1. å¿˜è®°å®ç°ææ„å‡½æ•°
```c++
class MusicPlayer {
    int* buffer;       // éŸ³é¢‘ç¼“å†²åŒº
    char* songName;    // æ­Œæ›²å
public:
    MusicPlayer(const char* name) {
        buffer = new int[10000];          // åˆ†é…ç¼“å†²åŒº
        songName = new char[strlen(name) + 1];  // åˆ†é…æ­Œåç©ºé—´
        strcpy(songName, name);
    }
    // ç³Ÿç³•ï¼Œå¿˜è®°å†™ææ„å‡½æ•°äº†ï¼
};

void playMusic() {
    MusicPlayer* player = new MusicPlayer("æœ€çˆ±çš„æ­Œ.mp3");
    delete player;  // åªåˆ é™¤äº†å¯¹è±¡ï¼Œbufferå’ŒsongNameçš„å†…å­˜éƒ½æ³„æ¼äº†
}
```

è¿™å°±åƒä½ åœ¨æ‰‹æœºéŸ³ä¹æ’­æ”¾å™¨ä¸Šä¸‹è½½äº†æ­Œæ›²å’Œæ­Œè¯ï¼Œå…³é—­æ’­æ”¾å™¨æ—¶åªé€€å‡ºäº†åº”ç”¨ï¼Œä½†åå°çš„éŸ³ä¹ç¼“å­˜å’Œä¸‹è½½çš„æ­Œè¯æ–‡ä»¶éƒ½è¿˜å ç€æ‰‹æœºç©ºé—´ï¼Œæ…¢æ…¢ç§¯ç´¯å°±ä¼šæŠŠæ‰‹æœºå­˜å‚¨ç©ºé—´å æ»¡ï¼  

**æ­£ç¡®åšæ³•**ï¼š

```c++
// æ–¹æ³•ä¸€:
class MusicPlayer {
    std::vector<int> buffer;      
    std::string songName;         
public:
    MusicPlayer(const char* name) :
        buffer(10000),            // é¢„åˆ†é…10000ä¸ªæ•´æ•°ç©ºé—´
        songName(name)            // ç›´æ¥ä»const char*æ„é€ string
    {
        // ä¸éœ€è¦æ‰‹åŠ¨æ‹·è´ï¼Œstringæ„é€ å‡½æ•°å·²ç»å¤„ç†å¥½äº†
    }
    // åŒæ ·ä¸éœ€è¦ææ„å‡½æ•°ï¼Œvectorå’Œstringä¼šè‡ªåŠ¨æ¸…ç†
};

// æ–¹æ³•äºŒï¼šä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ
class MusicPlayer {
    std::unique_ptr<int[]> buffer;  
    std::unique_ptr<char[]> songName;
public:
    MusicPlayer(const char* name) :
        buffer(new int[10000]),
        songName(new char[strlen(name) + 1]) 
    {
        strcpy(songName.get(), name);
    }
    // ä¸éœ€è¦æ‰‹åŠ¨å†™ææ„å‡½æ•°ï¼Œæ™ºèƒ½æŒ‡é’ˆä¼šè‡ªåŠ¨å¤„ç†æ¸…ç†å·¥ä½œ
};
```

#### 2. å¿˜è®°éµå¾ª"ä¸‰/äº”æ³•åˆ™"
> "ä¸‰æ³•åˆ™"æ˜¯è¯´ï¼šå¦‚æœä½ éœ€è¦è‡ªå®šä¹‰ææ„å‡½æ•°ã€æ‹·è´æ„é€ å‡½æ•°å’Œæ‹·è´èµ‹å€¼è¿ç®—ç¬¦ä¸­çš„ä»»ä½•ä¸€ä¸ªï¼Œä½ å°±éœ€è¦è‡ªå®šä¹‰å…¨éƒ¨ä¸‰ä¸ªã€‚
>
> "äº”æ³•åˆ™"æ˜¯åœ¨ä¸‰æ³•åˆ™åŸºç¡€ä¸Šå¢åŠ äº†ç§»åŠ¨æ„é€ å‡½æ•°å’Œç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦ã€‚

```c++
class PhotoAlbum {
    char* title;
    int* photos;
public:
    PhotoAlbum(const char* name) {
        title = new char[strlen(name) + 1];
        strcpy(title, name);
        photos = new int[1000];
    }
    ~PhotoAlbum() {
        delete[] title;
        delete[] photos;
    }
    // ç³Ÿç³•ï¼Œå¿˜è®°å†™æ‹·è´æ„é€ å‡½æ•°äº†ï¼
};

void processAlbum() {
    PhotoAlbum album1("å‡æ—¥ç›¸å†Œ");
    PhotoAlbum album2 = album1;  // æµ…æ‹·è´ï¼ä¸¤ä¸ªå¯¹è±¡æŒ‡å‘åŒä¸€å—å†…å­˜
    // ç¨‹åºç»“æŸæ—¶ï¼ŒåŒä¸€å—å†…å­˜è¢«åˆ é™¤ä¸¤æ¬¡ï¼Œå¯¼è‡´å´©æºƒ
}
```

è¿™å°±åƒä½ å¤åˆ¶äº†ä¸€å¼ æˆ¿å¡ï¼Œç»“æœä¸¤ä¸ªäººéƒ½ä»¥ä¸ºè‡ªå·±æ˜¯æˆ¿é—´çš„ä¸»äººã€‚é€€æˆ¿æ—¶ä¸¤ä¸ªäººéƒ½å»é€€æˆ¿ï¼Œé…’åº—ç³»ç»Ÿæ··ä¹±äº†ï¼

**æ­£ç¡®åšæ³•**ï¼š

```c++
// æ–¹æ³•ä¸€ï¼šä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ
class PhotoAlbum {
    std::unique_ptr<char[]> title;
    std::unique_ptr<int[]> photos;
public:
     PhotoAlbum(const char* name) : 
        title(new char[strlen(name) + 1]),  // ç›´æ¥ä½¿ç”¨new
        photos(new int[1000])               // ç›´æ¥ä½¿ç”¨new
        {
            strcpy(title.get(), name);
        }
    
    // ç¦æ­¢æ‹·è´ï¼Œåªå…è®¸ç§»åŠ¨
    PhotoAlbum(const PhotoAlbum&) = delete;
    PhotoAlbum& operator=(const PhotoAlbum&) = delete;
    
    // ç§»åŠ¨æ„é€ å’Œèµ‹å€¼æ˜¯å…è®¸çš„
    PhotoAlbum(PhotoAlbum&&) = default;
    PhotoAlbum& operator=(PhotoAlbum&&) = default;
};

// æ–¹æ³•äºŒï¼šä½¿ç”¨stringå’Œvector

class PhotoAlbum {
    std::string title;           // æ›¿ä»£ unique_ptr<char[]>
    std::vector<int> photos;     // æ›¿ä»£ unique_ptr<int[]>
public:
    PhotoAlbum(const char* name) : 
        title(name),             // ç›´æ¥ä»const char*æ„é€ 
        photos(1000)             // é¢„åˆ†é…1000ä¸ªæ•´æ•°ç©ºé—´
    {
        // ä¸éœ€è¦æ‰‹åŠ¨æ‹·è´ï¼Œæ„é€ å‡½æ•°å·²ç»å¤„ç†å¥½äº†
    }
    
    // å…³é”®åŒºåˆ«ï¼šä¸å†éœ€è¦æ˜¾å¼ç¦ç”¨æ‹·è´æˆ–å¯ç”¨ç§»åŠ¨
    // stringå’Œvectorå·²ç»å®ç°äº†æ­£ç¡®çš„æ‹·è´å’Œç§»åŠ¨è¯­ä¹‰
};

```

#### 3.åŸºç±»ææ„å‡½æ•°æ²¡æœ‰è®¾ç½®æˆè™šå‡½æ•°

```c++
class Animal {
public:
    Animal() { /* åˆå§‹åŒ–ä»£ç  */ }
    ~Animal() { /* é‡Šæ”¾åŸºç±»èµ„æº */ }  // é—®é¢˜ï¼šéè™šææ„å‡½æ•°ï¼
};

class Dog : public Animal {
    int* dogData;
public:
    Dog() { dogData = new int[100]; }  // å­ç±»åˆ†é…äº†é¢å¤–å†…å­˜
    ~Dog() { delete[] dogData; }      // å­ç±»ææ„å‡½æ•°
};

void processAnimal() {
    Animal* pet = new Dog();  // é€šè¿‡åŸºç±»æŒ‡é’ˆåˆ›å»ºDogå¯¹è±¡
    // ä½¿ç”¨pet...
    delete pet;  // é—®é¢˜ï¼šåªä¼šè°ƒç”¨Animal::~Animal()ï¼Œä¸ä¼šè°ƒç”¨Dog::~Dog()
                 // dogDataå†…å­˜æ³„æ¼ï¼
}
```

è¿™å°±åƒä¸€è¾†è½¦ï¼ˆåŸºç±»ï¼‰ä¸Šè£…äº†ä¸€ä¸ªç‰¹æ®Šè®¾å¤‡ï¼ˆå­ç±»ï¼‰ã€‚æŠ¥åºŸè½¦è¾†æ—¶ï¼Œå›æ”¶ç«™åªæŒ‰æ™®é€šè½¦å¤„ç†ï¼Œå®Œå…¨å¿½ç•¥äº†é‚£ä¸ªç‰¹æ®Šè®¾å¤‡ã€‚è½¦æ˜¯å›æ”¶äº†ï¼Œä½†ç‰¹æ®Šè®¾å¤‡è¢«é—å¿˜åœ¨è§’è½é‡Œï¼Œæ²¡äººç®¡ï¼

**æ­£ç¡®åšæ³•**ï¼š
```c++
class Animal {
public:
    Animal() { /* åˆå§‹åŒ–ä»£ç  */ }
    virtual ~Animal() { /* é‡Šæ”¾åŸºç±»èµ„æº */ }  // è™šææ„å‡½æ•°ï¼
};

class Dog : public Animal {
    int* dogData;
public:
    Dog() { dogData = new int[100]; }
    ~Dog() override { delete[] dogData; }  // ä¼šè¢«æ­£ç¡®è°ƒç”¨
};
```
### 3.2 æ™ºèƒ½æŒ‡é’ˆä½¿ç”¨ä¸å½“
#### 1. shared_ptrå¾ªç¯å¼•ç”¨
```c++
class Person {
    std::string name;
    std::shared_ptr<Person> spouse;  // é…å¶
public:
    Person(const string& n) : name(n) {}
    
    void marry(std::shared_ptr<Person> other) {
        spouse = other;
        other->spouse = std::shared_ptr<Person>(this);  // å¾ªç¯å¼•ç”¨ï¼
    }
};

void createCouple() {
    auto jack = std::make_shared<Person>("Jack");
    auto rose = std::make_shared<Person>("Rose");
    jack->marry(rose);  // ä¹‹åå³ä½¿å‡½æ•°ç»“æŸï¼Œä¸¤ä¸ªå¯¹è±¡ä¹Ÿä¸ä¼šè¢«é‡Šæ”¾
}
```

è¿™å°±åƒä¸¤ä¸ªå›¾ä¹¦é¦†ç®¡ç†å‘˜å°å¼ å’Œå°æäº’ç›¸ç®¡ç†å¯¹æ–¹çš„é—¨ç¦å¡ã€‚è§„å®š"åªæœ‰æ²¡äººç®¡ç†æˆ‘çš„é—¨ç¦å¡æ—¶æˆ‘æ‰èƒ½ç¦»èŒ"ï¼Œç»“æœä»–ä»¬éƒ½ç¦»ä¸äº†èŒâ€”â€”å› ä¸ºä»–ä»¬éƒ½åœ¨ç­‰å¯¹æ–¹å…ˆæ”¾å¼ƒç®¡ç†è‡ªå·±çš„é—¨ç¦å¡ï¼  

**æ­£ç¡®åšæ³•**ï¼š

```c++
class Person {
    std::string name;
    std::weak_ptr<Person> spouse;  // ä½¿ç”¨weak_ptré¿å…å¾ªç¯å¼•ç”¨
public:
    Person(const string& n) : name(n) {}
    
    void marry(std::shared_ptr<Person> other) {
        spouse = other;  // weak_pträ¸ä¼šå¢åŠ å¼•ç”¨è®¡æ•°
        other->spouse = std::weak_ptr<Person>(
            std::shared_ptr<Person>(this)
        );
    }
};
```

#### 2. é”™è¯¯åœ°å°† this æŒ‡é’ˆä¼ ç»™ shared_ptr
```c++
class VideoPlayer {
public:
    void playInBackground() {
        // é”™è¯¯ï¼ç›´æ¥ä»thisåˆ›å»ºshared_ptr
        std::thread t(&VideoPlayer::play, 
            std::shared_ptr<VideoPlayer>(this)
        );
        t.detach();
    }
};

void watchVideo() {
    auto player = std::make_shared<VideoPlayer>();  // ç¬¬ä¸€ä¸ªç®¡ç†è€…
    player->playInBackground();  // åˆ›å»ºäº†ç¬¬äºŒä¸ªç®¡ç†è€…ï¼
}
```

è¿™å°±åƒä¸€ä¸ªåŒ…è£¹åŒæ—¶è¢«è´´äº†ä¸¤å¼ å¿«é€’å•ï¼Œç»“æœä¸¤å®¶å¿«é€’å…¬å¸éƒ½æ¥å–ä»¶ï¼Œæ¯å®¶éƒ½è§‰å¾—è‡ªå·±è´Ÿè´£è¿™ä¸ªåŒ…è£¹ã€‚æœ€ååŒ…è£¹è¢«å¤„ç†äº†ä¸¤æ¬¡ï¼Œç³»ç»Ÿæ··ä¹±äº†ï¼  

**æ­£ç¡®åšæ³•**ï¼š

```c++
class VideoPlayer : public std::enable_shared_from_this<VideoPlayer> {
public:
    void play() {
        std::thread t(&VideoPlayer::playThread, 
            shared_from_this()  // æ­£ç¡®çš„æ–¹å¼
        );
        t.detach();
    }
};
```

#### 3. shared_ptrå’Œæ™®é€šæŒ‡é’ˆæ··ç”¨
```c++
class ResourceManager {
    std::shared_ptr<Resource> res;
public:
    void process() {
        Resource* raw = res.get();  // è·å–åŸå§‹æŒ‡é’ˆ
        delete raw;                 // é”™è¯¯ï¼ä¸åº”è¯¥æ‰‹åŠ¨åˆ é™¤
        // shared_ptrè¿˜ä¼šå†æ¬¡åˆ é™¤ï¼Œå¯¼è‡´åŒé‡é‡Šæ”¾
    }
};
```

è¿™å°±åƒä¸€ä¸ªæ–‡ä»¶æ—¢æ”¾åœ¨äº†è‡ªåŠ¨å¤‡ä»½ç³»ç»Ÿé‡Œï¼Œåˆäº¤ç»™ä½ æ‰‹åŠ¨ç®¡ç†ã€‚ä½ æ‰‹åŠ¨åˆ é™¤äº†æ–‡ä»¶ï¼Œè‡ªåŠ¨ç³»ç»Ÿåˆå°è¯•åˆ é™¤ä¸€æ¬¡ï¼Œç»“æœæ•´ä¸ªç³»ç»Ÿå´©æºƒäº†ï¼

**æ­£ç¡®åšæ³•**ï¼š

```c++
class ResourceManager {
    std::shared_ptr<Resource> res;
public:
    void process() {
        // åªä½¿ç”¨shared_ptræ¥å£ï¼Œä¸è¦æ‰‹åŠ¨ç®¡ç†å†…å­˜
        res->doSomething();
        // è®©shared_ptrè‡ªåŠ¨å¤„ç†æ¸…ç†å·¥ä½œ
    }
};
```

### ğŸ’¡ å°è´´å£«
1.ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆæ—¶ï¼Œä¼˜å…ˆè€ƒè™‘`unique_ptr`ï¼Œåªæœ‰åœ¨ç¡®å®éœ€è¦å…±äº«æ‰€æœ‰æƒæ—¶æ‰ä½¿ç”¨`shared_ptr`

2.å¦‚æœé‡åˆ°å¾ªç¯å¼•ç”¨ï¼Œè€ƒè™‘ä½¿ç”¨`weak_ptr`æ‰“ç ´å¾ªç¯

3.ç»ä¸è¦æ‰‹åŠ¨åˆ é™¤æ™ºèƒ½æŒ‡é’ˆç®¡ç†çš„èµ„æº

4.å¦‚æœç±»éœ€è¦åœ¨å†…éƒ¨ä½¿ç”¨thisçš„shared_ptrï¼Œåº”è¯¥ç»§æ‰¿`enable_shared_from_this`

5.ç°ä»£C++ä¸­ï¼Œå»ºè®®ä½¿ç”¨`= delete`æ˜¾å¼ç¦ç”¨æ‹·è´ï¼Œè€Œä¸æ˜¯ä¾èµ–ç¼–è¯‘å™¨ç”Ÿæˆ

6.åœ¨æœ‰ç»§æ‰¿å…³ç³»çš„ç±»è®¾è®¡ä¸­ï¼ŒåŸºç±»ææ„å‡½æ•°å»ºè®®è®¾ç½®æˆè™šå‡½æ•°ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼ã€‚

## å››ã€å®¹å™¨å’Œæ•°æ®ç»“æ„
### 4.1ã€å®¹å™¨æ¸…ç†ä¸å®Œæ•´
#### 1. æŒ‡é’ˆå®¹å™¨æœªé‡Šæ”¾å…ƒç´ 
```c++
class ImageGallery {
    std::vector<Image*> images;
public:
    void addImage(const std::string& filename) {
        images.push_back(new Image(filename));
    }
    
    ~ImageGallery() {
        images.clear();  // é”™è¯¯ï¼åªæ¸…ç©ºäº†å®¹å™¨ï¼Œæ²¡æœ‰é‡Šæ”¾Imageå¯¹è±¡
    }
};
```

è¿™å°±åƒä½ æœ‰ä¸€ä¸ªç›¸å†Œï¼Œé‡Œé¢è´´ç€å„ç§ç…§ç‰‡çš„ä½ç½®ä¿¡æ¯ã€‚å½“ä½ æ‰”æ‰ç›¸å†Œæ—¶ï¼Œåªæ˜¯æ‰”æ‰äº†ç›®å½•ï¼Œä½†ç…§ç‰‡è¿˜æ•£è½åœ¨å„å¤„ï¼Œæ²¡äººçŸ¥é“å®ƒä»¬åœ¨å“ªé‡Œï¼Œä¹Ÿæ²¡äººèƒ½æ¸…ç†å®ƒä»¬ï¼

**æ­£ç¡®åšæ³•**ï¼š

```c++
class ImageGallery {
    std::vector<std::unique_ptr<Image>> images;
public:
    void addImage(const std::string& filename) {
        images.push_back(std::unique_ptr<Image>(new Image(filename)));
        // æˆ–è€…ä½¿ç”¨
        // images.emplace_back(new Image(filename));
    }
    
    // ä¸éœ€è¦ææ„å‡½æ•°ï¼Œvectoré”€æ¯æ—¶ä¼šè‡ªåŠ¨é‡Šæ”¾æ‰€æœ‰unique_ptr
};
```

#### 2. åµŒå¥—å®¹å™¨çš„å†…å­˜æ³„æ¼
```c++
class ChessGame {
    // æ£‹ç›˜ï¼š8x8çš„æ ¼å­ï¼Œæ¯ä¸ªæ ¼å­å¯èƒ½æœ‰ä¸€ä¸ªæ£‹å­
    std::vector<std::vector<ChessPiece*>> board;
public:
    ChessGame() {
        // åˆå§‹åŒ–8x8çš„æ£‹ç›˜
        board.resize(8);
        for(auto& row : board) {
            row.resize(8, nullptr);
        }
    }
    
    void placePiece(int row, int col, PieceType type) {
        board[row][col] = new ChessPiece(type);
    }
    
    ~ChessGame() {
        // åªæ¸…ç©ºäº†å¤–å±‚vectorï¼Œå†…å±‚çš„æŒ‡é’ˆéƒ½æ³„æ¼äº†
        board.clear();
    }
};
```

è¿™å°±åƒä½ æœ‰ä¸€ä¸ªå¤šå±‚æ–‡ä»¶æŸœï¼Œæ¯å±‚æœ‰å¤šä¸ªæŠ½å±‰ï¼ŒæŠ½å±‰é‡Œæ”¾ç€æ–‡ä»¶ã€‚ä½ åªæ˜¯æŠŠæ–‡ä»¶æŸœæ¬èµ°äº†ï¼Œä½†æ²¡æœ‰æ¸…ç©ºæ¯ä¸ªæŠ½å±‰é‡Œçš„æ–‡ä»¶ï¼Œè¿™äº›æ–‡ä»¶å°±æ°¸è¿œä¸¢åœ¨æŠ½å±‰äº†ï¼Œå ç©ºé—´ï¼

**æ­£ç¡®åšæ³•**ï¼š

```c++
class ChessGame {
    // ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆç®¡ç†æ£‹å­
    std::vector<std::vector<std::unique_ptr<ChessPiece>>> board;
public:
    ChessGame() {
        board.resize(8);
        for(auto& row : board) {
            row.resize(8);  // unique_ptré»˜è®¤åˆå§‹åŒ–ä¸ºnullptr
        }
    }
    void placePiece(int row, int col, PieceType type) {
       board[row][col].reset(new ChessPiece(type));  // C++11å†™æ³•ï¼Œç”¨resetä»£æ›¿make_unique
   }
    
    // ä¸éœ€è¦ææ„å‡½æ•°ï¼ŒåµŒå¥—å®¹å™¨ä¼šè‡ªåŠ¨æ¸…ç†
};
```

#### 3. å…³è”å®¹å™¨çš„å†…å­˜æ³„æ¼
```c++
class Dictionary {
    std::map<std::string, Definition*> words;
public:
    void addWord(const std::string& word, const std::string& meaning) {
        words[word] = new Definition(meaning);
    }
    
    ~Dictionary() {
        // åªæ˜¯æ¸…é™¤äº†mapï¼Œä½†Definitionå¯¹è±¡ä»ç„¶æ³„æ¼
        words.clear();
    }
};
```

è¿™å°±åƒä½ æœ‰ä¸€æœ¬åœ°å€ç°¿ï¼Œè®°å½•ç€æœ‹å‹çš„åå­—å’Œä½å€ã€‚å½“ä½ æ‰”æ‰åœ°å€ç°¿æ—¶ï¼Œæœ‹å‹çš„æˆ¿å­å¹¶ä¸ä¼šæ¶ˆå¤±ï¼Œå®ƒä»¬ä»ç„¶å ç€åœ°æ–¹ï¼Œä½†ä½ å†ä¹Ÿæ‰¾ä¸åˆ°å®ƒä»¬äº†ï¼

**æ­£ç¡®åšæ³•**ï¼š

```c++
class Dictionary {
    std::map<std::string, std::unique_ptr<Definition>> words;
public:
    void addWord(const std::string& word, const std::string& meaning) {
        words[word].reset(new Definition(meaning));
        // æˆ–è€…
        // words[word] = std::unique_ptr<Definition>(new Definition(meaning));
    }
    
    // ä¸éœ€è¦æ‰‹åŠ¨æ¸…ç†ï¼Œmapé”€æ¯æ—¶ä¼šå¤„ç†æ‰€æœ‰Definition
};
```

### 4.2ã€è‡ªå®šä¹‰æ•°æ®ç»“æ„ç®¡ç†ä¸å½“
#### 1. é“¾è¡¨èŠ‚ç‚¹åˆ é™¤ä¸å®Œæ•´
```c++
struct ListNode {
    int data;
    ListNode* next;
    
    ListNode(int val) : data(val), next(nullptr) {}
};

class LinkedList {
    ListNode* head;
public:
    LinkedList() : head(nullptr) {}
    
    void append(int val) {
        //è¿½åŠ èŠ‚ç‚¹
        // ...
        current->next = new ListNode(val);
    }
    
    ~LinkedList() {
        // é”™è¯¯ï¼åªåˆ é™¤äº†å¤´èŠ‚ç‚¹ï¼Œå…¶ä»–èŠ‚ç‚¹å…¨éƒ¨æ³„æ¼
        delete head;
    }
};
```

è¿™å°±åƒä¸€åˆ—ç«è½¦ï¼Œä½ åªæŠŠç«è½¦å¤´æ‹–èµ°äº†ï¼Œä½†æ‰€æœ‰è½¦å¢è¿˜è¿åœ¨ä¸€èµ·åœåœ¨é“è½¨ä¸Šï¼Œæ— äººè®¤é¢†ä¹Ÿæ— æ³•ç§»åŠ¨ï¼

**æ­£ç¡®åšæ³•**ï¼š

```c++
class LinkedList {
    ListNode* head;
public:
    LinkedList() : head(nullptr) {}
    
    void append(int val) {
        // åŒä¸Š...
    }
    
    ~LinkedList() {
        // æ­£ç¡®åšæ³•ï¼šéå†åˆ é™¤æ‰€æœ‰èŠ‚ç‚¹
        ListNode* current = head;
        while(current) {
            ListNode* next = current->next;
            delete current;
            current = next;
        }
    }
};
```

#### 2. æ ‘ç»“æ„çš„éƒ¨åˆ†æ¸…ç†
```c++
struct TreeNode {
    int value;
    TreeNode* left;
    TreeNode* right;
    
    TreeNode(int v) : value(v), left(nullptr), right(nullptr) {}
};

class BinaryTree {
    TreeNode* root;
public:
    // çœç•¥æ·»åŠ èŠ‚ç‚¹çš„ä»£ç ...
    
    ~BinaryTree() {
        // é”™è¯¯ï¼åªåˆ é™¤äº†æ ¹èŠ‚ç‚¹ï¼Œæ‰€æœ‰å­èŠ‚ç‚¹éƒ½æ³„æ¼äº†
        delete root;
    }
};
```

è¿™å°±åƒä½ ç å€’äº†ä¸€æ£µå¤§æ ‘ï¼Œä½†åªæ¸…ç†äº†ä¸»å¹²ï¼Œæ‰€æœ‰çš„æ ‘æå’Œæ ‘å¶éƒ½æ•£è½åœ¨åœ°ä¸Šæ²¡äººæ¸…ç†ï¼éšç€æ—¶é—´æ¨ç§»ï¼Œè¿™äº›æ ‘ææ ‘å¶å æ®äº†è¶Šæ¥è¶Šå¤šçš„ç©ºé—´ã€‚

**æ­£ç¡®åšæ³•**ï¼š

```c++
class BinaryTree {
    TreeNode* root;
    
    // é€’å½’åˆ é™¤èŠ‚ç‚¹åŠå…¶æ‰€æœ‰å­èŠ‚ç‚¹
    void deleteSubtree(TreeNode* node) {
        if(!node) return;
        
        // å…ˆåˆ é™¤å·¦å³å­æ ‘
        deleteSubtree(node->left);
        deleteSubtree(node->right);
        
        // å†åˆ é™¤å½“å‰èŠ‚ç‚¹
        delete node;
    }
    
public:
    // çœç•¥æ·»åŠ èŠ‚ç‚¹çš„ä»£ç ...
    
    ~BinaryTree() {
        deleteSubtree(root);
    }
};
```

#### 3. å›¾ç»“æ„çš„å†…å­˜æ³„æ¼
```c++
struct GraphNode {
    int id;
    std::vector<GraphNode*> neighbors;
    
    GraphNode(int i) : id(i) {}
};

class Graph {
    std::vector<GraphNode*> nodes;
public:
    void addNode(int id) {
        nodes.push_back(new GraphNode(id));
    }
    
    void addEdge(int from, int to) {
        // ç®€åŒ–ä»£ç ï¼Œå‡è®¾èŠ‚ç‚¹ä¸€å®šå­˜åœ¨
        GraphNode* fromNode = findNode(from);
        GraphNode* toNode = findNode(to);
        fromNode->neighbors.push_back(toNode);
    }
    
    ~Graph() {
        // é”™è¯¯ï¼åªåˆ é™¤äº†èŠ‚ç‚¹ï¼Œæ²¡æœ‰å¤„ç†èŠ‚ç‚¹å†…éƒ¨çš„é‚»å±…å®¹å™¨
        for(auto* node : nodes) {
            delete node;
        }
    }
};
```

è¿™å°±åƒä¸€ä¸ªç¤¾äº¤ç½‘ç»œï¼Œæ¯ä¸ªäººæœ‰å¾ˆå¤šå¥½å‹è¿æ¥ã€‚å½“ä½ é€€å‡ºçš„æ—¶å€™ï¼Œåªåˆ é™¤äº†è´¦å·ï¼Œä½†æ‰€æœ‰çš„å¥½å‹å…³ç³»è¿˜ä¿å­˜åœ¨ç³»ç»Ÿä¸­ï¼Œå ç”¨ç€å¤§é‡ç©ºé—´å´æ— æ³•è®¿é—®ï¼

**æ­£ç¡®åšæ³•**ï¼š

```c++
class Graph {
    std::vector<std::unique_ptr<GraphNode>> nodes;
public:
    void addNode(int id) {
        nodes.push_back(std::unique_ptr<GraphNode>(new GraphNode(id)));
    }
    
    void addEdge(int from, int to) {
        GraphNode* fromNode = findNode(from);
        GraphNode* toNode = findNode(to);
        // åªå­˜å‚¨åŸå§‹æŒ‡é’ˆä½œä¸ºå¼•ç”¨ï¼Œä¸è´Ÿè´£é‡Šæ”¾
        fromNode->neighbors.push_back(toNode);
    }
    
    // ä¸éœ€è¦ææ„å‡½æ•°ï¼Œvectorä¼šè‡ªåŠ¨é‡Šæ”¾æ‰€æœ‰èŠ‚ç‚¹
};
```

### ğŸ’¡ å°è´´å£«
1.å®¹å™¨å­˜å‚¨æŒ‡é’ˆæ—¶ï¼Œä¼˜å…ˆä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ

2.å¯¹äºåµŒå¥—å®¹å™¨ï¼Œæ¯ä¸€å±‚éƒ½éœ€è¦è€ƒè™‘å†…å­˜ç®¡ç†

3.æ¸…ç†å¤æ‚æ•°æ®ç»“æ„æ—¶ï¼Œè®°ä½è¦é€’å½’åœ°æ¸…ç†æ‰€æœ‰å­èŠ‚ç‚¹

## äº”ã€ç³»ç»Ÿèµ„æºç›¸å…³
### 5.1ã€æ–‡ä»¶æ“ä½œç›¸å…³
#### 1. æ‰“å¼€æ–‡ä»¶åæœªå…³é—­
```c++
class LogManager {
public:
    void writeLog(const std::string& message) {
        FILE* logFile = fopen("app.log", "a");
        if(logFile) {
            fprintf(logFile, "%s\n", message.c_str());
            // ç³Ÿç³•ï¼Œå¿˜è®°è°ƒç”¨fclose(logFile)äº†ï¼
        }
    }
};
```

è¿™å°±åƒå¤§å®¶å»å›¾ä¹¦é¦†å€Ÿä¹¦ï¼Œçœ‹å®Œåç›´æ¥æ”¾åœ¨å®¶é‡Œä¹¦æ¶ä¸Šï¼Œæ—¢æ²¡è¿˜ç»™å›¾ä¹¦é¦†ï¼Œå…¶ä»–äººä¹Ÿå€Ÿä¸åˆ°è¿™æœ¬ä¹¦ã€‚æ—¶é—´ä¹…äº†ï¼Œå›¾ä¹¦é¦†çš„ä¹¦è¶Šæ¥è¶Šå°‘ï¼Œæœ€åæ²¡ä¹¦å¯å€Ÿï¼

**æ­£ç¡®åšæ³•**ï¼š

```c++
class LogManager {
public:
    void writeLog(const std::string& message) {
        // ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ(å¸¦æœ‰è‡ªå®šä¹‰åˆ é™¤å™¨)ç®¡ç†æ–‡ä»¶èµ„æº
        std::unique_ptr<FILE, decltype(&fclose)> logFile(
            fopen("app.log", "a"), fclose
        );
        
        if(logFile) {
            fprintf(logFile.get(), "%s\n", message.c_str());
            // ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨è°ƒç”¨fclose
        }
    }
};
```

#### 2. å¼‚å¸¸å¯¼è‡´æ–‡ä»¶æœªå…³é—­
```c++
void analyzeData(const std::string& filename) {
    FILE* file = fopen(filename.c_str(), "r");
    if(!file) return;
    
    char line[1024];
    while(fgets(line, sizeof(line), file)) {
        if(somethingWrong()) {
            throw std::runtime_error("å¤„ç†å‡ºé”™");  // å¼‚å¸¸å‘ç”Ÿæ—¶ï¼Œfcloseä¸ä¼šè¢«è°ƒç”¨
        }
    }
    
    fclose(file);  // å¦‚æœå‘ç”Ÿå¼‚å¸¸ï¼Œè¿™è¡Œæ°¸è¿œä¸ä¼šæ‰§è¡Œ
}
```

**æ­£ç¡®åšæ³•**ï¼š

```c++
void analyzeData(const std::string& filename) {
    // ä½¿ç”¨RAIIï¼Œæ–‡ä»¶æµå¯¹è±¡è‡ªåŠ¨ç®¡ç†
    std::ifstream file(filename);
    if(!file.is_open()) return;
    
    std::string line;
    while(std::getline(file, line)) {
        // å³ä½¿æŠ›å‡ºå¼‚å¸¸ï¼Œfileä¹Ÿä¼šè‡ªåŠ¨å…³é—­
        processLine(line);
    }
    
    // ä¸éœ€è¦æ‰‹åŠ¨closeï¼Œç¦»å¼€ä½œç”¨åŸŸè‡ªåŠ¨å…³é—­
}
```

### 5.2ã€ç½‘ç»œèµ„æºæœªé‡Šæ”¾
#### 1. å¥—æ¥å­—(Socket)æœªå…³é—­
```c++
class SimpleServer {
    int serverSocket;
public:
    void start() {
        serverSocket = socket(AF_INET, SOCK_STREAM, 0);
        // é…ç½®socket...
        bind(serverSocket, ...);
        listen(serverSocket, ...);
        
        while(true) {
            int clientSocket = accept(serverSocket, ...);
            if(checkError()) {
                return;  // é”™è¯¯ï¼åœ¨é”™è¯¯æƒ…å†µä¸‹æœªå…³é—­serverSocket
            }
            
            // å¤„ç†å®¢æˆ·ç«¯è¿æ¥...
            close(clientSocket);  // å…³é—­å®¢æˆ·ç«¯socket
        }
        
        close(serverSocket);
    }
};
```

è¿™å°±åƒä½ åœ¨å…¬å…±ä¼šè®®å¤§å…é¢„å®šäº†ä¸€ä¸ªå›ºå®šçš„ä¼šè®®é¢‘é“è¿›è¡Œè§†é¢‘ä¼šè®®ï¼Œçªç„¶é‡åˆ°æŠ€æœ¯é—®é¢˜å°±ç›´æ¥ç¦»å¼€äº†ï¼Œå´æ²¡æœ‰é‡Šæ”¾è¿™ä¸ªé¢‘é“ã€‚ç³»ç»Ÿä¸­çš„å¯ç”¨é¢‘é“è¶Šæ¥è¶Šå°‘ï¼Œå…¶ä»–ç”¨æˆ·æ— æ³•å»ºç«‹æ–°çš„ä¼šè®®ï¼Œè€Œé‚£äº›è¢«å ç”¨çš„é¢‘é“å´ç©ºæ— ä¸€äººï¼

**æ­£ç¡®åšæ³•**ï¼š

```c++
class SimpleServer {
    class SocketGuard {
        int fd;
    public:
        SocketGuard(int socket) : fd(socket) {}
        ~SocketGuard() { if(fd >= 0) close(fd); }
        int get() const { return fd; }
    };
    
    SocketGuard serverSocket;
public:
    void start() {
        serverSocket = SocketGuard(socket(AF_INET, SOCK_STREAM, 0));
        // é…ç½®socket...
        bind(serverSocket.get(), ...);
        listen(serverSocket.get(), ...);
        
        while(true) {
            SocketGuard clientSocket(accept(serverSocket.get(), ...));
            if(checkError()) {
                return;  // å®‰å…¨ï¼serverSocketä¼šè‡ªåŠ¨å…³é—­
            }
            
            // å¤„ç†å®¢æˆ·ç«¯è¿æ¥...
            // clientSocketç¦»å¼€ä½œç”¨åŸŸè‡ªåŠ¨å…³é—­
        }
        
        // serverSocketç¦»å¼€ä½œç”¨åŸŸè‡ªåŠ¨å…³é—­
    }
};
```

#### 2. æ•°æ®åº“è¿æ¥æœªå…³é—­
```c++
void queryDatabase() {
    DBConnection* conn = DBConnection::open("db_server");
    // æ‰§è¡ŒæŸ¥è¯¢...
    
    if(queryFailed()) {
        return;  // é”™è¯¯ï¼è¿æ¥æœªå…³é—­
    }
    
    conn->close();
    delete conn;
}
```

**æ­£ç¡®åšæ³•**ï¼š

```c++
void queryDatabase() {
    // ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆå’Œè‡ªå®šä¹‰åˆ é™¤å™¨
    std::unique_ptr<DBConnection, std::function<void(DBConnection*)>> conn(
        DBConnection::open("db_server"),
        [](DBConnection* c) { 
            if(c) {
                c->close();
                delete c;
            }
        }
    );
    
    // æ‰§è¡ŒæŸ¥è¯¢...
    if(queryFailed()) {
        return;  // å®‰å…¨ï¼connä¼šè‡ªåŠ¨æ¸…ç†
    }
    
    // ä¸éœ€è¦æ‰‹åŠ¨å…³é—­ï¼Œç¦»å¼€ä½œç”¨åŸŸè‡ªåŠ¨å¤„ç†
}
```

### 5.3ã€ç³»ç»Ÿèµ„æºæœªé‡Šæ”¾
#### 1. äº’æ–¥é‡ï¼ˆMutexï¼‰æœªé”€æ¯
```c++
class ThreadSafeCounter {
    int count;
    pthread_mutex_t mutex;
public:
    ThreadSafeCounter() {
        count = 0;
        pthread_mutex_init(&mutex, NULL);
    }
    
    void increment() {
        pthread_mutex_lock(&mutex);
        count++;
        pthread_mutex_unlock(&mutex);
    }
    
    // é”™è¯¯ï¼å¿˜è®°åœ¨ææ„å‡½æ•°ä¸­é”€æ¯mutex
};
```

è¿™å°±åƒä½ åœ¨åŠå…¬å®¤è£…äº†ä¸ªç‰¹æ®Šçš„é—¨é”ï¼Œç¦»èŒæ—¶å´æ²¡æœ‰æ‹†é™¤ã€‚æ–°å‘˜å·¥æ— æ³•ä½¿ç”¨è¿™ä¸ªåŠå…¬å®¤ï¼Œå› ä¸ºé”è¿˜åœ¨ä½†é’¥åŒ™å·²ç»ä¸¢å¤±ï¼

**æ­£ç¡®åšæ³•**ï¼š

```c++
class ThreadSafeCounter {
    int count;
    std::mutex mutex;  // ä½¿ç”¨C++æ ‡å‡†åº“çš„mutex
public:
    ThreadSafeCounter() : count(0) {}
    
    void increment() {
        std::lock_guard<std::mutex> lock(mutex);
        count++;
        // é”ä¼šåœ¨ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨é‡Šæ”¾
    }
    
    // ä¸éœ€è¦æ‰‹åŠ¨é”€æ¯ï¼Œmutexä¼šè‡ªåŠ¨æ¸…ç†
};
```

#### 2. åŠ¨æ€åŠ è½½çš„åº“æœªå¸è½½
```c++
void loadPlugin() {
    void* handle = dlopen("plugin.so", RTLD_LAZY);  // åŠ è½½åŠ¨æ€åº“
    if(!handle) return;  // åŠ è½½å¤±è´¥ç›´æ¥è¿”å›ï¼Œæ²¡é—®é¢˜
    
    // è·å–å‡½æ•°æŒ‡é’ˆ
    void (*func)() = (void(*)())dlsym(handle, "pluginFunction");
    if(!func) {
        return;  // é”™è¯¯ï¼åœ¨è¿™é‡Œç›´æ¥è¿”å›ï¼Œå¿˜è®°è°ƒç”¨dlclose(handle)å¯¼è‡´åº“èµ„æºæ³„æ¼
    }
    
    // ä½¿ç”¨æ’ä»¶...
    func();
    
    dlclose(handle);  // æ­£å¸¸è·¯å¾„ä¼šé‡Šæ”¾èµ„æºï¼Œä½†é”™è¯¯è·¯å¾„ä¸ä¼š
}
```

**æ­£ç¡®åšæ³•**ï¼š

```c++
class DynamicLibrary {
    void* handle;
public:
    DynamicLibrary(const char* path) : handle(dlopen(path, RTLD_LAZY)) {}
    ~DynamicLibrary() { if(handle) dlclose(handle); }
    
    void* getSymbol(const char* name) {
        return handle ? dlsym(handle, name) : nullptr;
    }
    
    bool isLoaded() const { return handle != nullptr; }
};

void loadPlugin() {
    // ä½¿ç”¨RAIIåŒ…è£…åŠ¨æ€åº“
    DynamicLibrary plugin("plugin.so");
    if(!plugin.isLoaded()) return;
    
    // è·å–å‡½æ•°æŒ‡é’ˆ
    void (*func)() = (void(*)())plugin.getSymbol("pluginFunction");
    if(!func) {
        return;  // å®‰å…¨ï¼pluginä¼šè‡ªåŠ¨å¸è½½
    }
    
    // ä½¿ç”¨æ’ä»¶...
    func();
    
    // ä¸éœ€è¦æ‰‹åŠ¨å¸è½½ï¼Œç¦»å¼€ä½œç”¨åŸŸè‡ªåŠ¨å¤„ç†
}
```

### 5.4ã€å…¶ä»–ç³»ç»Ÿèµ„æºæ³„æ¼
#### 2. å…±äº«å†…å­˜åŒºåŸŸæœªè§£é™¤æ˜ å°„
```c++
void useSharedMemory() {
    // æ‰“å¼€å…±äº«å†…å­˜
    int fd = shm_open("/myshm", O_RDWR, 0666);
    if(fd == -1) return;
    
    // æ˜ å°„åˆ°è¿›ç¨‹ç©ºé—´
    void* addr = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    if(addr == MAP_FAILED) {
        close(fd);
        return;
    }
    
    // ä½¿ç”¨å…±äº«å†…å­˜...
    
    if(processError()) {
        close(fd);
        return;  // é”™è¯¯ï¼å¿˜è®°è°ƒç”¨munmapè§£é™¤æ˜ å°„
    }
    
    // æ¸…ç†èµ„æº
    munmap(addr, 4096);
    close(fd);
}
```

è¿™å°±åƒä½ åœ¨ä¸€å—å…¬å…±ç™½æ¿ä¸Šä¿ç•™äº†ä¸€å—åŒºåŸŸåšç¬”è®°ï¼Œä¸­é€”æ”¾å¼ƒäº†ï¼Œå´æ²¡æœ‰æ“¦é™¤æ ‡è®°ã€‚è¿™å—åŒºåŸŸæ—¢ä¸èƒ½è¢«ä½ ç»§ç»­ä½¿ç”¨ï¼Œå…¶ä»–äººçœ‹åˆ°ä½ çš„æ ‡è®°ä¹Ÿä¸æ•¢ä½¿ç”¨ï¼Œç™½æ¿ç©ºé—´å°±è¿™æ ·è¢«ç™½ç™½æµªè´¹äº†ï¼

**æ­£ç¡®åšæ³•**ï¼š

```c++
class SharedMemory {
    int fd;
    void* addr;
    size_t size;
public:
    SharedMemory(const char* name, size_t sz) : 
        fd(-1), addr(MAP_FAILED), size(sz) {
        fd = shm_open(name, O_RDWR, 0666);
        if(fd != -1) {
            addr = mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
        }
    }
    
    ~SharedMemory() {
        if(addr != MAP_FAILED) munmap(addr, size);
        if(fd != -1) close(fd);
    }
    
    void* get() const { return addr; }
    bool isValid() const { return fd != -1 && addr != MAP_FAILED; }
};

void useSharedMemory() {
    // ä½¿ç”¨RAIIç®¡ç†å…±äº«å†…å­˜
    SharedMemory shm("/myshm", 4096);
    if(!shm.isValid()) return;
    
    // ä½¿ç”¨å…±äº«å†…å­˜...
    if(processError()) {
        return;  // å®‰å…¨ï¼shmä¼šè‡ªåŠ¨æ¸…ç†
    }
    
    // ä¸éœ€è¦æ‰‹åŠ¨æ¸…ç†ï¼Œç¦»å¼€ä½œç”¨åŸŸè‡ªåŠ¨å¤„ç†
}
```

### ğŸ’¡ å°è´´å£«
1.å¯¹äºç³»ç»Ÿèµ„æºï¼Œå°½é‡ä½¿ç”¨RAIIæŠ€æœ¯è‡ªåŠ¨ç®¡ç†ç”Ÿå‘½å‘¨æœŸ

2.å¯ä»¥ç¼–å†™ç®€å•çš„èµ„æºåŒ…è£…ç±»ï¼Œæˆ–ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆé…åˆè‡ªå®šä¹‰åˆ é™¤å™¨

3.C++æ ‡å‡†åº“å·²ç»æä¾›äº†è®¸å¤šèµ„æºç®¡ç†ç±»(å¦‚std::fstream, std::mutex)ï¼Œä¼˜å…ˆä½¿ç”¨å®ƒä»¬

4.å¯¹äºä¸åŒç±»å‹çš„ç³»ç»Ÿèµ„æºï¼Œè®°ä½å®ƒä»¬ç‰¹å®šçš„æ¸…ç†å‡½æ•°(close, dlclose, munmapç­‰)

5.ç‰¹åˆ«æ³¨æ„å¼‚å¸¸å®‰å…¨ï¼Œç¡®ä¿å‘ç”Ÿå¼‚å¸¸æ—¶èµ„æºèƒ½è¢«æ­£ç¡®é‡Šæ”¾

## å…­ã€å¤šçº¿ç¨‹åœºæ™¯
### 6.1ã€çº¿ç¨‹èµ„æºç®¡ç†
#### 1. çº¿ç¨‹å¯¹è±¡æœªæ­£ç¡®é‡Šæ”¾
```c++
class DownloadManager {
    std::vector<pthread_t> threads;
public:
    void downloadFile(const std::string& url) {
        pthread_t thread;
        if(pthread_create(&thread, nullptr, downloadThread, 
                         new std::string(url)) == 0) {
            threads.push_back(thread);
        }
    }
    
    // é”™è¯¯ï¼ææ„å‡½æ•°ä¸­æ²¡æœ‰ç­‰å¾…çº¿ç¨‹ç»“æŸ
    ~DownloadManager() {
        // çº¿ç¨‹è¿˜åœ¨è¿è¡Œï¼Œä½†DownloadManagerå·²ç»é”€æ¯
    }
};
```

**æ­£ç¡®åšæ³•**ï¼š

```c++
class DownloadManager {
    std::vector<std::thread> threads;  // ä½¿ç”¨C++æ ‡å‡†çº¿ç¨‹
public:
    void downloadFile(const std::string& url) {
        threads.emplace_back([url]() {
            // ä¸‹è½½é€»è¾‘...
        });
    }
    
    ~DownloadManager() {
        // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
        for(auto& thread : threads) {
            if(thread.joinable()) {
                thread.join();
            }
        }
    }
};
```

#### 2. çº¿ç¨‹å±€éƒ¨å­˜å‚¨(TLS)æœªæ¸…ç†
```c++
// çº¿ç¨‹å±€éƒ¨å­˜å‚¨
thread_local char* buffer = nullptr;  // æ¯ä¸ªçº¿ç¨‹çš„ä¸´æ—¶ç¼“å†²åŒº

void workerThread(int threadId) {
    // æ¯ä¸ªçº¿ç¨‹åˆ›å»ºè‡ªå·±çš„ç¼“å†²åŒº
    buffer = new char[100];
    sprintf(buffer, "çº¿ç¨‹%dçš„æ•°æ®", threadId);
    
    // çº¿ç¨‹å·¥ä½œ...
    std::cout << "æ­£åœ¨å¤„ç†: " << buffer << std::endl;
    
    // çº¿ç¨‹ç»“æŸï¼Œä½†å¿˜è®°é‡Šæ”¾ç¼“å†²åŒº
    // åº”è¯¥ delete[] bufferï¼Œä½†å¿˜è®°äº†
}

void startWorkers() {
    std::vector<std::thread> threads;
    // åˆ›å»º5ä¸ªå·¥ä½œçº¿ç¨‹
    for(int i = 0; i < 5; i++) {
        threads.emplace_back(workerThread, i);
    }
    
    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹ç»“æŸ
    for(auto& t : threads) {
        t.join();
    }
    // 5ä¸ªçº¿ç¨‹çš„ç¼“å†²åŒºéƒ½æ³„æ¼äº†ï¼
}
```

è¿™å°±åƒ100ä¸ªå‘˜å·¥å„è‡ªé¢†å–äº†ä¸€å¥—å·¥å…·ï¼Œä¸‹ç­æ—¶å…¨éƒ½å¿˜è®°å½’è¿˜ã€‚å…¬å¸æŸå¤±äº†100å¥—å·¥å…·ï¼Œè€Œè¿™äº›å·¥å…·æ•£è½å„å¤„æ— äººçŸ¥æ™“ï¼

**æ­£ç¡®åšæ³•**ï¼š

```c++
// ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆè‡ªåŠ¨ç®¡ç†ç¼“å†²åŒº
thread_local std::unique_ptr<char[]> buffer;

void workerThread(int threadId) {
    buffer.reset(new char[100]);
    // æˆ–è€…ç›´æ¥èµ‹å€¼
    // buffer = std::unique_ptr<char[]>(new char[100]);
    
    sprintf(buffer.get(), "çº¿ç¨‹%dçš„æ•°æ®", threadId);
    
    // çº¿ç¨‹å·¥ä½œ...
    std::cout << "æ­£åœ¨å¤„ç†: " << buffer.get() << std::endl;
    
    // çº¿ç¨‹ç»“æŸæ—¶ï¼Œæ™ºèƒ½æŒ‡é’ˆè‡ªåŠ¨é‡Šæ”¾ç¼“å†²åŒº
}
```
**æˆ–è€…æ›´ç®€å•çš„æ–¹å¼**ï¼š
```c++
// ç›´æ¥ä½¿ç”¨stringä½œä¸ºç¼“å†²åŒº
thread_local std::string buffer;

void workerThread(int threadId) {
    // ç›´æ¥ä½¿ç”¨stringï¼Œä¸éœ€è¦ç®¡ç†å†…å­˜
    buffer = "çº¿ç¨‹" + std::to_string(threadId) + "çš„æ•°æ®";
    
    // çº¿ç¨‹å·¥ä½œ...
    std::cout << "æ­£åœ¨å¤„ç†: " << buffer << std::endl;
    
    // çº¿ç¨‹ç»“æŸæ—¶ï¼Œstringè‡ªåŠ¨æ¸…ç†
}
```

### 6.2ã€å›è°ƒå‡½æ•°ç›¸å…³
#### 1. åŠ¨æ€åˆ†é…çš„å›è°ƒå‡½æ•°å¯¹è±¡æœªé‡Šæ”¾
```c++
class TimerSystem {
    using Callback = void(*)(void*);
    struct CallbackInfo {
        Callback func;
        void* userData;
    };
    
    std::vector<CallbackInfo*> callbacks;
public:
    void registerCallback(Callback cb, void* data) {
        CallbackInfo* info = new CallbackInfo{cb, data};
        callbacks.push_back(info);
    }
    
    void cleanup() {
        // é”™è¯¯ï¼åªæ˜¯æ¸…ç©ºvectorï¼Œæ²¡æœ‰é‡Šæ”¾CallbackInfoå¯¹è±¡
        callbacks.clear();
    }
};
```

**æ­£ç¡®åšæ³•**ï¼š

```c++
class TimerSystem {
    using Callback = std::function<void()>;
    std::vector<std::unique_ptr<Callback>> callbacks;
public:
    void registerCallback(Callback cb) {
        // å…ˆåˆ›å»ºunique_ptrï¼Œå†push_back
        std::unique_ptr<Callback> callbackPtr(new Callback(std::move(cb)));
        callbacks.push_back(std::move(callbackPtr));
    }
    
    // ä¸éœ€è¦æ‰‹åŠ¨æ¸…ç†ï¼Œvectoré”€æ¯æ—¶ä¼šè‡ªåŠ¨é‡Šæ”¾æ‰€æœ‰å›è°ƒå¯¹è±¡
};
```

#### 2. å¼‚æ­¥æ“ä½œä¸­çš„å†…å­˜æ³„æ¼
```c++
void processAsyncRequest(const Request& req) {
    auto* context = new RequestContext(req);
    
    std::thread([context]() {
        // å¼‚æ­¥å¤„ç†è¯·æ±‚...
        
        if(requestFailed()) {
            // é”™è¯¯ï¼å¼‚æ­¥çº¿ç¨‹é€€å‡ºï¼Œä½†å¿˜è®°åˆ é™¤context
            return;
        }
        
        // ...ç»§ç»­å¤„ç†
        delete context;
    }).detach();  // åˆ†ç¦»çº¿ç¨‹ï¼Œæ— æ³•æ§åˆ¶å…¶ç”Ÿå‘½å‘¨æœŸ
}
```

è¿™å°±åƒä½ æŠŠä¸€é¡¹é‡è¦ä»»åŠ¡å§”æ‰˜ç»™åŠ©æ‰‹åå°±ä¸ç®¡äº†ï¼Œä½†åŠ©æ‰‹é‡åˆ°é—®é¢˜å¯èƒ½ä¸­é€”æ”¾å¼ƒä»»åŠ¡ã€‚æ—¢æ²¡æœ‰å®Œæˆå·¥ä½œï¼Œä¹Ÿæ²¡æœ‰å½’è¿˜å·¥ä½œææ–™ï¼Œè€Œä½ å·²ç»å¤±å»äº†ä¸åŠ©æ‰‹çš„è”ç³»ï¼

**æ­£ç¡®åšæ³•**ï¼š

```c++
void processAsyncRequest(const Request& req) {
    // ä½¿ç”¨shared_ptrè‡ªåŠ¨ç®¡ç†ä¸Šä¸‹æ–‡
    auto context = std::make_shared<RequestContext>(req);
    
    std::thread([context]() {
        // å¼‚æ­¥å¤„ç†è¯·æ±‚...
        
        if(requestFailed()) {
            return;  // å®‰å…¨ï¼contextä¼šè‡ªåŠ¨é‡Šæ”¾
        }
        
        // ...ç»§ç»­å¤„ç†
        // ä¸éœ€è¦æ‰‹åŠ¨åˆ é™¤ï¼Œshared_pträ¼šè‡ªåŠ¨å¤„ç†
    }).detach();
}
```

### ğŸ’¡ å°è´´å£«
1.åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸­ï¼Œæ€»æ˜¯ä½¿ç”¨RAIIå’Œæ™ºèƒ½æŒ‡é’ˆæ¥ç®¡ç†èµ„æº

2.æ³¨æ„çº¿ç¨‹çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼Œç¡®ä¿ç”¨join()æˆ–detach()å¤„ç†æ‰€æœ‰çº¿ç¨‹

3.é¿å…ä½¿ç”¨åŸå§‹æŒ‡é’ˆä¼ é€’æ•°æ®ç»™çº¿ç¨‹ï¼Œä¼˜å…ˆä½¿ç”¨å€¼ä¼ é€’æˆ–æ™ºèƒ½æŒ‡é’ˆ

4.çº¿ç¨‹å±€éƒ¨å­˜å‚¨ä¹Ÿéœ€è¦æ³¨æ„å†…å­˜ç®¡ç†ï¼ŒåŒæ ·å¯ä»¥ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ

5.ä½¿ç”¨æ ‡å‡†åº“çš„çº¿ç¨‹å·¥å…·(std::thread, std::mutex)è€Œéåº•å±‚API

6.å¼‚æ­¥æ“ä½œå°¤å…¶è¦æ³¨æ„èµ„æºç®¡ç†ï¼Œå› ä¸ºç”Ÿå‘½å‘¨æœŸæ›´éš¾è¿½è¸ª

## ä¸ƒã€æ¡†æ¶å’Œç»„ä»¶é›†æˆ
### 7.1ã€è·¨æ¨¡å—èµ„æºç®¡ç†
#### 1. åœ¨ä¸€ä¸ªæ¨¡å—åˆ†é…å†…å­˜ï¼Œåœ¨å¦ä¸€ä¸ªæ¨¡å—é‡Šæ”¾
```c++
// æ¨¡å—A (render_engine.dll)
extern "C" void* createTexture(int width, int height) {
    return new Texture(width, height);  // Aæ¨¡å—åˆ†é…å†…å­˜
}

// æ¨¡å—B (game_logic.dll)
void loadGameAssets() {
    void* texture = createTexture(1024, 768);
    // ...ä½¿ç”¨texture...
    free(texture);  // é”™è¯¯ï¼Bæ¨¡å—ç”¨é”™è¯¯çš„æ–¹å¼é‡Šæ”¾Aæ¨¡å—åˆ†é…çš„å†…å­˜
}
```

è¿™å°±åƒä¸¤ä¸ªä¸åŒéƒ¨é—¨åˆä½œä¸€ä¸ªé¡¹ç›®ï¼šå¸‚åœºéƒ¨é—¨ç§Ÿäº†åœºåœ°ï¼Œä½†è®©æŠ€æœ¯éƒ¨é—¨å»é€€ç§Ÿã€‚æŠ€æœ¯éƒ¨é—¨ä¸çŸ¥é“å…·ä½“ç§Ÿçº¦ç»†èŠ‚ï¼Œä¸çŸ¥é“æ€ä¹ˆé€€ï¼Œç»“æœåœºåœ°è´¹ç”¨ä¸€ç›´åœ¨è®¡è´¹ï¼

**æ­£ç¡®åšæ³•**ï¼š

```c++
// æ¨¡å—A (render_engine.dll)
extern "C" void* createTexture(int width, int height) {
    return new Texture(width, height);
}

extern "C" void destroyTexture(void* texture) {  // æä¾›é…å¯¹çš„é‡Šæ”¾å‡½æ•°
    delete static_cast<Texture*>(texture);
}

// æ¨¡å—B (game_logic.dll)
void loadGameAssets() {
    void* texture = createTexture(1024, 768);
    // ...ä½¿ç”¨texture...
    destroyTexture(texture);  // ä½¿ç”¨æ­£ç¡®çš„é‡Šæ”¾å‡½æ•°
}
```

#### 2. æ¨¡å—é—´æ¥å£çº¦å®šä¸æ¸…
```c++
// ç¬¬ä¸‰æ–¹åº“
struct Buffer {
    void* data;
    size_t size;
};

Buffer* lib_create_buffer(size_t size);  // æ–‡æ¡£æ²¡è¯´æ˜è°è´Ÿè´£é‡Šæ”¾

// åº”ç”¨ä»£ç 
void processData() {
    Buffer* buf = lib_create_buffer(1024);
    // ä½¿ç”¨buf...
    
    // ä¸ç¡®å®šæ˜¯å¦åº”è¯¥é‡Šæ”¾ï¼Œæœ€ç»ˆæ²¡æœ‰é‡Šæ”¾
    // å®é™…ä¸Šåº”è¯¥é‡Šæ”¾ä½†æ²¡è¯´æ˜ï¼Œå¯¼è‡´æ³„æ¼
}
```

**æ­£ç¡®åšæ³•**ï¼š

```c++
// ç¬¬ä¸‰æ–¹åº“åº”è¯¥æ˜ç¡®æ–‡æ¡£
Buffer* lib_create_buffer(size_t size);  // è°ƒç”¨è€…è´Ÿè´£é€šè¿‡lib_free_bufferé‡Šæ”¾
void lib_free_buffer(Buffer* buf);       // é…å¥—çš„é‡Šæ”¾å‡½æ•°

// æ›´å¥½çš„æ–¹å¼ï¼šä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆå’Œè‡ªå®šä¹‰åˆ é™¤å™¨å°è£…
std::unique_ptr<Buffer, decltype(&lib_free_buffer)> 
    createSafeBuffer(size_t size) {
    return {lib_create_buffer(size), lib_free_buffer};
}

void processData() {
    auto buf = createSafeBuffer(1024);
    // ä½¿ç”¨buf.get()...
    // è‡ªåŠ¨é‡Šæ”¾ï¼Œä¸ä¼šæ³„æ¼
}
```

### 7.2ã€æ¡†æ¶é›†æˆé—®é¢˜
#### 1. å›è°ƒå‡½æ•°çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†
```c++
// UIæ¡†æ¶
class UIFramework {
public:
    using Callback = void(*)(void* userData);
    void registerClickHandler(Callback cb, void* userData);
};

// åº”ç”¨ä»£ç 
class Button {
    UIFramework* framework;
public:
    Button(UIFramework* fw) : framework(fw) {
        // æ³¨å†Œå›è°ƒ
        framework->registerClickHandler(onClickStatic, this);
    }
    
    // ææ„æ—¶æ²¡æœ‰å–æ¶ˆæ³¨å†Œï¼Œæ¡†æ¶å¯èƒ½ä¼šè°ƒç”¨å·²é”€æ¯å¯¹è±¡çš„å›è°ƒ
};
```

**æ­£ç¡®åšæ³•**ï¼š

```c++
class UIFramework {
public:
    using Callback = std::function<void()>;
    int registerClickHandler(Callback cb);  // è¿”å›å¤„ç†å™¨ID
    void unregisterHandler(int handlerId);
};

class Button {
    UIFramework* framework;
    int handlerId;
public:
    Button(UIFramework* fw) : framework(fw) {
        // ä½¿ç”¨lambdaæ•è·this
        handlerId = framework->registerClickHandler(
            [this]() { this->onClick(); }
        );
    }
    
    ~Button() {
        framework->unregisterHandler(handlerId);  // å–æ¶ˆæ³¨å†Œ
    }
};
```

#### 2. æ’ä»¶ç³»ç»Ÿçš„èµ„æºå…±äº«
```c++
// ä¸»åº”ç”¨
class Application {
public:
    SharedResource* getResource() {
        return new SharedResource();  // åˆ›å»ºèµ„æºå®ä¾‹
    }
};

// æ’ä»¶ä»£ç 
void PluginFunction(Application* app) {
    SharedResource* res = app->getResource();
    // ä½¿ç”¨èµ„æº...
    
    // æ’ä»¶ä¸ç¡®å®šæ˜¯å¦åº”è¯¥é‡Šæ”¾èµ„æº
    // ä¸»åº”ç”¨ä¹Ÿä¸çŸ¥é“æ’ä»¶æ˜¯å¦ä¼šé‡Šæ”¾
    // ç»“æœæ²¡äººé‡Šæ”¾ï¼Œé€ æˆæ³„æ¼
}
```

è¿™å°±åƒå…¬å¸æ€»éƒ¨ç»™åˆ†éƒ¨æä¾›äº†å…±äº«æ‰“å°æœºï¼Œä½†æ²¡è¯´æ¸…æ¥šè°è´Ÿè´£ç»´æŠ¤ã€‚åˆ†éƒ¨ä»¥ä¸ºæ€»éƒ¨ä¼šå¤„ç†ï¼Œæ€»éƒ¨ä»¥ä¸ºåˆ†éƒ¨ä¼šè´Ÿè´£ï¼Œç»“æœæ‰“å°æœºæ•…éšœæ— äººä¿®ç†ï¼Œæœ€ç»ˆæ— æ³•ä½¿ç”¨ï¼

**æ­£ç¡®åšæ³•**ï¼š

```c++
// ä¸»åº”ç”¨
class Application {
public:
    std::shared_ptr<SharedResource> getResource() {
        // ä½¿ç”¨å¼•ç”¨è®¡æ•°ç®¡ç†ç”Ÿå‘½å‘¨æœŸ
        return std::make_shared<SharedResource>();
    }
};

// æ’ä»¶ä»£ç 
void PluginFunction(Application* app) {
    auto res = app->getResource();
    // ä½¿ç”¨èµ„æº...
    
    // ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨å¤„ç†å¼•ç”¨è®¡æ•°
    // æœ€åä¸€ä¸ªå¼•ç”¨æ¶ˆå¤±æ—¶èµ„æºè‡ªåŠ¨é‡Šæ”¾
}
```

### 7.3ã€å…¶ä»–é›†æˆåœºæ™¯
#### 1. å¼‚æ„å†…å­˜ç®¡ç†
```c++
// Cä»£ç 
char* c_create_string(const char* input) {
    char* result = malloc(strlen(input) + 1);
    strcpy(result, input);
    return result;
}

// C++ä»£ç 
std::string processCString() {
    char* cstr = c_create_string("test");
    std::string result = cstr;
    delete cstr;  // é”™è¯¯ï¼ç”¨deleteé‡Šæ”¾mallocåˆ†é…çš„å†…å­˜
    return result;
}
```

è¿™å°±åƒä½ ä»è‡ªåŠ©é¤å…å–äº†é£Ÿç‰©ï¼Œå´æŠŠé¤ç›˜æ”¾è¿›äº†å’–å•¡å…çš„å›æ”¶å¤„ã€‚ä¸¤ä¸ªç³»ç»Ÿä¸å…¼å®¹ï¼Œå¯¼è‡´é¤å…·æ··ä¹±æ— æ³•æ­£ç¡®å¤„ç†ï¼

**æ­£ç¡®åšæ³•**ï¼š

```c++
std::string processCString() {
    char* cstr = c_create_string("test");
    std::string result = cstr;
    free(cstr);  // æ­£ç¡®ä½¿ç”¨é…å¯¹çš„é‡Šæ”¾å‡½æ•°
    return result;
}
```

#### 2. å·¥å‚æ¨¡å¼ä¸­çš„å†…å­˜æ³„æ¼
```c++
class WidgetFactory {
public:
    static Widget* createButton() {
        return new Button();
    }
    
    static Widget* createTextbox() {
        return new Textbox();
    }
    
    // æ²¡æœ‰æä¾›é”€æ¯æ–¹æ³•ï¼Œç”¨æˆ·å¯èƒ½ä¸çŸ¥é“å¦‚ä½•æ­£ç¡®é‡Šæ”¾
};

void createUI() {
    Widget* btn = WidgetFactory::createButton();
    // ä½¿ç”¨btn...
    delete btn;  // ç”¨æˆ·ä¸ç¡®å®šæ˜¯å¦è¿™æ ·é‡Šæ”¾æ­£ç¡®
}
```

**æ­£ç¡®åšæ³•**ï¼š

```c++
class WidgetFactory {
public:
    static std::unique_ptr<Widget> createButton() {
        return std::make_unique<Button>();
    }
    
    static std::unique_ptr<Widget> createTextbox() {
        return std::make_unique<Textbox>();
    }
};

void createUI() {
    auto btn = WidgetFactory::createButton();
    // ä½¿ç”¨btn.get()...
    // è‡ªåŠ¨ç®¡ç†ç”Ÿå‘½å‘¨æœŸï¼Œæ— éœ€æ‰‹åŠ¨é‡Šæ”¾
}

class WidgetFactory {
public:
    static std::unique_ptr<Widget> createButton() {
        return std::unique_ptr<Widget>(new Button());
    }
    
    static std::unique_ptr<Widget> createTextbox() {
        return std::unique_ptr<Widget>(new Textbox());
    }
};

void createUI() {
    auto btn = WidgetFactory::createButton();
    // ä½¿ç”¨btn.get()...
    // è‡ªåŠ¨ç®¡ç†ç”Ÿå‘½å‘¨æœŸï¼Œæ— éœ€æ‰‹åŠ¨é‡Šæ”¾
}
```

### ğŸ’¡ å°è´´å£«
1.è·¨æ¨¡å—æ¥å£å§‹ç»ˆæ˜ç¡®èµ„æºçš„æ‰€æœ‰æƒå’Œé‡Šæ”¾è´£ä»»

2.ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆç®¡ç†è·¨è¾¹ç•Œèµ„æº

3.åº“çš„APIåº”æä¾›é…å¯¹çš„åˆ†é…/é‡Šæ”¾å‡½æ•°

4.å¯¹ç¬¬ä¸‰æ–¹åº“çš„æ¥å£è¿›è¡ŒRAIIåŒ…è£…

5.ä¿æŒåˆ†é…å’Œé‡Šæ”¾åœ¨åŒä¸€ä¸ªæ¨¡å—ä¸­è¿›è¡Œ

6.è®°å½•å¹¶éµå¾ªæ¯ä¸ªæ¨¡å—å’Œæ¡†æ¶çš„å†…å­˜ç®¡ç†çº¦å®š

## æ€»ç»“ï¼šC++å†…å­˜æ³„æ¼é˜²èŒƒæŒ‡å—

é€šè¿‡æœ¬æ–‡çš„è¯¦ç»†æ¢è®¨ï¼Œæˆ‘ä»¬å·²ç»æ·±å…¥äº†è§£äº†C++ä¸­å¸¸è§çš„å†…å­˜æ³„æ¼åœºæ™¯ã€‚ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥æ€»ç»“ä¸€ä¸‹å…³é”®çš„é˜²èŒƒæªæ–½å’Œæœ€ä½³å®è·µã€‚

### å†…å­˜æ³„æ¼çš„æœ¬è´¨
å†…å­˜æ³„æ¼æœ¬è´¨ä¸Šæ˜¯"ç”³è¯·äº†ä½†æ²¡æœ‰å½’è¿˜"çš„é—®é¢˜ã€‚å°±åƒå€Ÿä¸œè¥¿ä¸è¿˜ï¼Œæ—¶é—´é•¿äº†ï¼Œèµ„æºå°±ä¼šæ¯ç«­ã€‚åœ¨C++ä¸­ï¼Œè¿™ä¸ªé—®é¢˜å°¤ä¸ºçªå‡ºï¼Œå› ä¸ºå®ƒèµ‹äºˆäº†ç¨‹åºå‘˜ç›´æ¥ç®¡ç†å†…å­˜çš„æƒåŠ›ï¼Œä¹Ÿå› æ­¤å¸¦æ¥äº†æ›´å¤§çš„é£é™©ã€‚

### é˜²èŒƒå†…å­˜æ³„æ¼çš„æ ¸å¿ƒç­–ç•¥
#### 1. æ‹¥æŠ±ç°ä»£C++
+ ä¼˜å…ˆä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆï¼ˆ`std::unique_ptr`, `std::shared_ptr`ï¼‰
+ åˆ©ç”¨RAIIæŠ€æœ¯è‡ªåŠ¨ç®¡ç†èµ„æºç”Ÿå‘½å‘¨æœŸ
+ ä½¿ç”¨æ ‡å‡†å®¹å™¨(stringã€vectorç­‰)è€ŒéåŸå§‹æ•°ç»„

#### 2. éµå¾ªåŸºæœ¬åŸåˆ™
+ ç¡®ä¿èµ„æºçš„åˆ†é…å’Œé‡Šæ”¾åœ¨åŒä¸€ä¸ªä½œç”¨åŸŸå†…
+ æ˜ç¡®èµ„æºçš„æ‰€æœ‰æƒï¼ˆè°åˆ†é…ï¼Œè°é‡Šæ”¾ï¼‰
+ å¯¹äºæ¯ä¸ª`new`éƒ½è¦æœ‰å¯¹åº”çš„`delete`
+ å¯¹äºæ¯ä¸ª`new[]`éƒ½è¦æœ‰å¯¹åº”çš„`delete[]`
+ å¯¹äºæ¯ä¸ª`malloc`éƒ½è¦æœ‰å¯¹åº”çš„`free`

#### 3. ç‰¹å®šåœºæ™¯é˜²èŒƒæªæ–½
+ **åŸºç¡€æ“ä½œ**ï¼šå‡å°‘ç›´æ¥ä½¿ç”¨è£¸æŒ‡é’ˆï¼Œä¼˜å…ˆé€‰æ‹©æ™ºèƒ½æŒ‡é’ˆ
+ **æ§åˆ¶æµ**ï¼šæ‰€æœ‰æ‰§è¡Œè·¯å¾„éƒ½è¦è€ƒè™‘èµ„æºé‡Šæ”¾
+ **ç±»å’Œå¯¹è±¡**ï¼šæ­£ç¡®å®ç°ææ„å‡½æ•°ï¼Œéµå¾ªä¸‰/äº”æ³•åˆ™
+ **å®¹å™¨å’Œæ•°æ®ç»“æ„**ï¼šå®¹å™¨å­˜å‚¨æ™ºèƒ½æŒ‡é’ˆï¼Œé€’å½’æ¸…ç†å¤æ‚ç»“æ„
+ **ç³»ç»Ÿèµ„æº**ï¼šä½¿ç”¨RAIIåŒ…è£…å™¨å°è£…ç³»ç»Ÿèµ„æº
+ **å¤šçº¿ç¨‹**ï¼šæ³¨æ„çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸå’Œèµ„æºå…±äº«
+ **ç»„ä»¶é›†æˆ**ï¼šæ˜ç¡®æ¥å£çº¦å®šå’Œèµ„æºé‡Šæ”¾è´£ä»»

### æ£€æµ‹ä¸ä¿®å¤
é¢„é˜²å›ºç„¶é‡è¦ï¼Œä½†æ£€æµ‹ä¹Ÿä¸å¯æˆ–ç¼ºï¼š

1. ä½¿ç”¨å†…å­˜æ³„æ¼æ£€æµ‹å·¥å…·ï¼ˆValgrind, Visual Leak Detectorç­‰ï¼‰
2. å®æ–½ä»£ç å®¡æŸ¥ï¼Œé‡ç‚¹å…³æ³¨èµ„æºç®¡ç†
3. ç¼–å†™å•å…ƒæµ‹è¯•éªŒè¯èµ„æºé‡Šæ”¾
4. æŒç»­ç›‘æ§åº”ç”¨å†…å­˜ä½¿ç”¨æƒ…å†µ

**é¢„å‘Š**ï¼šè¿™äº›æ£€æµ‹æ–¹æ³•å¬èµ·æ¥æœ‰ç‚¹æŠ½è±¡ï¼Ÿåˆ«æ‹…å¿ƒï¼ä¸‹ä¸€ç¯‡æ–‡ç« ã€Šå†…å­˜æ³„æ¼å¦‚ä½•æ£€æµ‹ï¼Ÿä»åŸç†åˆ°å®æˆ˜ã€‹å°†å¸¦ä½ è¯¦ç»†äº†è§£å„ç§å†…å­˜æ³„æ¼æ£€æµ‹å·¥å…·å’ŒæŠ€æœ¯ï¼Œæ‰‹æŠŠæ‰‹æ•™ä½ å¦‚ä½•å‘ç°å¹¶ä¿®å¤æ½œåœ¨çš„å†…å­˜æ³„æ¼é—®é¢˜ã€‚æ•¬è¯·æœŸå¾…ï¼

### ç»ˆæå»ºè®®
è®°ä½è¿™å¥è¯ï¼š"**èµ„æºè·å–å³åˆå§‹åŒ–**"ï¼ˆRAIIï¼‰ã€‚è¿™ä¸ä»…æ˜¯ä¸€ç§æŠ€æœ¯ï¼Œæ›´æ˜¯ä¸€ç§æ€æƒ³ - è®©èµ„æºçš„ç”Ÿå‘½å‘¨æœŸä¸å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸç»‘å®šï¼Œä»è€Œå®ç°è‡ªåŠ¨åŒ–çš„èµ„æºç®¡ç†ã€‚

åœ¨ç°ä»£C++ä¸­ï¼Œç›´æ¥ä½¿ç”¨`new`/`delete`çš„åœºæ™¯è¶Šæ¥è¶Šå°‘ã€‚å¥½çš„C++ä»£ç åº”è¯¥å‡ ä¹çœ‹ä¸åˆ°è¿™äº›å…³é”®å­—ï¼Œè€Œæ˜¯é€šè¿‡æ™ºèƒ½æŒ‡é’ˆå’Œå®¹å™¨æ¥é—´æ¥ç®¡ç†å†…å­˜ã€‚

å°±åƒä¸€ä¸ªæ•´æ´çš„å®¶åº­ä¸éœ€è¦å¤©å¤©æ‰“æ‰«ï¼Œä¸€ä¸ªè®¾è®¡è‰¯å¥½çš„C++ç¨‹åºä¹Ÿä¸éœ€è¦æ—¶åˆ»æ‹…å¿ƒå†…å­˜æ³„æ¼ - å› ä¸ºè‰¯å¥½çš„æ¶æ„å·²ç»ä»æ ¹æœ¬ä¸Šé¢„é˜²äº†è¿™äº›é—®é¢˜ã€‚

### å¯„è¯­

å¸Œæœ›é€šè¿‡æœ¬æ–‡çš„å­¦ä¹ ï¼Œä½ èƒ½å¤Ÿåœ¨C++å†…å­˜ç®¡ç†çš„é“è·¯ä¸Šèµ°å¾—æ›´åŠ ä»å®¹ã€‚å†…å­˜æ³„æ¼å¹¶ä¸å¯æ€•ï¼Œå¯æ€•çš„æ˜¯ä¸äº†è§£å®ƒã€ä¸é‡è§†å®ƒã€‚æŒæ¡äº†è¿™äº›çŸ¥è¯†å’ŒæŠ€å·§ï¼Œä½ å°±èƒ½å†™å‡ºæ›´å¥å£®ã€æ›´é«˜æ•ˆçš„C++ç¨‹åºã€‚

**è®°ä½**ï¼šä¼˜ç§€çš„C++ç¨‹åºå‘˜ä¸æ˜¯èƒ½ä¿®å¤æ‰€æœ‰å†…å­˜æ³„æ¼çš„äººï¼Œè€Œæ˜¯èƒ½ä»è®¾è®¡ä¸Šé¢„é˜²å¤§å¤šæ•°å†…å­˜æ³„æ¼çš„äººï¼

å–œæ¬¢è¿™ç¯‡æ–‡ç« ï¼Ÿæƒ³å­¦ä¹ æ›´å¤šC++ç¼–ç¨‹æŠ€å·§å’Œæœ€ä½³å®è·µï¼Ÿæ¬¢è¿å…³æ³¨æˆ‘çš„å…¬ä¼—å·ï¼šã€Œ**è·Ÿç€å°åº·å­¦ç¼–ç¨‹**ã€ã€‚è¿™é‡Œæœ‰æ›´å¤šæ¥åœ°æ°”çš„ç¼–ç¨‹çŸ¥è¯†ï¼Œæ²¡æœ‰æ™¦æ¶©éš¾æ‡‚çš„æœ¯è¯­ï¼Œåªæœ‰å®ç”¨çš„ç¼–ç¨‹æŠ€å·§å’Œç”ŸåŠ¨çš„æ¡ˆä¾‹åˆ†æï¼

æ¬¢è¿åœ¨è¯„è®ºåŒºåˆ†äº«ä½ çš„C++å†…å­˜ç®¡ç†ç»éªŒå’Œé—®é¢˜ï¼Œæˆ‘ä»¬ä¸€èµ·è¿›æ­¥ï¼

å¦‚æœè§‰å¾—è¿™ç¯‡æ–‡ç« æœ‰å¸®åŠ©ï¼Œæ¬¢è¿ç‚¹ã€Œ**èµ**ã€ğŸ‘ã€ç‚¹ä¸ªã€Œ**åœ¨çœ‹**ã€ğŸ‘€ã€**è½¬å‘**ï¼Œè®©æ›´å¤šäººçœ‹åˆ°ï¼ğŸ‘

#### æ€ä¹ˆå…³æ³¨æˆ‘çš„å…¬ä¼—å·ï¼Ÿ

ç‚¹å‡»ä¸‹æ–¹å…¬ä¼—å·åç‰‡å³å¯å…³æ³¨ã€‚

![](https://files.mdnice.com/user/48364/65158d3c-cd38-4604-861a-8f0379066dc0.png)

å¦å¤–ï¼Œå°åº·è¿˜å»ºäº†ä¸€ä¸ªæŠ€æœ¯äº¤æµç¾¤ï¼Œä¸“é—¨èŠæŠ€æœ¯ã€ç­”ç–‘è§£æƒ‘ã€‚å¦‚æœä½ åœ¨è¯»æ–‡ç« æ—¶ç¢°åˆ°ä¸æ‡‚çš„åœ°æ–¹ï¼Œéšæ—¶æ¬¢è¿æ¥ç¾¤é‡Œæé—®ï¼æˆ‘ä¼šå°½åŠ›å¸®å¤§å®¶è§£ç­”ï¼Œç¾¤é‡Œè¿˜æœ‰ä¸å°‘æŠ€æœ¯å¤§ä½¬åœ¨çº¿æ”¯æ´ï¼Œå’±ä»¬ä¸€èµ·å­¦ä¹ è¿›æ­¥ï¼Œäº’ç›¸æˆé•¿ï¼

![](https://files.mdnice.com/user/48364/971ccaa3-8f57-4e33-8bc9-d0863eeade81.png)
