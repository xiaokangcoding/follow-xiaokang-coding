大家好，我是小康。

#### 前言：

你是不是曾经在 C++ 中遇到过“类型转换”的问题，看到一堆转换函数和符号，搞得一脸懵？放心，今天我就来给你们把这个看似高深的概念讲清楚。无论你是 C++ 新手，还是有点经验的小伙伴，今天这篇文章一定让你轻松掌握 C++ 的类型转换。

我知道，你可能在想：类型转换不就是把一个类型变成另一个类型吗？对，没错，但是这其中有很多小细节需要注意。今天我们就从最基础的内容开始，一步步深入，逐渐学会如何在实际编程中巧妙地使用类型转换。

## 1. 什么是类型转换？
先从最基础的定义开始。

**类型转换**，就是将一种数据类型的值转换成另一种数据类型的值。例如，我们有一个整数 `int` 类型的值 10，想把它转成 `float` 类型，结果就是 10.0。简单吧？

你会发现，在 C++ 中，类型转换有很多种方式，而且有些转换是自动的（也叫隐式转换），有些则需要我们手动做（也叫显式转换）。

## 2. 隐式类型转换
隐式类型转换，顾名思义，就是不需要我们显式地去做转换，C++ 会自动帮我们转换。

举个例子，假设我们有一个整数 `int` 和一个浮点数 `float`，我们想把它们相加，C++ 会自动把 `int` 转成 `float`，然后再做加法。

**来看这个例子**：

```c++
#include <iostream>
using namespace std;

int main() {
    int a = 5;
    float b = 3.2;
    cout << a + b << endl;  // 输出 8.2
    return 0;
}
```

在上面的代码里，`a` 是 `int` 类型，`b` 是 `float` 类型，C++ 自动把 `a` 转换成了 `float`，然后进行加法操作，结果是 8.2。这就是隐式类型转换。

**注意**：隐式转换虽然很方便，但有时也会带来一些意想不到的问题，特别是在数据丢失或者精度丢失的时候。比如把 `float` 转成 `int`，小数部分就会被丢弃。

## 3. 显式类型转换
有时候，C++ 并不会自动做类型转换，或者我们不希望它做自动转换。这时我们就需要手动进行类型转换，叫做显式类型转换。显式转换一般通过下面几种方式来完成：

### (1) C 风格的类型转换
这是最老派的类型转换方式，看起来很简单，但不推荐经常使用，因为它有点不太直观，容易出错。

```c++
#include <iostream>
using namespace std;

int main() {
    double pi = 3.14159;
    int intPi = (int)pi;  // C 风格的类型转换
    cout << intPi << endl;  // 输出 3
    return 0;
}
```

这里，`pi` 是 `double` 类型，我们想把它转成 `int` 类型，用 `(int)` 就能完成类型转换。你会发现，小数部分被丢掉了，结果是 3。

### (2) 函数式类型转换
函数式类型转换跟 C 风格有点像，但它看起来更像一个函数调用。可以理解为更“C++风格”的写法。

```c++
#include <iostream>
using namespace std;

int main() {
    double pi = 3.14159;
    int intPi = int(pi);  // 函数式类型转换
    cout << intPi << endl;  // 输出 3
    return 0;
}
```

这里我们用 `int(pi)` 来把 `double` 类型的 `pi` 转成 `int` 类型。

### (3) C++ 风格的类型转换（推荐）

从 C++ 风格的类型转换开始，类型转换就不再是那么随意了，C++ 提供了更加安全、清晰的转换方式，主要有以下几种：

分别是：`static_cast`、`dynamic_cast`、`const_cast` 和 `reinterpret_cast`。

听起来是不是有点复杂？别担心，它们其实有各自的用途，而且能帮助我们更加精确、更加安全地做类型转换。每种转换都有它的“专属场合”，用得好，能让代码既清晰又不容易出错。接下来，我们就一个一个聊聊，看看它们到底是怎么工作的，什么时候该用哪一个。

#### 1. `static_cast<T>`：最常见、最安全的转换

`static_cast` 是最常用的类型转换。它适用于那些类型之间的关系是清楚的、编译时就能知道转换能否成功的情况。简单来说，就是当你确信两个类型之间可以互相转换时，`static_cast` 就能帮你做这件事。比如把一个 `int` 转成 `float`，或者把基类指针转成派生类指针，这种转换，编译器是可以提前知道的。  

**常见场景**：

1、基本数据类型之间的转换

`static_cast` 可以用来转换不同的基本数据类型。例如，将 `int` 转换成 `float`，或者将 `double` 转换成 `int`。这种转换在编译时就能确定是否能成功，因此很安全。

**示例**：

```c++
#include <iostream>
using namespace std;

int main() {
    int intValue = 42;
    float floatValue = static_cast<float>(intValue);  // int 转 float
    cout << "int 转 float: " << floatValue << endl;

    double doubleValue = 9.87;
    int intFromDouble = static_cast<int>(doubleValue);  // double 转 int
    cout << "double 转 int: " << intFromDouble << endl;

    return 0;
}
```

输出：

```arduino
int 转 float: 42
double 转 int: 9
```

2、类之间的转换：继承关系下的转换

`static_cast` 常用来在有继承关系的类之间进行转换。特别是从派生类到基类（向上转换），或者从基类到派生类（向下转换）。

**向上转换（Upcasting）**：从派生类指针或引用转换到基类指针或引用，通常是自动发生的，无需 `static_cast`，但是如果显式转换也可以使用。

**向下转换（Downcasting）**：从基类指针或引用转换到派生类指针或引用，通常需要显式使用 `static_cast`，但是要确保基类指针确实指向派生类对象，否则会出问题。

**示例**：

```c++
#include <iostream>
using namespace std;

class Animal {
public:
    void speak() { cout << "Animal is speaking" << endl; }
};

class Dog : public Animal {
public:
    void bark() { cout << "Woof!" << endl; }
};

int main() {
    // 向上转换（Upcasting）: 派生类指针转换为基类指针
    Dog* dog = new Dog();
    Animal* animal = static_cast<Animal*>(dog);  // Dog* 转 Animal*
    animal->speak();  // 调用基类的方法

    // 向下转换（Downcasting）: 基类指针转换为派生类指针
    Dog* downcastedDog = static_cast<Dog*>(animal);  // Animal* 转 Dog*
    downcastedDog->bark();  // 调用派生类的方法

    delete dog;
    return 0;
}
```

输出：

```csharp
Animal is speaking
Woof!
```

在这个例子中：

+ **向上转换**：`Dog* dog` 被转换成了 `Animal* animal`，这在编译时是合法的。
+ **向下转换**：然后，`Animal*` 被转换回 `Dog*`，这样就可以调用 `Dog` 类特有的方法 `bark`。

**注意**：如果 `animal` 实际上并不是指向 `Dog` 对象，而是指向其他类型的对象，向下转换会导致未定义行为。确保向下转换的安全性是非常重要的。

3、`void*` 指针的转换

`void*` 是一种通用指针类型，可以指向任何类型的对象。在某些情况下，你需要将 `void*` 转换回具体类型的指针。这时可以使用 `static_cast` 进行转换。

**示例**：

```C++
#include <iostream>
using namespace std;

int main() {
    int num = 10;
    void* ptr = &num;  // void* 指向 int 类型的变量

    // 使用 static_cast 将 void* 转回 int* 类型
    int* intPtr = static_cast<int*>(ptr);
    cout << "通过转换得到的值: " << *intPtr << endl;  // 输出 10

    return 0;
}
```

输出：

```plain
通过转换得到的值: 10
```

在这个示例中，`void*` 指针被转换回了 `int*` 指针，这样就可以访问 `int` 类型的值了。

**小结一下**：

+ `static_cast` 是最常用的类型转换，通常用于编译时能够确定是否安全的转换。
+ 它适用于 基本数据类型之间的转换、类之间的转换（特别是有继承关系时）以及 `void` 指针的转换。
+ 在类的转换中，`static_cast` 可以用于 向上转换 和 向下转换，但要注意 向下转换 时需要确保指针确实指向正确的类型对象，避免出现未定义行为。

#### 2. `dynamic_cast<T>`：多态下的安全转换

`dynamic_cast` 是用来做 **安全类型转换** 的，尤其是在你不确定对象实际是什么类型时，它特别有用。它的最大特点是：只有在 **多态** 的情况下，才能发挥作用。也就是说，你需要有一个虚函数（或者说有继承关系，能通过基类指针调用派生类的方法）来保证这个转换是安全的。

简单来说，`dynamic_cast` 就是你有一个基类指针，想要把它转换成派生类指针。它会帮你检查这个转换到底行不行。如果不行，它会返回 `nullptr`（如果是指针）或者抛出异常（如果是引用）。这样一来，转换失败时你就不会犯傻，代码不会崩溃。

**常见场景**：

1、多态环境下的类型转换：

这场景下，你已经知道基类指针指向的是一个派生类对象，你只想安全地把它转换为派生类指针。`dynamic_cast` 就能确保这种转换不会出错。例如，假设你有一个基类指针，指向 `Dog` 对象，想把它转换成 `Dog*`，`dynamic_cast` 会帮你检查转换是否合法。

```c++
Animal* animal = new Dog();
Dog* dog = dynamic_cast<Dog*>(animal);  // 安全转换
dog->bark();
```

2、确保类型匹配： 

这个场景下，你手里有一个基类指针，但它指向的是 **多个不同派生类对象** 中的某一个。你不确定它指向的是哪种派生类，这时你可以用 `dynamic_cast` 来确认转换是否安全。比如你有一个 `Animal*`，它可能指向 `Dog` 或 `Cat`，你需要确认它是否指向 `Cat`，如果不是，就避免不必要的错误。  

```c++
Animal* animal = getAnimalFromSomewhere();  // 动态获取基类指针，指向不同的派生类对象
Dog* dogPtr = dynamic_cast<Dog*>(animal);   // 你不确定 animal 是指向 Dog 还是其他类型
if (dogPtr) {
    // 转换成功，animal 确实指向 Dog
} else {
    // 转换失败，animal 没有指向 Dog
}
```

假设你有 `Animal` 这个基类，`Dog` 和 `Cat` 是它的派生类：

```c++
class Animal {
public:
    virtual void speak() { cout << "Animal speaks" << endl; }
};

class Dog : public Animal {
public:
    void bark() { cout << "Woof!" << endl; }
};

class Cat : public Animal {
public:
    void meow() { cout << "Meow!" << endl; }
};
```

然后你用 `dynamic_cast` 来进行类型转换：

```c++
Animal* animal = new Dog();  // 基类指针指向派生类对象

// 转换成 Dog*，调用 bark()
Dog* dog = dynamic_cast<Dog*>(animal);
dog->bark();  

// 尝试转换成 Cat*，失败了，返回 nullptr
Cat* cat = dynamic_cast<Cat*>(animal);
if (cat) {
    cat->meow();
} else {
    cout << "转换失败，animal 不是 Cat 类型！" << endl;  // 输出：转换失败，animal 不是 Cat 类型！
}
```

输出：

```plain
Woof!
转换失败，animal 不是 Cat 类型！
```

**发生了什么？**：

+ 成功的转换：`animal` 实际上指向的是 `Dog` 对象，所以 `dynamic_cast` 成功地把 `Animal*` 转换成了 `Dog*`，然后我们能调用 `Dog` 类的方法 `bark()`。
+ 失败的转换：当我们尝试把 `animal` 转换成 `Cat*` 时，`dynamic_cast` 检查发现 `animal` 并不是 `Cat` 类型的对象，结果返回了 `nullptr`，因此没有调用 `Cat` 类的 `meow()` 方法。

**小结一下**：

+ 多态下的类型转换：`dynamic_cast` 很适合用在你已经知道基类指针指向的是哪个派生类的情况下，帮你安全地进行类型转换。
+ 确保类型匹配：当你不确定基类指针指向的是哪个派生类时，`dynamic_cast` 可以帮助你确认转换是否安全。如果转换失败，它会返回 `nullptr`（指针）或者抛出异常（引用），从而避免错误的发生。


#### 3. `const_cast<T>`：移除或添加常量限制

`const_cast` 是用来 改变常量性 的类型转换。简单来说，它能让你 **去掉常量限制**，或者 **给非常量加上常量限制**。是不是有点神秘？其实它就是一个“特权通行证”，让你可以绕过常规的常量检查。

**常见场景**：

1、移除 `const` 限制（危险地修改常量）：

比如你有一个 `const` 指针，指向一个 `const` 对象，按照常理，你不能修改这个对象。但如果你真的想修改它，`const_cast` 就能绕过这个限制。**记住，这种做法风险很大**，最好确保你知道自己在做什么，否则可能会导致程序崩溃。

```c++
#include <iostream>
using namespace std;

void modifyValue(const int* ptr) {
    // 使用 const_cast 去掉 const 限制，修改值
    int* modifiablePtr = const_cast<int*>(ptr);  
    *modifiablePtr = 20;  // 修改值
    cout << "修改后的值: " << *modifiablePtr << endl;
}

int main() {
    const int value = 10;  // 常量
    cout << "修改前: " << value << endl;
    modifyValue(&value);  // 试图修改常量
    cout << "修改后: " << value << endl;  // 结果可能是错误的
    return 0;
}
```

**注意！** 这个例子里我们用了 `const_cast` 去掉了 `const` 限制，但修改 `const` 对象的值是有风险的。现代编译器可能会优化 `const` 数据，让你修改的数据没有实际效果。

输出（不同编译器可能会有不同的结果）：

```bash
修改前: 10
修改后的值: 20
修改后: 10
```

在这段代码中，`modifyValue` 函数里，`const_cast` 让我们绕过了 `const` 限制，修改了指针指向的值。虽然我们在函数内修改了值，但是 main 中的 `value` 值并没有发生改变，编译器可能对 `const` 变量做了优化，导致它保持不变。

2、添加 `const` 限制（保护对象不被修改）：

这种情况就比较安全了，你可以用 `const_cast` 强制将一个非 `const` 对象变成 `const`。比如，有一个函数需要一个 `const` 指针，你可以用 `const_cast` 来“保护”它，避免它被修改。

```c++
#include <iostream>
using namespace std;

void printValue(const int* ptr) {
    cout << "Value is: " << *ptr << endl;
    // *ptr = 10;  // 这行会报错，因为 ptr 是 const 指针
}

int main() {
    int value = 30;
    // 添加 const 限制
    const int* constPtr = const_cast<const int*>(&value);
    printValue(constPtr);  // 确保不会修改 value

    return 0;
}
```

在这个例子里，我们用 `const_cast<const int*>` 强制把一个 `int*` 转换成 `const int*`，然后传给 `printValue` 函数。这确保了在 `printValue` 函数内，`value` 的值不会被意外修改。

**小结一下**：

+ `const_cast` 主要用来改变对象的常量性，既可以移除 `const` 限制，也可以给对象加上 `const` 限制。
+ 移除 `const` 限制：可以让你修改原本不可修改的 `const` 对象，但要小心这样做可能导致不可预测的行为，特别是在优化和常量数据方面。
+ 添加 `const` 限制：通过强制将非 `const` 对象变成 `const`，可以保证对象在某些场合下不会被修改，避免意外错误。

**需要注意的**：

+ 使用 `const_cast` 去修改 `const` 对象非常危险，除非你非常清楚自己在做什么。
+ 通常建议尽量避免使用 `const_cast`，除非你确实有很强的理由去移除或者添加常量限制。

#### 4. `reinterpret_cast<T>`：最强大、最危险的转换

`reinterpret_cast` 是 C++ 中最强大也是最危险的类型转换。它可以把任何类型强行转成其他类型，几乎没有任何限制。你想把一个 `int` 转换成 `char*`？没问题；你想把一个指针转换成一个整数？也行；甚至你想把一个指针转换成完全不相干的类型，这都可以！总之，`reinterpret_cast` 基本上是告诉编译器：“我不管你怎么想，我就是要这么做！”

**不过，注意了！它是最强大的同时也是最危险的类型转换**，因为绕过了编译器的安全检查，直接在内存层面操作，搞不好会让程序崩溃，所以得小心使用。

**常见场景**：

1、指针之间的转换： 有时候你需要把一个指针转换成另一种类型的指针，虽然它们本质上没啥关系，但你还是可以通过 `reinterpret_cast` 做到。比如把 `int*` 转成 `void*`，或者把函数指针转换成另一种完全不同类型的函数指针。

2、指针转换为整数： 在一些底层的编程中，我们可能需要将一个指针转换成一个整数（通常是内存地址）。这样就能把地址存储在整数里，方便在后续代码中使用。

3、整数转换为指针： 假如你有一个内存地址（用整数表示），有时候你需要把它重新转换成指针来访问那个位置的数据。这种情况经常发生在底层编程或硬件操作时。

**示例**：

1.指针类型转换：

```c++
#include <iostream>
using namespace std;

int main() {
    int x = 42;
    void* ptr = &x;  // 把 int 指针转成 void 指针

    // 使用 reinterpret_cast 把 void 指针转回 int 指针
    int* intPtr = reinterpret_cast<int*>(ptr);
    cout << "通过 reinterpret_cast 读取的值: " << *intPtr << endl;

    return 0;
}
```

在这个例子里，我们先把一个 `int*` 转成 `void*`，然后再用 `reinterpret_cast` 强行转回 `int*`，这样就能继续操作这个数据。这样做其实挺常见的，但要注意，不是所有指针之间都能随便转换，特别是不同数据类型的指针之间。

2.指针转整数：

```c++
#include <iostream>
using namespace std;

int main() {
    int x = 100;
    int* ptr = &x;

    // 用 reinterpret_cast 把指针转换成整数
    uintptr_t ptrAsInt = reinterpret_cast<uintptr_t>(ptr);
    cout << "指针转成整数: " << ptrAsInt << endl;

    // 再把整数转换回指针
    int* ptrBack = reinterpret_cast<int*>(ptrAsInt);
    cout << "转换回指针的值: " << *ptrBack << endl;

    return 0;
}
```

这段代码展示了怎么把指针转换成整数（这其实就是内存地址）。如果你有内存地址的整数表示，`reinterpret_cast` 可以让你把它转换回指针，继续访问那块内存。

3.整数转指针：

```c++
#include <iostream>
using namespace std;

int main() {
    uintptr_t address = 0x7ffeee40f380;  // 假设这是一个有效的地址

    // 用 reinterpret_cast 把整数转换回指针
    int* ptr = reinterpret_cast<int*>(address);
    cout << "通过地址读取的值: " << *ptr << endl;

    return 0;
}
```

这个例子展示了如何把一个整数（假设它是一个内存地址）转换成指针。虽然在很多情况下你不需要这么做，但如果你在做底层系统编程或者跟硬件打交道时，可能会遇到这种需求。

**小结一下**：

+ `reinterpret_cast` 可以让你做一些非常规的类型转换，包括指针类型之间的转换，或者将指针和整数相互转换。
+ 指针转换：你可以把指针从一种类型转换到完全不同的类型，比如从 `int*` 转换成 `char*`，甚至转换到函数指针类型。
+ 指针与整数转换：你还可以将指针转换成整数（比如内存地址），或者将一个整数转换回指针，再去操作那块内存。

#### 小结一下：

现在你应该对 C++ 中的四种类型转换有了更清晰的认识，记住它们的特点和应用场景：  

+ `static_cast`：最常用，安全，编译器可以检测类型是否匹配。适用于基本类型和类类型之间的转换。
+ `dynamic_cast`：主要用于类之间的指针或引用转换，通常用在继承体系中。
+ `const_cast`：用来修改常量性，允许修改常量对象。
+ `reinterpret_cast`：最强大也最危险，用来进行底层的指针运算和转换。

掌握这四种类型转换后，你就能在 C++ 编程中游刃有余，不再被类型转换搞得一头雾水了。

## 总结：

总结一下：类型转换就是让不同类型的数据能够互相转换，方便我们在程序中处理各种数据。首先，有时候编译器会自动帮我们做类型转换，这叫 **隐式类型转换**，比如从 `int` 转到 `float`，它会自己做，但我们得注意不要丢失精度。

然后，我们也可以手动进行 **显式类型转换**，比如用 **C 风格**`(int)value` 或 **函数式**`int(value)` 转换类型，虽然这些方式比较直接，但不够安全。

为了更精确和安全地转换，C++ 提供了更推荐的 **C++ 风格类型转换**，包括：`static_cast`（最常见、最安全的转换）、`dynamic_cast`（在有继承关系时保证安全转换）、`const_cast`（用来添加或移除常量限制）和 `reinterpret_cast`（最强大但也最危险的转换）。

总的来说，选择合适的转换方式能让我们的代码更加健壮和易于维护，但也要小心避免不必要的错误。  

### 最后:

觉得有收获的话，记得点个「赞」👍 点个「在看」👀，顺便分享给你的小伙伴们，一起学编程！😉

如果你还想继续挖掘更多编程技巧，快来关注我的公众号「跟着小康学编程」，这里有一堆干货等着你！有问题或者想聊的，评论区见！技术的路上，我们一起走，大家一起进步，绝对不孤单！💪

#### 怎么关注我的公众号？

点击下方公众号名片即可关注。

![](https://files.mdnice.com/user/48364/65158d3c-cd38-4604-861a-8f0379066dc0.png)

另外，小康还建了一个技术交流群，专门聊技术、答疑解惑。如果你在读文章时碰到不懂的地方，随时欢迎来群里提问！我会尽力帮大家解答，群里还有不少技术大佬在线支援，咱们一起学习进步，互相成长！

![](https://files.mdnice.com/user/48364/971ccaa3-8f57-4e33-8bc9-d0863eeade81.png)