大家好，我是小康。

>你踩过这个坑吗？为什么我的程序明明很简单，却总是莫名其妙地崩溃！

嘿，各位 C++ 爱好者们，今天咱们聊一个几乎所有 C++ 程序员都会踩的坑——迭代器失效。无论你是刚入门的新手，还是写了好几年代码的老司机，这个问题都可能让你的程序莫名其妙地崩溃。不过别担心，读完这篇文章，你一定会恍然大悟："哦！原来是这么回事！"

## 迭代器到底是个啥？
先别急着谈"失效"，咱们得先弄明白迭代器是啥玩意儿。

想象一下，迭代器就像是一个"指针"，指向容器（比如vector、list）中的某个元素。通过迭代器，我们可以访问、修改容器中的元素，还能在容器中移动（前进或后退）。

简单来说，迭代器就是容器和算法之间的桥梁，让你能够不关心容器内部结构，就能轻松遍历和操作容器中的元素。

```cpp
vector<int> nums = {1, 2, 3, 4, 5};
// it就是一个迭代器，指向vector的第一个元素
auto it = nums.begin(); 
cout << *it << endl; // 输出1
```

> 💡 学习建议：
>
>多动手实验：亲自运行几段“迭代器失效”的代码，看程序是怎么崩的，印象更深。
>
>对比不同容器行为：同样的操作在 vector、list、map 中可能完全不同。
>
>理解背后的原理：为什么插入或删除会让迭代器失效？理解这点比死记规则更重要。
>
>养成安全习惯：修改容器时尽量用返回的有效迭代器，或者使用安全的遍历方式（例如 erase(it++) 这种写法）。
>
>想系统学习更多 C++ 知识？欢迎关注我的公众号「**跟着小康编程**」，我会持续更新 C、 C++、Linux、后端开发等高质量技术文章。也可以加我的个人微信，一起进群讨论学习！
>
> 
> <table>
> <tr>
> <td align="center">
> <img src="https://github.com/xiaokangcoding/follow-xiaokang-coding/raw/main/images/qrcode-wechat-official.png" width="200">
> <br>
> <em>公众号「跟着学小康编程」</em>
> </td>
> <td align="center">
> <img src="https://github.com/xiaokangcoding/follow-xiaokang-coding/raw/main/images/qrcode-personal-wechat.png" width="200">
> <br>
> <em>个人微信（备注：加群）</em>
> </td>
> </tr>
> </table>

## 什么是迭代器失效？
现在到了关键问题：什么是迭代器失效？

简单讲，**当你对容器进行了某些操作后，原先有效的迭代器变得无效了，再使用这个迭代器就会导致未定义行为（通常是程序崩溃）**，这就是迭代器失效。

就好比你拿着一把钥匙（迭代器）去开一个门（访问容器元素），但有人趁你不注意把锁换了（容器结构改变），你的钥匙自然就不管用了。

## 常见的迭代器失效场景
### 1. vector中的迭代器失效
vector 是最常用的 STL 容器，也是迭代器失效最容易发生的地方。

#### 场景一：添加元素(push_back)导致的失效
```cpp
vector<int> nums = {1, 2, 3};
auto it = nums.begin(); // it指向1
nums.push_back(4);      // 可能导致迭代器失效
cout << *it << endl;    // 危险操作！可能崩溃
```

为啥会失效？因为 vector 在内存中是连续存储的，当空间不够时，会重新分配一块更大的内存，并把原来的元素复制过去。这时候，原来的内存地址就变了，之前的迭代器自然就失效了。

就像你正在看一本书，突然有人把这本书拿走换了一本新的放在原处——你手指的位置自然就不对了。

#### 场景二：insert 操作导致的失效

说到 vector 添加元素，咱们可不能忘了另一个常用的操作——insert！这家伙比 push_back 还要狡猾呢！

```c++
vector<int> nums = {1, 2, 3, 4, 5};
auto it = nums.begin() + 2; // it指向元素3
nums.insert(nums.begin(), 0); // 在最前面插入0
cout << *it << endl; // 危险操作！it已经失效了
```

为啥 insert 更容易让人踩坑？因为 insert 有双重杀伤力：

首先，和 push_back 一样，如果 vector 容量不够，insert会导致重新分配内存，所有迭代器就全军覆没了。

其次，即使没有重新分配内存，insert也会让插入位置及其后面的所有元素向后挪位置，这会使这些位置的迭代器全部"串位"。

打个比方，就像你排队时，突然有人插队到你前面，你和你后面的人都被迫向后移了一位——原来记录的位置信息就全乱套了！

记住这个简单规则：

+ 如果 insert 导致扩容：所有迭代器都 GG
+ 如果 insert 不导致扩容：插入位置及其后面的迭代器都 GG

#### 场景三：删除元素导致的失效
```cpp
vector<int> nums = {1, 2, 3, 4, 5};
for (auto it = nums.begin(); it != nums.end(); ++it) {
    if (*it == 3) {
        nums.erase(it); // 迭代器失效
        cout << *it << endl;    // 不要继续使用it，危险操作！可能崩溃 
    }
}
```

问题在哪？当你删除了一个元素后，该位置后面的所有元素都会前移，原来的迭代器就指向了一个错误的位置。

### 2. list中的迭代器失效
list 是双向链表，它的迭代器失效情况比 vector 要简单些。

```cpp
list<int> myList = {1, 2, 3, 4, 5};
auto it = myList.begin();
++it; // it指向2
myList.erase(it); // 删除2，it失效
// 不能再使用it 
```

对于 list，只有被删除节点的迭代器会失效，其他节点的迭代器仍然有效。这是因为 list 是链表结构，删除一个节点不会影响其他节点的内存位置。

### 3. map/set中的迭代器失效
map 和 set 是基于红黑树实现的，它们的迭代器失效规则和 list 类似。

```cpp
map<int, string> myMap = {{1, "one"}, {2, "two"}, {3, "three"}};
auto it = myMap.begin();
myMap.erase(it); // it失效
// 不能再使用it
```

同样，只有被删除元素的迭代器会失效，其他元素的迭代器仍然有效。

## 如何避免迭代器失效的坑？
知道了问题所在，我们该如何避免呢？这里有几个实用技巧：

### 技巧一：使用 erase 和 insert 的返回值

大多数容器的 erase 方法都会返回下一个有效迭代器，insert会返回指向新插入元素的迭代器，我们可以利用这一点。

```c++
// erase的返回值
vector<int> nums = {1, 2, 3, 4, 5};
for (auto it = nums.begin(); it != nums.end(); ) {
    if (*it == 3) {
        it = nums.erase(it); // erase返回下一个有效迭代器
    } else {
        ++it;
    }
}

// insert的返回值
vector<int> nums2 = {1, 2, 3, 4};
auto it2 = nums2.begin();
it2 = nums2.insert(it2 + 2, 100); // it2现在指向新插入的100
cout << *it2 << endl; // 输出100
```

这个技巧在需要连续操作容器时特别有用，可以保持迭代器始终有效。

### 技巧二：先记录再删除
```cpp
vector<int> nums = {1, 2, 3, 4, 5};
vector<int> toRemove;

// 先标记要删除的元素
for (int i = 0; i < nums.size(); ++i) {
    if (nums[i] == 3) {
        toRemove.push_back(i);
    }
}

// 从后往前删除（避免索引变化）
for (int i = toRemove.size() - 1; i >= 0; --i) {
    nums.erase(nums.begin() + toRemove[i]);
}
```

### 技巧三：使用稳定的容器操作
一些容器操作不会导致迭代器失效，可以优先使用这些操作。

```cpp
// 对于list，splice操作不会导致迭代器失效
list<int> myList = {1, 2, 3, 4, 5};
list<int> anotherList = {10, 20};
auto it = myList.begin();
++it; // it指向2
myList.splice(myList.end(), anotherList); // 不会导致it失效
cout << *it << endl; // 仍然是2
```

## 实战案例：解决常见迭代器失效问题
### 案例一：删除 vector 中的偶数
错误写法：

```cpp
vector<int> nums = {1, 2, 3, 4, 5, 6};
for (auto it = nums.begin(); it != nums.end(); ++it) {
    if (*it % 2 == 0) {
        nums.erase(it); // 错误！迭代器失效
    }
}
```

正确写法：

```cpp
vector<int> nums = {1, 2, 3, 4, 5, 6};
for (auto it = nums.begin(); it != nums.end(); ) {
    if (*it % 2 == 0) {
        it = nums.erase(it);
    } else {
        ++it;
    }
}
```

### 案例二：在遍历的同时添加元素
错误写法：

```cpp
vector<int> nums = {1, 2, 3};
for (auto it = nums.begin(); it != nums.end(); ++it) {
    if (*it == 2) {
        nums.push_back(4); // 错误！可能导致迭代器失效
    }
}
```

正确写法(使用下标)：

```cpp
vector<int> nums = {1, 2, 3};
int size = nums.size(); // 先记录原始大小
for (int i = 0; i < size; ++i) {
    if (nums[i] == 2) {
        nums.push_back(4); // 使用索引而非迭代器
    }
}
```

## 总结
迭代器失效看起来很复杂，但只要记住几个简单的规则，就能轻松避开这个坑：

1. **vector**: 插入或删除元素后，该位置及其后面的迭代器都会失效；如果重新分配内存，所有迭代器都会失效。
2. **list/forward_list**: 只有被删除元素的迭代器会失效。
3. **map/set/multimap/multiset**: 只有被删除元素的迭代器会失效。
4. **unordered_map/unordered_set**: 插入操作可能导致所有迭代器失效（rehash）；删除操作只会导致被删除元素的迭代器失效。

实际编程中，优先考虑使用现代 C++ 的算法和容器操作，比如`remove_if`和`erase`的组合，往往能更优雅地解决问题：

```cpp
vector<int> nums = {1, 2, 3, 4, 5, 6};
// 一行代码删除所有偶数
nums.erase(remove_if(nums.begin(), nums.end(), 
    [](int x) { return x % 2 == 0; }),
    nums.end());
```

怎么样，迭代器失效这个坑，你现在是不是已经有底了？下次写代码的时候，别忘了提醒自己：容器变了，迭代器可能就不靠谱了！

---

## 踩坑不止于此，一起深度探索 C++！
看完了这篇文章，是不是感觉对迭代器失效有了全新的认识？其实 C++ 的坑远不止这一个，每一个坑背后都有精彩的技术原理和解决方案。

想要避开更多 C++ 开发中的隐藏陷阱，掌握那些让代码更高效、更优雅的技巧吗？欢迎关注我的公众号「**跟着小康学编程**」！

在这里，我会用同样接地气的语言，继续为你解锁：

+ 那些让面试官眼前一亮的 C/C++ 核心知识
+ 大厂实战中总结的性能优化秘诀
+ 计算机基础知识的趣味解读
+ 以及更多像"迭代器失效"这样的实战踩坑指南

学习编程就像破解谜题，每掌握一个知识点，都是打开新世界的一把钥匙。我希望能和你一起，把复杂的问题变简单，把枯燥的技术变有趣！

如果这篇文章对你有帮助，欢迎 **点赞、在看、转发**，也欢迎在评论区分享你踩过的 C++ 坑！

下期见！👨‍💻

## 🚀 跟我学，你能收获啥？

在这里，你不仅能看到干货，还能真正学到能用的技能：

+ **Linux 实战技巧**：服务器调优、常用命令、Shell 脚本，让你像高手一样操作系统。
+ **C/C++ 后台开发**：从基础语法到高性能编程，带你写出稳、快、可维护的服务端代码。
+ **C/C++ 项目实战**：真实项目案例，教你从需求到上线完整流程，掌握开发套路和最佳实践。
+ **常用开发工具**：调试、版本控制、构建工具、性能分析工具，让开发效率大幅提升。
+ **性能优化**：CPU/内存/IO 调优技巧，定位瓶颈，让你的程序跑得更快更稳。
+ **项目架构设计**：微服务、分层架构、模块设计思路，帮你构建可扩展、易维护的系统。
+ **Go 后端开发**：微服务、云原生实战，教你用 Go 搭建高并发、高可用系统。
+ **编程面试干货 & 算法**：核心算法套路、面试高频题解析，让你不再手忙脚乱。
+ **计算机基础梳理**：操作系统、网络、数据结构、并发原理，知识体系清晰明了。
+ **成长路线图**：系统规划你的学习路径，从初学到高级，帮你少走弯路。

内容**深入浅出、实用有趣**，再也不用看书看到睡着。  
无论是面试冲刺，还是技能升级，这里都是你的“技术加油站”。


## 👀 想加入？很简单！
**扫一扫下面二维码**，一键关注公众号，开启你的技术学习之旅！

![](https://files.mdnice.com/user/71186/0dde803d-d52f-4ed8-b74b-b7f3da5817b9.png)

另外，我还建了一个**技术交流群**，里面都是认真写代码的小伙伴，不吹牛、不闲聊，只聊技术。  
有问题？大家一块儿讨论，比一个人闷头学效率高多了！

![](https://files.mdnice.com/user/48364/4ebc72e9-e4bb-447a-9a92-8367a178df6d.png)

技术这条路，一个人走容易迷路，一群人走才有方向。  
跟上节奏，我们一起变强 💪
