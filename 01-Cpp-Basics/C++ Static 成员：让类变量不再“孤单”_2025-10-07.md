大家好，我是小康。今天我们接着聊聊 static 在类中的应用。

### 前言

如果说 static 变量让函数“记住”上一次的状态，那么 static 成员变量就像是整个类的“共享记忆”。这次，我们将从类的角度来聊聊 static 成员变量和函数，帮你彻底搞懂它们是什么，怎么用。

=========

大家好，我是小康 👋  
今天我们接着聊聊 `**static**`** 在类中的应用**。

### 前言

如果说 `static` 变量让函数能“记住”上一次的状态，  
那么 `**static**`** 成员变量** 就像是整个类的“共享记忆”。

每个对象都有自己的成员变量，但类的 `static` 成员只有一份——  
所有对象都共用它，就像一个“公共储物柜”，谁都能打开、谁都能修改。

这次，我们就从类的角度出发，  
带你彻底搞懂：

+ `static` 成员变量和普通成员有啥区别？
+ `static` 成员函数为啥不能访问非静态成员？
+ 它们在实际开发中又有哪些妙用？


> 💡 学习建议：
>
>多写例子：定义几个对象观察它们对同一个 static 变量的修改效果；
>
>理解作用域与存储周期：想清楚为什么静态成员不属于对象，而属于类；
>
>注意访问方式：ClassName::member 与对象访问的区别是关键细节；
>
>结合静态函数一起练习：理解它们的配合使用场景，比如计数器、对象池等。
>
>想系统学习更多 C++ 知识？欢迎关注我的公众号「**跟着小康编程**」，我会持续更新 C、 C++、Linux、后端开发等高质量技术文章。也可以加我的个人微信，一起进群讨论学习！
>
> 
> <table>
> <tr>
> <td align="center">
> <img src="https://github.com/xiaokangcoding/follow-xiaokang-coding/raw/main/images/qrcode-wechat-official.png" width="200">
> <br>
> <em>公众号「跟着学小康编程」</em>
> </td>
> <td align="center">
> <img src="https://github.com/xiaokangcoding/follow-xiaokang-coding/raw/main/images/qrcode-personal-wechat.png" width="200">
> <br>
> <em>个人微信（备注：加群）</em>
> </td>
> </tr>
> </table>

### 什么是 static 成员变量？

在 C++ 中，类的成员变量通常是属于某个具体对象的，每个对象都会有一份独立的成员变量。而 **static 成员变量** 可不一样，它是所有对象共享的一个变量。

#### 举个例子：
假设我们有一个类 `Car`，它有一个成员变量 `carCount` 用来统计车的数量。

如果每个 `Car` 对象都单独存储这个数量，那就没什么意义了。因为 `carCount` 应该是所有 `Car` 对象共享的，而不是每个对象都自有一份。这个时候，就可以用 **static** 来声明 `carCount`。

```c++
#include <iostream>
using namespace std;

class Car {
public:
    static int carCount;  // 声明静态成员变量

    Car() {
        carCount++;
    }
};

// 静态成员变量需要在类外定义
int Car::carCount = 0;

int main() {
    Car car1;
    Car car2;

    cout << "Number of cars: " << Car::carCount << endl;  // 输出：2
    return 0;
}
```

在这个例子中，`carCount` 变量是静态的，所有 `Car` 对象共享同一个 `carCount`，所以无论创建多少个 `Car` 对象，它都会累加。

### 如何访问 static 成员？

静态成员的访问和普通成员稍微有些不同。普通成员变量需要通过对象来访问，而静态成员变量可以通过 **类名::** 来直接访问，甚至不需要创建对象。

#### 访问静态成员：
```c++
class Car {
public:
    static int carCount;  // 静态成员变量

    Car() {
        carCount++;
    }
};

// 在类外定义静态成员
int Car::carCount = 0;

int main() {
    // 直接通过类名访问静态成员
    cout << "Initial car count: " << Car::carCount << endl;  // 输出：0

    Car car1;
    cout << "After one car: " << Car::carCount << endl;  // 输出：1
    Car car2;
    cout << "After two cars: " << Car::carCount << endl;  // 输出：2

    return 0;
}
```

你可以看到，静态成员 `carCount` 通过 `Car::carCount` 来访问，不需要创建 `Car` 对象。这样就避免了不必要的内存浪费。

### 静态成员函数

#### 什么是静态成员函数？

**静态成员函数** 是属于类的，而不是某个对象的。也就是说，你可以通过类名来调用它，而不需要先创建对象。这一点与普通的成员函数不同，普通成员函数是通过对象来调用的。

#### 它有什么特点？

**1、类级别的函数**：静态成员函数属于类级别，不依赖于任何对象。你不需要创建类的实例，就能通过类名直接调用。

**2、只能访问静态成员**：静态成员函数只能访问类中的静态成员变量和其他静态成员函数，因为它没有绑定到任何具体的对象，也就无法访问属于对象的非静态成员。

**3、没有 `this` 指针**：普通成员函数有一个隐含的 `this` 指针，指向调用该函数的对象，而静态成员函数没有 `this` 指针。

#### 与普通成员函数的区别是什么？

- **普通成员函数**：普通成员函数是与对象关联的，它可以访问类的静态和非静态成员。访问非静态成员时，它依赖于对象的 `this` 指针。
- **静态成员函数**：静态成员函数没有 `this` 指针，它不能直接访问非静态成员，只能访问静态成员。

#### 举个例子：
```c++
#include <iostream>
using namespace std;

class Car {
public:
    static int carCount;  // 静态成员变量

    Car() {
        carCount++;
    }

    // 静态成员函数
    static void printCarCount() {
        cout << "Number of cars: " << carCount << endl;
    }
};

// 静态成员变量需要在类外定义
int Car::carCount = 0;

int main() {
    Car car1;
    Car car2;

    // 通过类名调用静态成员函数
    Car::printCarCount();  // 输出：2
    return 0;
}
```

在上面的代码中，`printCarCount()` 是一个静态成员函数，它只能访问静态成员变量 `carCount`，不能直接访问非静态成员变量。如果尝试访问非静态成员，编译器会报错。

#### 静态成员函数不能访问非静态成员：
```c++
class Car {
public:
    int speed;  // 非静态成员变量
    static int carCount;  // 静态成员变量

    static void printSpeed() {
        // 编译错误：静态成员函数无法访问非静态成员变量
        cout << "Speed: " << speed << endl;
    }
};
```

**那为什么静态成员函数不能访问非静态成员？**

这个问题其实很好理解，关键在于静态成员函数的“身份”问题。

 **1、静态成员函数属于类，而不是对象**：静态成员函数是在类层面上定义的，它没有绑定到具体的对象。所以，当你调用静态成员函数时，它是通过类名来调用的，不依赖于任何特定的对象。
 
 **2、非静态成员属于对象**：而非静态成员变量和普通成员函数是属于具体对象的。当你创建一个对象时，非静态成员才会存在，并且只有通过这个对象才能访问这些成员。

静态成员函数无法访问非静态成员的原因就是，它不属于任何特定的对象，所以无法知道该访问哪个对象的非静态成员。换句话说，静态成员函数没有“this”指针，它无法指向具体的对象，也就不能访问属于某个对象的成员。

**举个例子来说明**：

还是上面 `Car` 类的例子，`speed` 是一个非静态成员变量，而 `carCount` 是一个静态成员变量。

+ 当你调用静态成员函数 `printSpeed()` 时，它是通过类名来调用的。这个函数没有“this”指针，无法知道是哪个 `Car` 对象的 `speed` 变量。
+ 但是，静态成员函数可以访问类中的静态成员 `carCount`，因为静态成员是属于类的，不依赖于具体的对象。

所以，静态成员函数只能访问静态成员变量和其他静态函数，无法访问非静态成员。

#### 小结：
静态成员函数和对象没关系，它不属于某个具体对象，所以它不能直接操作对象的非静态成员变量。

### static 成员的应用场景：
了解了静态成员变量和静态成员函数的基本概念，接下来我们来聊聊它们的实际应用场景。虽然在很多情况下，我们的类对象都有自己独立的成员变量和成员函数，但在某些特定场景下，静态成员就能派上大用场。

#### 1. 全局共享数据
假设我们有一个程序需要统计不同用户的访问次数，而这个次数应该对所有用户共享，而不是每个用户都有一份。这时，静态成员变量就能帮助我们做到这一点。

例如，我们可以在用户类中创建一个静态的访问计数器，所有用户对象共享这个计数器，这样每当有用户访问时，计数器就会增加，而不需要每个对象都单独保存一份。

```c++
class User {
public:
    static int visitCount;  // 所有用户共享

    User() {
        visitCount++;
    }
};

// 在类外定义静态变量
int User::visitCount = 0;

int main() {
    User user1;
    User user2;
    cout << "Total visits: " << User::visitCount << endl;  // 输出：2
    return 0;
}
```

在这个例子中，不管你创建多少个 `User` 对象，它们都会共享同一个 `visitCount`，这样就避免了每个用户对象都存储计数的重复工作。

#### 2. 工厂模式中的静态成员

有些时候，类中的静态成员函数可以帮助你创建对象。工厂模式就是一个常见的例子，它允许你通过静态成员函数来创建类的实例，而不需要在外部直接调用构造函数。

```c++
class Product {
public:
    static Product* createProduct() {
        return new Product();
    }
};

int main() {
    Product* product = Product::createProduct();
    // 使用 product
    delete product;
    return 0;
}
```

在这里，`createProduct` 是一个静态成员函数，用来创建 `Product` 对象。这种做法能够封装对象创建的细节，提供更灵活的控制。

#### 3. 配置类中的静态成员

在很多程序中，我们可能会有一个配置类，用来保存一些全局的配置数据（如程序的设置、资源路径、日志级别等）。这些配置信息往往是固定的，不会因为对象的创建而变化。此时，静态成员变量非常适合用来保存这些共享的数据。

例如，一个全局的日志配置类可以用静态成员来记录当前的日志级别：

```C++
class Logger {
public:
    static int logLevel;

    static void log(const string& message) {
        if (logLevel >= 2) {
            cout << "Log: " << message << endl;
        }
    }
};

// 在类外定义静态变量
int Logger::logLevel = 2;

int main() {
    Logger::log("Program started");
    Logger::logLevel = 1;
    Logger::log("Another log");
    return 0;
}
```

在这个例子中，`logLevel` 是一个静态成员，所有日志都根据这个静态设置来决定是否输出。

### 总结：

静态成员变量和静态成员函数让我们在 C++ 中能更方便地管理共享数据和功能。它的一个关键特点是：**它们属于整个类，而不是某个具体的对象**。所以，多个对象之间能共享同一份数据，避免了每个对象都要独占一份的情况。这不仅节省内存，也让代码更加简洁高效。

今天我们了解了静态成员变量和静态成员函数的基本用法，知道了如何共享数据、访问静态成员，还明白了为什么静态成员函数不能访问非静态的成员。

如果觉得这篇文章还不错，别忘了点个「赞」、点个「在看」，或分享给更多对 C++ 编程感兴趣的小伙伴！也欢迎大家关注我的公众号「跟着小康学编程」。

下篇文章，我们会继续聊聊 **C++ 中 static 如何应用到多线程，保证线程安全**。这样，你就能在写多线程代码时更得心应手了！

## 🚀 跟我学，你能收获啥？
在这里，你可以学到：

+ Linux、C/C++、Go 的实战技巧
+ 计算机基础知识梳理
+ 编程面试干货、算法套路和优化思路

内容**深入浅出、实用有趣**，不再让你看着书就犯困。  
无论是面试冲刺，还是想升级技能，这里都是你的“技术加油站”。


## 👀 想加入？很简单！
**扫一扫下面二维码**，一键关注公众号，开启你的技术学习之旅！

![](https://files.mdnice.com/user/71186/0dde803d-d52f-4ed8-b74b-b7f3da5817b9.png)

另外，我还建了一个**技术交流群**，里面都是认真写代码的小伙伴，不吹牛、不闲聊，只聊技术。  
有问题？大家一块儿讨论，比一个人闷头学效率高多了！

![](https://files.mdnice.com/user/48364/4ebc72e9-e4bb-447a-9a92-8367a178df6d.png)

技术这条路，一个人走容易迷路，一群人走才有方向。  
跟上节奏，我们一起变强 💪