大家好，我是小康。

#### 前言：

写 C/C++ 代码时，有时候你会遇到编译器提示“重复定义”或者“符号冲突”的问题，尤其是在引入类的头文件时，编译器可能会告诉你：“喂！你这里有两个相同的类定义，搞错了吧！”

这个问题通常发生在某个 `.cpp` 文件中多次引入了同一个头文件，导致该头文件被多次包含。你可能会想，为什么这会有问题呢？头文件不就是用来声明类和函数的吗，包含一次不就行了吗？为什么会导致编译出错呢？

好，今天我们就通过一个类的例子来解决这个问题，看看怎样防止头文件被重复包含，以及如何优雅地解决这个问题。

### 1. 头文件重复包含会造成什么问题？

假设我们有一个非常简单的 `Math` 类，它包含了两个数学操作：加法和减法。

```c++
// math.h
class Math {
public:
    int add(int a, int b);
    int subtract(int a, int b);
};
```
#### 现在，你可能会有这样一个场景：

你在同一个源文件里，写了两次 `#include "math.h"`，看起来似乎没啥问题，毕竟就包含了同一个头文件而已。

```c++
// main.cpp
#include "math.h"
#include "math.h"  // 这里多了一次包含

int main() {
    Math math;
    return 0;
}
```

#### 为什么这样会出错呢？

虽然看起来我们只是简单地重复包含了一次头文件，但实际上，每次 `#include` 都会把头文件的内容直接插入到源文件里。

也就是说，当编译器处理到第二个 `#include "math.h"` 时，它会再次“插入”一遍 `math.h` 的内容。

#### 这样就发生了什么呢？

编译器在处理 `main.cpp` 时，会看到两次完全相同的类定义—`Math`类。这就让编译器觉得，你在同一个源文件中定义了两次 `Math` 类，于是就报错了：

```bash
error: redefinition of 'class Math'
```

**这就叫做重复定义！**

为什么会这样呢？
- 因为 **类的定义在整个文件中是全局有效的**。
- 如果你两次定义同一个类，编译器就会觉得这违反了规则——**类不能重复定义**。它会认为你在同一个源文件里定义了两个 `Math` 类，这自然会引发编译错误。

> **注意**：不仅仅是类，函数和全局变量在头文件被多次包含时也会遇到类似的重复定义问题。  

### 2. 如何解决头文件重复包含的问题？

好消息是，C/C++ 提供了两种常见的方法来防止头文件被多次包含：`#ifndef` 和 `#pragma once`。接下来我们用这两种方法来解决上面的问题。

#### 方法一：`#ifndef`（防止多次包含）

**这是什么？**

`#ifndef`（if not defined） 是 C/C++ 中一种常用的预处理指令。通过这种方式，我们可以给每个头文件加个“防护罩”，让它只被包含一次。

`#ifndef` 的基本思想是：检查某个宏（macro）是否已经被定义过。如果没有定义，就定义它并包含头文件的内容；如果已经定义过了，那么就跳过这个文件的内容，避免重复包含。

**怎么用？**

还是上面的 Math 类，为了防止它被重复包含，我们可以用 `#ifndef` 包裹起来：

```c++
// math.h
#ifndef MATH_H  // 如果没有定义过 MATH_H
#define MATH_H  // 那么就定义 MATH_H

class Math {
public:
    int add(int a, int b);
    int subtract(int a, int b);
};

#endif  // 结束防护罩
```

**这段代码的意思是**：首先检查 `MATH_H` 是否被定义过，如果没有定义，就进入 `#define MATH_H`，并包含头文件内容；如果定义过了，就直接跳过头文件的内容。

每次你包含这个头文件时，预处理器会首先检查 `MATH_H` 是否已经被定义。如果是，后续的文件就不会重复包含这个头文件了。

**为什么有效？**

这样做的原理是：宏定义（`#define`）是一次性的，也就是说，`MATH_H` 一旦被定义，后续的代码就不会再次进入 `#ifndef` 里面的部分，从而避免重复定义。

#### 方法二：`#pragma once`（一种简洁的做法）

**这是什么？**

除了 `#ifndef`，还有一种非常简洁且常用的方式叫做 `#pragma once`。它的作用跟 `#ifndef` 一样，都是为了防止头文件重复包含。

`#pragma once` 是一个编译指令，它告诉编译器：**这个文件只会被包含一次，不管它在代码中被引用多少次**。它比 `#ifndef` 方式要简洁得多，因为你不需要手动定义宏，也不需要写多余的 `#endif`。

**怎么用？**

只需要在头文件的最开始加上一行 `#pragma once`，就搞定了。例如：

```c++
// math.h
#pragma once

int add(int a, int b);
int subtract(int a, int b);
```

从此以后，编译器会记住这个头文件已经包含过了，下次再遇到这个文件时，它会自动跳过，避免重复处理。

**为什么有效？**

`#pragma once` 是编译器的一个指令，告诉它只会处理一次该文件。不同于 `#ifndef` 需要通过宏来实现防止多次包含，`#pragma once` 是编译器直接控制的，它内部会自动进行管理，不需要外部干预。

### 3. 哪个更好？`#ifndef` 还是 `#pragma once`？

#### `#ifndef` 的优势：
+ **标准化**：`#ifndef` 是 C/C++ 的标准指令，几乎所有的编译器都支持，确保了代码的可移植性。
+ **兼容性**：在一些古老的编译器或者特定平台上，`#pragma once` 可能不被支持，但 `#ifndef` 是广泛支持的。

#### `#pragma once` 的优势：
+ **简洁**：只需要一行代码，写起来比 `#ifndef` 简单。
+ **效率**：`#pragma once` 由编译器本身管理，通常比 `#ifndef` 的宏检查更高效。
+ **少出错**：省去了重复定义宏的麻烦，减少了可能出错的机会。

#### 小结一下：
+ `#ifndef`：这种方式是标准的 C/C++ 预处理指令，几乎所有的编译器都支持，兼容性很好。虽然稍微麻烦一点，但可以确保代码在不同的编译器和平台上都能正常工作。
+ `#pragma once`：这是编译器的指令，使用起来非常简洁，省去了很多冗余的代码，适合现代编译器。不过，某些老旧编译器可能不支持，所以在特殊情况下要小心。

#### 列个表格，对比一下：

| 特性 | `#ifndef`<br/> 防护宏 | `#pragma once` |
| --- | --- | --- |
| **兼容性** | 兼容所有编译器，任何支持 C/C++ 的编译器都能用 | 主要是现代编译器，但大部分支持（如 GCC、Clang、MSVC） |
| **书写方式** | 需要多个指令，稍微麻烦一点 | 一行代码，简单直接 |
| **防护效果** | 通过宏定义确保文件只被包含一次 | 直接告诉编译器只包含一次，效率更高 |
| **出错几率** | 容易出错，宏定义的名字要避免冲突 | 几乎没有出错的可能 |


总的来说，`#pragma once` 更简洁、更现代，但有些老旧编译器可能不支持。如果你在做跨平台开发，或者需要最大兼容性，还是用 `#ifndef` 更稳妥。

记住，虽然两者都能解决问题，但你可以根据实际情况选择最适合你的方式。总之，搞清楚头文件重复包含这个小坑，可以让你在写代码时更加得心应手，减少不必要的麻烦！

### 最后:

如果觉得这篇文章不错，别忘了点个「赞」、点个「在看」支持一下哦，或分享给更多对 C/C++编程 感兴趣的小伙伴！

也欢迎大家关注我的公众号「跟着小康学编程」，下一篇，我们接着为大家分享编程技术干货，敬请期待！

#### 怎么关注我的公众号？

点击下方公众号名片即可关注。

![](https://files.mdnice.com/user/48364/65158d3c-cd38-4604-861a-8f0379066dc0.png)

此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！

![](https://files.mdnice.com/user/48364/971ccaa3-8f57-4e33-8bc9-d0863eeade81.png)


