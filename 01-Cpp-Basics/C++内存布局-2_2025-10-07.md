大家好，我是小康。

#### 前言：

在上一篇文章《C++对象内存布局你真的懂了吗？对齐和顺序优化大揭秘！》中，我们讨论了成员变量的顺序如何影响内存大小，还分享了优化对象内存的技巧，帮助你让内存更加高效。

但其实，内存布局远不止这些。除了变量顺序的优化，内存对齐和虚函数表（VTable）也是幕后“推手”，它们会影响对象的大小和程序的运行效率，理解它们的运作对写出高效代码至关重要。

此外，当类有继承关系时，内存布局的复杂性会进一步增加，尤其是虚函数表指针和父类成员的继承。搞清楚这些细节，可以帮助我们更好地掌握内存使用情况。

所以，这篇文章将深入探讨内存对齐、填充、虚函数、继承等因素是如何影响内存布局的，并且我们还会介绍如何使用 GDB 和 VS 调试工具来查看和优化内存布局，帮助你更直观地理解这些内容。

### 一、内存对齐和填充的基本概念

#### 内存对齐：

+ **内存对齐** 是为了让数据在内存中的存储位置符合某种规则，以便 CPU 更高效地访问。
+ 比如，现代 CPU 通常会按 8 字节为单位访问内存。为了避免 CPU 每次访问数据时需要分两次读，数据最好从 8 字节的边界开始存储，这样就能减少 CPU 的访问次数。

#### 填充：
+ 如果数据没有按要求对齐，系统会在数据之间插入“空白”区域，称为 **填充**。填充的空间不会存储任何有效数据，只是为了保证数据的对齐。
+ 填充虽然浪费了一些内存，但它能让 CPU 高效地按对齐的规则来访问数据，避免了多次读取，提升了性能。

### 二、用类成员的例子来说明

假设我们有一个类，类中有几个不同类型的成员变量，CPU 要按 8 字节读取内存（通常是现代系统的默认设置）。我们来看两种情况：**不填充** 和 **填充**。

```c++
class MyClass {
public:
    char a;  // 1 字节
    int b;   // 4 字节
    double c; // 8 字节
};
```

#### 1. 不填充的情况
在没有填充的情况下，类的内存布局可能是这样的：

```css
内存地址:  0x00   0x01   0x02   0x03   0x04   0x05   0x06   0x07   0x08   0x09   0x0A   0x0B   0x0C   0x0D   0x0E   0x0F
存储数据: | a(1B) | b(4B) | c(8B) |
```

**解释：**

+ `a` 是 `char` 类型，占 1 字节。
+ `b` 是 `int` 类型，占 4 字节。
+ `c` 是 `double` 类型，占 8 字节。

在这个例子里，`a` 和 `b` 是按顺序存储的，`a` 占用了 `0x00`，`b` 占用了 `0x01` 到 `0x04`，然后 `c` 紧接着存储在 `0x05` 到 `0x0C`。

这里，问题在于 `c` 没有按 8 字节的边界对齐。在内存中，`c` 其实是可以从 `0x08` 开始存储的，但它实际上被存放在 `0x05` 之后的位置，并没有对齐到 8 字节的边界。这导致了潜在的性能问题，特别是 CPU 访问的时候。

**CPU 如何访问？**

假设 CPU 是按照 **8 字节**来访问内存的，它会按照顺序从内存中读取数据。

第一次访问：CPU 从 `0x00` 开始读取 8 字节的数据。

+ 它会得到 `a`（1 字节）和 `b`（4 字节），然后剩下的数据不完整。
+ `c` 可能会被分开存放，导致 CPU 必须两次读取才能拿到完整的 `c`，这就引发了额外的访问开销。

#### 2. 填充的情况
为了确保数据对齐，我们可以使用 **填充**，让 `a` 后面加上 3 字节的填充，这样 `b` 就从 4 字节的边界开始存储，`c` 也能对齐到 8 字节的边界。

```css
内存地址:  0x00   0x01   0x02   0x03   0x04   0x05   0x06   0x07   0x08   0x09   0x0A   0x0B   0x0C   0x0D   0x0E   0x0F
存储数据: | a(1B) | fill(3B) | b(4B) | fill(4B) | c(8B) |
```

**解释：**

+ `a` 仍然占 1 字节，位于 `0x00`。
+ 由于 `b` 是 `int` 类型，占用 4 字节，为了让 `b` 和 `c` 正确对齐，我们在 `a` 后面添加了 **3 字节填充**（`fill(3B)`）。
+ 现在 `b` 从 `0x04` 开始，占用 `0x04` 到 `0x07` 的位置。
+ 然后，为了保证 `c` 对齐到 8 字节的边界，我们又插入了 **4 字节填充**，让 `c` 从 `0x08` 开始存储，直到 `0x0F`。

现在，数据已经按 8 字节对齐：

+ **第一次访问**：CPU 从 `0x00` 开始读取 8 字节的数据，得到完整的 `a`（1 字节）和 `b`（4 字节），以及填充的空间。
+ **第二次访问**：CPU 再读取 `0x08` 到 `0x0F` 这 8 字节的数据，完整获取到 `c`。

这样，CPU 每次都能一次性加载 8 字节的完整数据块，避免了多次访问，提高了效率。

这里提个问题：在填充的情况下，假设 CPU 一次性加载了 8 字节的数据，包括了 `a` 和 `b`，那么程序怎么知道这些字节分别属于 `a` 和 `b` 呢？它们明明在同一块内存区域中。

这就要讲到 CPU 是如何工作的了：

当 CPU 一次性加载了 8 字节的数据，它会把这 8 字节加载到一个寄存器里。寄存器是 CPU 内部非常快速的存储区域，能够存储数据供 CPU 快速使用。

但问题是，程序怎么从这 8 字节的寄存器中提取出 `a` 和 `b` 呢？答案是，程序根据变量的类型和大小来处理：

+ `a` 是 1 字节，程序知道它就占用寄存器中的前 1 个字节。
+ `b` 是 4 字节，程序知道它占用寄存器中接下来的 4 个字节。

所以，虽然寄存器一次性存储了 8 字节的数据，程序会根据每个变量的类型和大小（比如 `a` 占 1 字节，`b` 占 4 字节）来正确地分割和读取它们的数据。

#### 3、小结一下：
1. **不填充** 的情况下，数据没有对齐，`c`可能需要分开读取，导致 CPU 需要多次访问内存，性能降低。
2. **填充** 的情况下，数据被对齐到适当的边界，CPU 每次都能高效地读取整块数据，提升了性能。

虽然填充浪费了内存（在 `a` 后插入了 3 字节，在 `b` 后插入了 4 字节），但它带来了更高的访问效率，特别是在数据量大的情况下，性能提升是显著的。

通过这个类成员的例子，应该能让你更直观地理解内存对齐、填充及其对 CPU 性能的影响！

### 三、有虚函数时的内存布局（VTable 指针）

C++ 的多态是通过虚函数实现的。为了支持动态多态（也就是运行时根据对象类型调用正确的虚函数），编译器会为每个含有虚函数的类创建一个虚函数表（VTable）。每个对象都会有一个指针，指向这个虚函数表。这个指针会在对象的内存布局中占用额外的空间。

#### 1、例子：
```c++
class Base {
public:
    virtual void func() {}
    int a;
};

int main() {
    cout << "Size of Base: " << sizeof(Base) << " bytes" << endl;
    return 0;
}
```

#### 2、输出：
在 64 位系统上，输出通常是：

```bash
Size of Base: 16 bytes 
```

#### 3、内存布局：
```scss
| VTable指针 (8字节) | a (4字节) | 填充 (4字节) |
|--------------------|-----------|--------------|
0x00                0x08        0x0C          0x10
```

**简单说明：**

+ **VTable指针（8字节）**：每个含虚函数的类的对象都会有一个虚函数表指针，指向类的虚函数表。虚函数表中保存了类的虚函数地址，以便动态调用。
+ `a (4字节)`：普通成员变量，占用 4 字节。
+ **填充（4字节）**：为了保证 8 字节对齐，系统会在 `a` 后面插入 4 字节的填充。
+ **总大小：** 16 字节。由于 64 位系统对齐要求为 8 字节，因此对象的总大小被填充到 16 字节。

### 四、 类的继承关系对内存布局的影响  

在 C++ 中，继承不仅仅是代码复用的方式，它还会影响类的内存布局。特别是当涉及到虚函数的时候，继承关系让内存布局变得更加复杂。为什么呢？我们来详细看看。

#### 1. 继承关系中的虚函数表

我们已经知道，如果一个类包含虚函数，编译器就会为这个类创建一个虚函数表（VTable），并且对象中会有一个指针指向这个虚函数表。这让对象能够在运行时根据实际类型调用相应的虚函数。

现在，如果我们有一个父类包含虚函数，而派生类继承了这个父类，那么派生类的内存布局不仅会包含自己的成员变量，还会包含从父类继承来的虚函数表指针。这意味着派生类的对象内存比父类要大，因为它需要额外存储父类的虚函数表指针和父类成员。

#### 2. 继承关系中的内存布局
让我们通过一个实际的例子来看看内存布局是如何变化的。

```c++
#include <iostream>
using namespace std;

class Base {
public:
    virtual void func() {}  // 虚函数
    int a;                  // 普通成员变量
};

class Derived : public Base {
public:
    int b;  // 派生类的成员变量
};

int main() {
    cout << "Size of Base: " << sizeof(Base) << " bytes" << endl;
    cout << "Size of Derived: " << sizeof(Derived) << " bytes" << endl;
    return 0;
}
```

#### 3. 内存布局分析

**Base 类**：

+ `func()` 虚函数使得编译器为 `Base` 类创建了一个虚函数表（VTable），并且给每个 `Base` 类型的对象加上一个指针，指向这个虚函数表。
+ `a` 是一个普通的 `int` 类型，占用 4 字节。
+ 由于系统的对齐规则（通常是 8 字节对齐），`Base` 类的总大小是 16 字节。

内存布局：

```scss
| VTable指针 (8字节) | a (4字节) | 填充 (4字节) |
总大小：16 字节
```

**Derived 类**：

+ `Derived` 类继承了 `Base` 类，除了自己的成员变量 `b`，它还继承了 `Base` 的虚函数表指针（8 字节）和 `a`（4 字节）。
+ `b` 是一个 `int` 类型，占 4 字节。
+ 由于内存对齐要求，`Derived` 类的内存布局会包含额外的填充，以保证对象的对齐规则。最终，`Derived` 的内存大小为 24 字节。

内存布局：

```scss
| VTable指针 (8字节) | a (4字节) | 填充 (4字节) | b (4字节) | 填充 (4字节) |
总大小：24 字节
```

#### 4. 小结一下：

继承会影响类的内存布局，特别是当父类有虚函数的时候。派生类不仅要包含自己定义的成员变量，还要存储父类的虚函数表指针和父类成员，这就让对象的内存变得更大。

此外，内存对齐规则也会加入填充空间，进一步增加对象的内存占用。所以，继承让内存布局变得复杂，尤其是有虚函数时，内存消耗会更明显。  

但是，即使不涉及继承和虚函数，类的内存布局依然会受类成员的排列顺序、数据类型对齐要求、以及可能的填充字节影响。通过一些简单的代码和 GDB 调试，我们可以看到这些影响。

### 五、如何使用 gdb 等调试工具查看内存布局 

GDB 是一个非常强大的调试工具，不仅能帮助你调试程序逻辑，还可以查看对象在内存中的具体布局。我们可以利用 GDB 来深入了解对象的内存分配，看看它的每一部分占用了多少字节，是否有填充字节，以及这些字节是如何排列的。

接下来，我们以一个简单的类 MyClass 为例，来使用 gdb 看看它的内存布局是如何排列的。

#### 1、示例：MyClass 的内存布局

看看下面这个代码：

```c++
#include <iostream>
using namespace std;

class MyClass {
public:
    char a;  // 1字节
    double b; // 8字节
    char c;  // 1字节

    MyClass() {
        a = 'A';
        b = 8.0;
        c = 'B';
    }
};

int main() {
    MyClass m;
    cout << sizeof(MyClass) << " bytes" << endl; // 24
    return 0;
}
```

这里，我们定义了一个简单的类 `MyClass`，其中包含一个 `char` 类型的成员变量 `a`、一个 `double` 类型的成员变量 `b` 和另一个 `char` 类型的成员变量 `c`。

+ `char` 类型占 1 字节。
+ `double` 类型占 8 字节。

#### 2、使用 GDB 查看内存布局

我们在 GDB 中运行这个程序，并查看 `MyClass` 对象 `m` 的内存布局。

**1. 编译时加调试信息**：

```bash
g++ -g my_program.cpp -o my_program
```

**2. 在 GDB 中运行程序**：

```bash
gdb ./my_program
```

**3. 设置断点并查看内存布局**：

```bash
(gdb) b 19    // 19 代表行号
(gdb) r       // 运行程序
(gdb) p sizeof(MyClass)  // 输出类的大小
$1 = 24
(gdb) p &m   // 打印对象 m 的地址        
(gdb) 0x7fffffffe2d0
(gdb) x/24b 0x7fffffffe2d0 // 查看 m 对象的内存布局，从地址 0x7fffffffe2d0 开始，查看接下来的 24 个字节，以 16 进制格式显示。
0x7fffffffe2d0: 0x41    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x7fffffffe2d8: 0x00    0x00    0x00    0x00    0x00    0x00    0x20    0x40
0x7fffffffe2e0: 0x42    0xe3    0xff    0xff    0xff    0x7f    0x00    0x00
```

解析内存布局：

通过 GDB 输出的内存信息，我们可以看到以下内容：

**1. a = 'A'（0x41）**：
+ `a` 是一个 `char` 类型，占 1 字节，值是 `'A'`，也就是 `0x41`。
+ 紧接着的字节是填充字节，因为 `double` 类型需要 8 字节对齐，系统会插入填充字节来满足对齐要求。

**2. b = 8.0（double）**：
+ `b` 是一个 `double` 类型，占 8 字节，值为 `8.0`。
+ 8.0 的 16 进制表示是 `0x40200000`，即在内存中的表示为：

```bash
0x20 0x40 0x00 0x00 0x00 0x00 0x00 0x00
```

**3. c = 'B'（0x42）**：
+ `c` 是一个 `char` 类型，占 1 字节，值是 `'B'`，即 `0x42`。
+ 由于 `b` 的 8 字节对齐要求，`c` 后面依然会有填充字节，所以你会看到 `0x42` 后面跟着一些非零值。

#### 3、为什么会有填充字节？

上文有提到过，填充字节其实是为了遵循内存对齐规则。因为 `double` 类型需要 8 字节对齐，因此内存中的 `char` 类型成员 `a` 和 `c` 后面会插入一些填充字节来保证 `double` 类型变量 `b` 从一个 8 字节对齐的位置开始存储。

这种内存对齐的设计有助于提升性能，因为它减少了处理器访问内存时的不必要跳跃（即减少了缓存未命中和内存访问的延迟）。

#### 4、小结一下：
+ 通过 GDB，我们可以清楚地看到对象的内存布局，了解每个成员变量占用的字节数，以及填充字节的存在。
+ 如果你在调试时看到填充字节或者其他看似“奇怪”的字节值，那通常是内存对齐导致的。

除了 GDB，我们也可以通过 Visual Studio (VS) 来调试，能够帮助你更直观地查看 C++ 程序的内存布局。下面是如何在 VS 中进行调试并查看对象的内存布局的一些步骤。

1.打开调试模式

首先，确保你在调试模式下编译代码，方法是选择“调试”配置进行编译，而不是“发布”配置。

2.添加断点

在代码中，你可以通过点击行号左侧的空白区域来设置断点。举个例子，在 `main()` 函数里，点击 `MyClass m;` 这一行的左侧空白区域，VS 会在这一行设置一个断点。

![](https://files.mdnice.com/user/71186/2364c8a2-89a0-419f-9d8b-72140de7d884.png)


3.启动调试并监视变量

接着在 VS 中按 **F5** 或点击工具栏的 **开始调试** 按钮启动程序。

当程序运行到断点时会自动暂停。你可以通过 监视 来查看特定对象或变量的内存布局。右键点击想要查看的变量（比如 `m`），然后选择 **添加监视**，VS 会在下方的“监视”窗口中显示这个变量。

![](https://files.mdnice.com/user/71186/18f64f10-961c-4060-9d90-b1dc71a09e1f.png)

4.显示内存窗口

如果你想更直接地查看对象的内存布局，可以打开 内存窗口。操作步骤如下：

+ 在调试过程中，点击 **调试** 菜单，选择 **窗口** > **内存** > **内存 1**。

![](https://files.mdnice.com/user/71186/440cab41-5d79-4cf1-8187-dfe44843decd.png)

+ 在弹出的内存窗口中，输入你想要查看的对象的地址。例如，如果 `m` 的地址是 `0x7fffffffe2d0`，你就可以在内存窗口中输入这个地址，查看它对应的内存内容。


![](https://files.mdnice.com/user/71186/2d4fcd24-8645-4659-af45-5b915f001f7d.png)


5.观察内存内容

在内存窗口中，VS 会以十六进制和字符两种格式显示内存内容。你可以看到 `m` 对象的各个成员变量是如何在内存中排列的，包括是否有填充字节。通过观察这些内容，你就能很清楚地理解内存的分配情况，是否有浪费或者对齐问题。

总之：GDB 和 Visual Studio 都能帮助你检查 C++ 程序中的内存布局。GDB 提供了命令行的调试方式，而 VS 提供了更加图形化、直观的调试体验。

### 六、如何优化内存布局，减少内存浪费  

在我们用 gdb 这样的工具查看对象的内存布局后，你可能会发现有一些看起来很浪费的地方，比如内存填充或者变量排列不够紧凑，这些都可能影响程序的性能或者占用不必要的内存。那么，如何优化这些布局呢？如何减少这些“空隙”呢？

这就是我们接下来的话题：**如何优化内存布局，减少内存浪费**。

我们可以通过合理地调整类中的成员变量顺序来减少填充字节的数量，达到更高效的内存布局。例如，之前在 `MyClass` 中，`char a` 和 `char c` 之间有 7 个字节的填充，因为 `double b` 占了 8 字节，这样就会造成后续的 `char c` 变量需要跳过填充区域。

如果我们把 `char` 类型的变量放在一起，这样可以减少填充空间，从而优化内存使用。简单来说，就是尽量让相同大小的变量靠在一起，避免出现填充字节。

来看看我们如何优化这个 `MyClass` 类：

```c++
class MyClass {
public:
    char a;    // 1字节
    char c;    // 1字节
    double b;  // 8字节

    MyClass() {
        a = 'A';
        b = 8.0;
        c = 'B';
    }
};
```

这里我们调整了 `a` 和 `c` 的位置，使得它们都放在一起，`double b` 则在后面。这样做的好处是，类的内存布局更加紧凑，减少了填充字节的浪费，内存占用也会更加高效。

再来看下我们编译并查看内存布局的结果：

```bash
(gdb) x/16b 0x7fffffffe2d0
0x7fffffffe2d0: 0x41    0x42    0x00    0x00    0x00    0x00    0x00    0x00
0x7fffffffe2d8: 0x00    0x00    0x00    0x00    0x00    0x00    0x20    0x40

总大小：只占 16 个字节。
```

通过这种方式，我们不仅优化了内存布局，也可能提升了程序的运行效率。总的来说，优化内存布局的核心就是避免浪费空间，尽量减少对齐的填充字节，并合理安排成员变量的顺序。

那么在实际的使用场景中，我们是否会通过调整成员变量顺序来优化内存占用？

那得看情况！具体可参考我的上一篇文章：

### 总结

搞懂内存对齐和填充，对你写高效的 C++ 代码超有帮助。简单来说，内存对齐是为了让数据存取更快，而填充就是为了让数据按照规定的方式排列。像虚函数和继承关系这些也会影响内存布局，虚函数表指针（VTable）和继承过来的成员变量都会占用额外的内存。

用 gdb 和 VS 调试，你可以直接看清楚对象在内存里的分布，找到可能的浪费或者对齐问题。优化内存布局的办法其实挺简单的，比如调整成员变量顺序、使用合适的对齐方式，这些都能帮你减少内存占用，还能提升性能。

总的来说，理解这些内存布局的小细节，不仅能帮你写出更省内存、更快的代码，调试和优化时也能省不少时间。

### 最后:

如果觉得有用，别忘了点个「赞」、点个「在看」，或分享给更多对 C++ 编程感兴趣的小伙伴！😊

也欢迎关注我的公众号「跟着小康学编程」，获取更多有趣又实用的技术干货。有问题？评论区等你，咱们一起讨论学习！技术路上不孤单，一起成长！  

#### 怎么关注我的公众号？

点击下方公众号名片即可关注。

![](https://files.mdnice.com/user/48364/65158d3c-cd38-4604-861a-8f0379066dc0.png)

另外，小康还建了一个技术交流群，专门聊技术、答疑解惑。如果你在读文章时碰到不懂的地方，随时欢迎来群里提问！我会尽力帮大家解答，群里还有不少技术大佬在线支援，咱们一起学习进步，互相成长！

![](https://files.mdnice.com/user/48364/971ccaa3-8f57-4e33-8bc9-d0863eeade81.png)