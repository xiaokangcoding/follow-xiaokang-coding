#### 前言：

大家好，我是小康 👋

在上一篇文章《C++对象内存布局你真的懂了吗？对齐和顺序优化大揭秘！》中，我们讲了成员变量顺序对内存大小的影响，以及如何通过合理排序优化内存。

但实际上，C++ 对象的内存布局远比顺序优化复杂。**内存对齐、填充、虚函数表（VTable）**，甚至**继承关系**，都会悄悄改变对象的大小和运行效率。理解这些幕后机制，不仅能让你写出更高效的代码，还能帮助你在调试和优化时有的放矢。

在这篇文章中，我们将深入讲解这些概念，并结合 **GDB** 和 **VS 调试工具** 实例，让你直观地看到对象在内存中的真实排布。

> 💡 学习建议：
>
> **多画内存图**：画出对象的内存布局比单看代码更容易理解。
>
> **用调试器观察**：通过 GDB/VS 查看实际对象地址和偏移，加深理解。
>
> **实验不同组合**：尝试不同成员类型、继承和虚函数，观察大小变化。
>
>想系统学习更多 C++ 知识？欢迎关注我的公众号「**跟着小康编程**」，我会持续更新 C、 C++、Linux、后端开发等高质量技术文章。也可以加我的个人微信，一起进群讨论学习！
>
> 
> <table>
> <tr>
> <td align="center">
> <img src="https://github.com/xiaokangcoding/follow-xiaokang-coding/raw/main/images/qrcode-wechat-official.png" width="200">
> <br>
> <em>公众号「跟着学小康编程」</em>
> </td>
> <td align="center">
> <img src="https://github.com/xiaokangcoding/follow-xiaokang-coding/raw/main/images/qrcode-personal-wechat.png" width="200">
> <br>
> <em>个人微信（备注：加群）</em>
> </td>
> </tr>
> </table>

### 一、内存对齐和填充的基本概念

#### 内存对齐：

+ **内存对齐** 是为了让数据在内存中的存储位置符合某种规则，以便 CPU 更高效地访问。
+ 比如，现代 CPU 通常会按 8 字节为单位访问内存。为了避免 CPU 每次访问数据时需要分两次读，数据最好从 8 字节的边界开始存储，这样就能减少 CPU 的访问次数。

#### 填充：
+ 如果数据没有按要求对齐，系统会在数据之间插入“空白”区域，称为 **填充**。填充的空间不会存储任何有效数据，只是为了保证数据的对齐。
+ 填充虽然浪费了一些内存，但它能让 CPU 高效地按对齐的规则来访问数据，避免了多次读取，提升了性能。

### 二、用类成员的例子来说明

假设我们有一个类，类中有几个不同类型的成员变量，CPU 要按 8 字节读取内存（通常是现代系统的默认设置）。我们来看两种情况：**不填充** 和 **填充**。

```c++
class MyClass {
public:
    char a;  // 1 字节
    int b;   // 4 字节
    double c; // 8 字节
};
```

#### 1. 不填充的情况
在没有填充的情况下，类的内存布局可能是这样的：

```css
内存地址:  0x00   0x01   0x02   0x03   0x04   0x05   0x06   0x07   0x08   0x09   0x0A   0x0B   0x0C   0x0D   0x0E   0x0F
存储数据: | a(1B) | b(4B) | c(8B) |
```

**解释：**

+ `a` 是 `char` 类型，占 1 字节。
+ `b` 是 `int` 类型，占 4 字节。
+ `c` 是 `double` 类型，占 8 字节。

在这个例子里，`a` 和 `b` 是按顺序存储的，`a` 占用了 `0x00`，`b` 占用了 `0x01` 到 `0x04`，然后 `c` 紧接着存储在 `0x05` 到 `0x0C`。

这里，问题在于 `c` 没有按 8 字节的边界对齐。在内存中，`c` 其实是可以从 `0x08` 开始存储的，但它实际上被存放在 `0x05` 之后的位置，并没有对齐到 8 字节的边界。这导致了潜在的性能问题，特别是 CPU 访问的时候。

**CPU 如何访问？**

假设 CPU 是按照 **8 字节**来访问内存的，它会按照顺序从内存中读取数据。

第一次访问：CPU 从 `0x00` 开始读取 8 字节的数据。

+ 它会得到 `a`（1 字节）和 `b`（4 字节），然后剩下的数据不完整。
+ `c` 可能会被分开存放，导致 CPU 必须两次读取才能拿到完整的 `c`，这就引发了额外的访问开销。

#### 2. 填充的情况
为了确保数据对齐，我们可以使用 **填充**，让 `a` 后面加上 3 字节的填充，这样 `b` 就从 4 字节的边界开始存储，`c` 也能对齐到 8 字节的边界。

```css
内存地址:  0x00   0x01   0x02   0x03   0x04   0x05   0x06   0x07   0x08   0x09   0x0A   0x0B   0x0C   0x0D   0x0E   0x0F
存储数据: | a(1B) | fill(3B) | b(4B) | fill(4B) | c(8B) |
```

**解释：**

+ `a` 仍然占 1 字节，位于 `0x00`。
+ 由于 `b` 是 `int` 类型，占用 4 字节，为了让 `b` 和 `c` 正确对齐，我们在 `a` 后面添加了 **3 字节填充**（`fill(3B)`）。
+ 现在 `b` 从 `0x04` 开始，占用 `0x04` 到 `0x07` 的位置。
+ 然后，为了保证 `c` 对齐到 8 字节的边界，我们又插入了 **4 字节填充**，让 `c` 从 `0x08` 开始存储，直到 `0x0F`。

现在，数据已经按 8 字节对齐：

+ **第一次访问**：CPU 从 `0x00` 开始读取 8 字节的数据，得到完整的 `a`（1 字节）和 `b`（4 字节），以及填充的空间。
+ **第二次访问**：CPU 再读取 `0x08` 到 `0x0F` 这 8 字节的数据，完整获取到 `c`。

这样，CPU 每次都能一次性加载 8 字节的完整数据块，避免了多次访问，提高了效率。

这里提个问题：在填充的情况下，假设 CPU 一次性加载了 8 字节的数据，包括了 `a` 和 `b`，那么程序怎么知道这些字节分别属于 `a` 和 `b` 呢？它们明明在同一块内存区域中。

这就要讲到 CPU 是如何工作的了：

当 CPU 一次性加载了 8 字节的数据，它会把这 8 字节加载到一个寄存器里。寄存器是 CPU 内部非常快速的存储区域，能够存储数据供 CPU 快速使用。

但问题是，程序怎么从这 8 字节的寄存器中提取出 `a` 和 `b` 呢？答案是，程序根据变量的类型和大小来处理：

+ `a` 是 1 字节，程序知道它就占用寄存器中的前 1 个字节。
+ `b` 是 4 字节，程序知道它占用寄存器中接下来的 4 个字节。

所以，虽然寄存器一次性存储了 8 字节的数据，程序会根据每个变量的类型和大小（比如 `a` 占 1 字节，`b` 占 4 字节）来正确地分割和读取它们的数据。

#### 3、小结一下：
1. **不填充** 的情况下，数据没有对齐，`c`可能需要分开读取，导致 CPU 需要多次访问内存，性能降低。
2. **填充** 的情况下，数据被对齐到适当的边界，CPU 每次都能高效地读取整块数据，提升了性能。

虽然填充浪费了内存（在 `a` 后插入了 3 字节，在 `b` 后插入了 4 字节），但它带来了更高的访问效率，特别是在数据量大的情况下，性能提升是显著的。

通过这个类成员的例子，应该能让你更直观地理解内存对齐、填充及其对 CPU 性能的影响！

### 三、有虚函数时的内存布局（VTable 指针）

C++ 的多态是通过虚函数实现的。为了支持动态多态（也就是运行时根据对象类型调用正确的虚函数），编译器会为每个含有虚函数的类创建一个虚函数表（VTable）。每个对象都会有一个指针，指向这个虚函数表。这个指针会在对象的内存布局中占用额外的空间。

#### 1、例子：
```c++
class Base {
public:
    virtual void func() {}
    int a;
};

int main() {
    cout << "Size of Base: " << sizeof(Base) << " bytes" << endl;
    return 0;
}
```

#### 2、输出：
在 64 位系统上，输出通常是：

```bash
Size of Base: 16 bytes 
```

#### 3、内存布局：
```scss
| VTable指针 (8字节) | a (4字节) | 填充 (4字节) |
|--------------------|-----------|--------------|
0x00                0x08        0x0C          0x10
```

**简单说明：**

+ **VTable指针（8字节）**：每个含虚函数的类的对象都会有一个虚函数表指针，指向类的虚函数表。虚函数表中保存了类的虚函数地址，以便动态调用。
+ `a (4字节)`：普通成员变量，占用 4 字节。
+ **填充（4字节）**：为了保证 8 字节对齐，系统会在 `a` 后面插入 4 字节的填充。
+ **总大小：** 16 字节。由于 64 位系统对齐要求为 8 字节，因此对象的总大小被填充到 16 字节。

### 四、 类的继承关系对内存布局的影响  

在 C++ 中，继承不仅仅是代码复用的方式，它还会影响类的内存布局。特别是当涉及到虚函数的时候，继承关系让内存布局变得更加复杂。为什么呢？我们来详细看看。

#### 1. 继承关系中的虚函数表

我们已经知道，如果一个类包含虚函数，编译器就会为这个类创建一个虚函数表（VTable），并且对象中会有一个指针指向这个虚函数表。这让对象能够在运行时根据实际类型调用相应的虚函数。

现在，如果我们有一个父类包含虚函数，而派生类继承了这个父类，那么派生类的内存布局不仅会包含自己的成员变量，还会包含从父类继承来的虚函数表指针。这意味着派生类的对象内存比父类要大，因为它需要额外存储父类的虚函数表指针和父类成员。

#### 2. 继承关系中的内存布局
让我们通过一个实际的例子来看看内存布局是如何变化的。

```c++
#include <iostream>
using namespace std;

class Base {
public:
    virtual void func() {}  // 虚函数
    int a;                  // 普通成员变量
};

class Derived : public Base {
public:
    int b;  // 派生类的成员变量
};

int main() {
    cout << "Size of Base: " << sizeof(Base) << " bytes" << endl;
    cout << "Size of Derived: " << sizeof(Derived) << " bytes" << endl;
    return 0;
}
```

#### 3. 内存布局分析

**Base 类**：

+ `func()` 虚函数使得编译器为 `Base` 类创建了一个虚函数表（VTable），并且给每个 `Base` 类型的对象加上一个指针，指向这个虚函数表。
+ `a` 是一个普通的 `int` 类型，占用 4 字节。
+ 由于系统的对齐规则（通常是 8 字节对齐），`Base` 类的总大小是 16 字节。

内存布局：

```scss
| VTable指针 (8字节) | a (4字节) | 填充 (4字节) |
总大小：16 字节
```

**Derived 类**：

+ `Derived` 类继承了 `Base` 类，除了自己的成员变量 `b`，它还继承了 `Base` 的虚函数表指针（8 字节）和 `a`（4 字节）。
+ `b` 是一个 `int` 类型，占 4 字节。
+ 由于内存对齐要求，`Derived` 类的内存布局会包含额外的填充，以保证对象的对齐规则。最终，`Derived` 的内存大小为 24 字节。

内存布局：

```scss
| VTable指针 (8字节) | a (4字节) | 填充 (4字节) | b (4字节) | 填充 (4字节) |
总大小：24 字节
```

#### 4. 小结一下：

继承会影响类的内存布局，特别是当父类有虚函数的时候。派生类不仅要包含自己定义的成员变量，还要存储父类的虚函数表指针和父类成员，这就让对象的内存变得更大。

此外，内存对齐规则也会加入填充空间，进一步增加对象的内存占用。所以，继承让内存布局变得复杂，尤其是有虚函数时，内存消耗会更明显。  

但是，即使不涉及继承和虚函数，类的内存布局依然会受类成员的排列顺序、数据类型对齐要求、以及可能的填充字节影响。通过一些简单的代码和 GDB 调试，我们可以看到这些影响。

### 五、如何使用 gdb 等调试工具查看内存布局 

GDB 是一个非常强大的调试工具，不仅能帮助你调试程序逻辑，还可以查看对象在内存中的具体布局。我们可以利用 GDB 来深入了解对象的内存分配，看看它的每一部分占用了多少字节，是否有填充字节，以及这些字节是如何排列的。

接下来，我们以一个简单的类 MyClass 为例，来使用 gdb 看看它的内存布局是如何排列的。

#### 1、示例：MyClass 的内存布局

看看下面这个代码：

```c++
#include <iostream>
using namespace std;

class MyClass {
public:
    char a;  // 1字节
    double b; // 8字节
    char c;  // 1字节

    MyClass() {
        a = 'A';
        b = 8.0;
        c = 'B';
    }
};

int main() {
    MyClass m;
    cout << sizeof(MyClass) << " bytes" << endl; // 24
    return 0;
}
```

这里，我们定义了一个简单的类 `MyClass`，其中包含一个 `char` 类型的成员变量 `a`、一个 `double` 类型的成员变量 `b` 和另一个 `char` 类型的成员变量 `c`。

+ `char` 类型占 1 字节。
+ `double` 类型占 8 字节。

#### 2、使用 GDB 查看内存布局

我们在 GDB 中运行这个程序，并查看 `MyClass` 对象 `m` 的内存布局。

**1. 编译时加调试信息**：

```bash
g++ -g my_program.cpp -o my_program
```

**2. 在 GDB 中运行程序**：

```bash
gdb ./my_program
```

**3. 设置断点并查看内存布局**：

```bash
(gdb) b 19    // 19 代表行号
(gdb) r       // 运行程序
(gdb) p sizeof(MyClass)  // 输出类的大小
$1 = 24
(gdb) p &m   // 打印对象 m 的地址        
(gdb) 0x7fffffffe2d0
(gdb) x/24b 0x7fffffffe2d0 // 查看 m 对象的内存布局，从地址 0x7fffffffe2d0 开始，查看接下来的 24 个字节，以 16 进制格式显示。
0x7fffffffe2d0: 0x41    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x7fffffffe2d8: 0x00    0x00    0x00    0x00    0x00    0x00    0x20    0x40
0x7fffffffe2e0: 0x42    0xe3    0xff    0xff    0xff    0x7f    0x00    0x00
```

解析内存布局：

通过 GDB 输出的内存信息，我们可以看到以下内容：

**1. a = 'A'（0x41）**：
+ `a` 是一个 `char` 类型，占 1 字节，值是 `'A'`，也就是 `0x41`。
+ 紧接着的字节是填充字节，因为 `double` 类型需要 8 字节对齐，系统会插入填充字节来满足对齐要求。

**2. b = 8.0（double）**：
+ `b` 是一个 `double` 类型，占 8 字节，值为 `8.0`。
+ 8.0 的 16 进制表示是 `0x40200000`，即在内存中的表示为：

```bash
0x20 0x40 0x00 0x00 0x00 0x00 0x00 0x00
```

**3. c = 'B'（0x42）**：
+ `c` 是一个 `char` 类型，占 1 字节，值是 `'B'`，即 `0x42`。
+ 由于 `b` 的 8 字节对齐要求，`c` 后面依然会有填充字节，所以你会看到 `0x42` 后面跟着一些非零值。

#### 3、为什么会有填充字节？

上文有提到过，填充字节其实是为了遵循内存对齐规则。因为 `double` 类型需要 8 字节对齐，因此内存中的 `char` 类型成员 `a` 和 `c` 后面会插入一些填充字节来保证 `double` 类型变量 `b` 从一个 8 字节对齐的位置开始存储。

这种内存对齐的设计有助于提升性能，因为它减少了处理器访问内存时的不必要跳跃（即减少了缓存未命中和内存访问的延迟）。

#### 4、小结一下：
+ 通过 GDB，我们可以清楚地看到对象的内存布局，了解每个成员变量占用的字节数，以及填充字节的存在。
+ 如果你在调试时看到填充字节或者其他看似“奇怪”的字节值，那通常是内存对齐导致的。

除了 GDB，我们也可以通过 Visual Studio (VS) 来调试，能够帮助你更直观地查看 C++ 程序的内存布局。下面是如何在 VS 中进行调试并查看对象的内存布局的一些步骤。

1.打开调试模式

首先，确保你在调试模式下编译代码，方法是选择“调试”配置进行编译，而不是“发布”配置。

2.添加断点

在代码中，你可以通过点击行号左侧的空白区域来设置断点。举个例子，在 `main()` 函数里，点击 `MyClass m;` 这一行的左侧空白区域，VS 会在这一行设置一个断点。

![](https://files.mdnice.com/user/71186/2364c8a2-89a0-419f-9d8b-72140de7d884.png)


3.启动调试并监视变量

接着在 VS 中按 **F5** 或点击工具栏的 **开始调试** 按钮启动程序。

当程序运行到断点时会自动暂停。你可以通过 监视 来查看特定对象或变量的内存布局。右键点击想要查看的变量（比如 `m`），然后选择 **添加监视**，VS 会在下方的“监视”窗口中显示这个变量。

![](https://files.mdnice.com/user/71186/18f64f10-961c-4060-9d90-b1dc71a09e1f.png)

4.显示内存窗口

如果你想更直接地查看对象的内存布局，可以打开 内存窗口。操作步骤如下：

+ 在调试过程中，点击 **调试** 菜单，选择 **窗口** > **内存** > **内存 1**。

![](https://files.mdnice.com/user/71186/440cab41-5d79-4cf1-8187-dfe44843decd.png)

+ 在弹出的内存窗口中，输入你想要查看的对象的地址。例如，如果 `m` 的地址是 `0x7fffffffe2d0`，你就可以在内存窗口中输入这个地址，查看它对应的内存内容。


![](https://files.mdnice.com/user/71186/2d4fcd24-8645-4659-af45-5b915f001f7d.png)


5.观察内存内容

在内存窗口中，VS 会以十六进制和字符两种格式显示内存内容。你可以看到 `m` 对象的各个成员变量是如何在内存中排列的，包括是否有填充字节。通过观察这些内容，你就能很清楚地理解内存的分配情况，是否有浪费或者对齐问题。

总之：GDB 和 Visual Studio 都能帮助你检查 C++ 程序中的内存布局。GDB 提供了命令行的调试方式，而 VS 提供了更加图形化、直观的调试体验。

### 六、如何优化内存布局，减少内存浪费  

在我们用 gdb 这样的工具查看对象的内存布局后，你可能会发现有一些看起来很浪费的地方，比如内存填充或者变量排列不够紧凑，这些都可能影响程序的性能或者占用不必要的内存。那么，如何优化这些布局呢？如何减少这些“空隙”呢？

这就是我们接下来的话题：**如何优化内存布局，减少内存浪费**。

我们可以通过合理地调整类中的成员变量顺序来减少填充字节的数量，达到更高效的内存布局。例如，之前在 `MyClass` 中，`char a` 和 `char c` 之间有 7 个字节的填充，因为 `double b` 占了 8 字节，这样就会造成后续的 `char c` 变量需要跳过填充区域。

如果我们把 `char` 类型的变量放在一起，这样可以减少填充空间，从而优化内存使用。简单来说，就是尽量让相同大小的变量靠在一起，避免出现填充字节。

来看看我们如何优化这个 `MyClass` 类：

```c++
class MyClass {
public:
    char a;    // 1字节
    char c;    // 1字节
    double b;  // 8字节

    MyClass() {
        a = 'A';
        b = 8.0;
        c = 'B';
    }
};
```

这里我们调整了 `a` 和 `c` 的位置，使得它们都放在一起，`double b` 则在后面。这样做的好处是，类的内存布局更加紧凑，减少了填充字节的浪费，内存占用也会更加高效。

再来看下我们编译并查看内存布局的结果：

```bash
(gdb) x/16b 0x7fffffffe2d0
0x7fffffffe2d0: 0x41    0x42    0x00    0x00    0x00    0x00    0x00    0x00
0x7fffffffe2d8: 0x00    0x00    0x00    0x00    0x00    0x00    0x20    0x40

总大小：只占 16 个字节。
```

通过这种方式，我们不仅优化了内存布局，也可能提升了程序的运行效率。总的来说，优化内存布局的核心就是避免浪费空间，尽量减少对齐的填充字节，并合理安排成员变量的顺序。

那么在实际的使用场景中，我们是否会通过调整成员变量顺序来优化内存占用？

那得看情况！具体可参考我的上一篇文章：

### 总结

搞懂内存对齐和填充，对你写高效的 C++ 代码超有帮助。简单来说，内存对齐是为了让数据存取更快，而填充就是为了让数据按照规定的方式排列。像虚函数和继承关系这些也会影响内存布局，虚函数表指针（VTable）和继承过来的成员变量都会占用额外的内存。

用 gdb 和 VS 调试，你可以直接看清楚对象在内存里的分布，找到可能的浪费或者对齐问题。优化内存布局的办法其实挺简单的，比如调整成员变量顺序、使用合适的对齐方式，这些都能帮你减少内存占用，还能提升性能。

总的来说，理解这些内存布局的小细节，不仅能帮你写出更省内存、更快的代码，调试和优化时也能省不少时间。

### 最后:

如果觉得有用，别忘了点个「赞」、点个「在看」，或分享给更多对 C++ 编程感兴趣的小伙伴！😊

也欢迎关注我的公众号「跟着小康学编程」，获取更多有趣又实用的技术干货。有问题？评论区等你，咱们一起讨论学习！技术路上不孤单，一起成长！  

## 🚀 跟我学，你能收获啥？

在这里，你不仅能看到干货，还能真正学到能用的技能：

+ **Linux 实战技巧**：服务器调优、常用命令、Shell 脚本，让你像高手一样操作系统。
+ **C/C++ 后台开发**：从基础语法到高性能编程，带你写出稳、快、可维护的服务端代码。
+ **C/C++ 项目实战**：真实项目案例，教你从需求到上线完整流程，掌握开发套路和最佳实践。
+ **常用开发工具**：调试、版本控制、构建工具、性能分析工具，让开发效率大幅提升。
+ **性能优化**：CPU/内存/IO 调优技巧，定位瓶颈，让你的程序跑得更快更稳。
+ **项目架构设计**：微服务、分层架构、模块设计思路，帮你构建可扩展、易维护的系统。
+ **Go 后端开发**：微服务、云原生实战，教你用 Go 搭建高并发、高可用系统。
+ **编程面试干货 & 算法**：核心算法套路、面试高频题解析，让你不再手忙脚乱。
+ **计算机基础梳理**：操作系统、网络、数据结构、并发原理，知识体系清晰明了。
+ **成长路线图**：系统规划你的学习路径，从初学到高级，帮你少走弯路。

内容**深入浅出、实用有趣**，再也不用看书看到睡着。  
无论是面试冲刺，还是技能升级，这里都是你的“技术加油站”。


## 👀 想加入？很简单！
**扫一扫下面二维码**，一键关注公众号，开启你的技术学习之旅！

![](https://files.mdnice.com/user/71186/0dde803d-d52f-4ed8-b74b-b7f3da5817b9.png)

另外，我还建了一个**技术交流群**，里面都是认真写代码的小伙伴，不吹牛、不闲聊，只聊技术。  
有问题？大家一块儿讨论，比一个人闷头学效率高多了！

![](https://files.mdnice.com/user/48364/4ebc72e9-e4bb-447a-9a92-8367a178df6d.png)

技术这条路，一个人走容易迷路，一群人走才有方向。  
跟上节奏，我们一起变强 💪