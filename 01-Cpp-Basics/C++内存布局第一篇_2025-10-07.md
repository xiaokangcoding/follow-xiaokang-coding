
## 前言：对象是怎么在内存中存放的？

大家好，我是小康 👋

你有没有想过，你写的 C++ 代码里，每一个对象在内存里到底长什么样？它们的成员变量是挨着放，还是零散存放？继承和虚函数会不会改变布局？

其实，了解对象的内存布局，不仅能帮你更好理解 C++ 对象模型，还能让你写出**更高效、更安全**的代码，甚至帮你避免那些难以发现的内存坑。

今天，我们就来拆开 C++ 对象的“黑盒”，看看它在内存中是怎么排布的。别担心，我会用最直观的例子让你秒懂！

> 💡 学习建议：
>
> **画图最直观**：在纸上画出对象内存布局，比单纯看代码更容易理解。
>
> **多观察 sizeof**：实验不同类成员、继承和虚函数对对象大小的影响。
>
> **结合调试器**：用调试器查看对象地址和成员偏移，会让概念更立体。
>
>想系统学习更多 C++ 知识？欢迎关注我的公众号「**跟着小康编程**」，我会持续更新 C、 C++、Linux、后端开发等高质量技术文章。也可以加我的个人微信，一起进群讨论学习！
>
> 
> <table>
> <tr>
> <td align="center">
> <img src="https://github.com/xiaokangcoding/follow-xiaokang-coding/raw/main/images/qrcode-wechat-official.png" width="200">
> <br>
> <em>公众号「跟着学小康编程」</em>
> </td>
> <td align="center">
> <img src="https://github.com/xiaokangcoding/follow-xiaokang-coding/raw/main/images/qrcode-personal-wechat.png" width="200">
> <br>
> <em>个人微信（备注：加群）</em>
> </td>
> </tr>
> </table>

### 一、内存布局是什么？

先来点简单的概念：**内存布局，就是 C++ 对象在内存中的存储方式。** 我们可以把对象看成一个“盒子”，里面放着一个个变量，而这些变量就是对象的成员变量。C++ 会根据一定的规则，安排这些成员变量在内存中怎么排布。

我们来看个简单的例子：

```C++
class MyClass {
public:
    char a;      // 1字节
    double b;    // 8字节
    char c;      // 1字节
};

```

这个类中有三个成员变量：

+ `a` 是 `char` 类型，占用 1 字节。
+ `b` 是 `double` 类型，占用 8 字节。
+ `c` 是 `char` 类型，占用 1 字节。

你可能会以为它们会按顺序紧凑地存储在内存中：`a`、`b` 紧挨着，`c` 紧接其后。但实际上，由于**内存对齐**的原因，这些成员变量的存储并不总是这么直观。

### 二、为什么要关心内存布局？
你可能会觉得：“这不就是个简单的对象吗，为什么我要关心内存布局？” 其实，**了解内存布局对程序性能的影响非常大**，尤其是在优化性能或排查内存相关问题时。

**1.内存对齐**：为了提升内存访问效率，编译器会按一定规则对齐数据，这可能会在成员变量之间插入一些“空隙”。 

**2.调试与排错**：理解内存布局可以让你在调试时更加得心应手，知道程序的内存到底是怎么分配的。

**3.优化程序**：通过调整成员变量的顺序，你可以减少内存浪费，提高效率。

### 三、成员变量和内存布局

我们先看看在默认内存对齐下，这个类的成员变量会怎样存储。

#### 内存布局分析
以 `class MyClass` 为例：

```C++
class MyClass {
public:
    char a;      // 1字节
    double b;    // 8字节
    char c;      // 1字节
};
```

+ `a`（1 字节）：从偏移量 `0` 开始存储，占用 1 字节。
+ 填充：为了满足 `double` 的 8 字节对齐要求，编译器会插入 7 个字节的填充空间。
+ `b`（8 字节）：从偏移量 `8` 开始存储，占用 8 字节。
+ `c`（1 字节）：从偏移量 `16` 开始存储，占用 1 字节。
+ 填充：为了保证整个类的大小是 `8` 的倍数（因为 `double` 是 8 字节对齐），编译器会插入 7 个字节的填充空间。

最终内存布局：

```scss
| a (1 byte) | 填充 (7 bytes) | b (8 bytes) | c (1 byte) | 填充 (7 bytes) |
```

总大小：**24 字节**。

#### 使用 `sizeof` 查看内存大小

我们可以用 `sizeof` 操作符查看对象的实际内存大小：

```C++
#include <iostream>
using namespace std;

class MyClass {
public:
    char a;      // 1字节
    double b;    // 8字节
    char c;      // 1字节
};

int main() {
    cout << "Size of MyClass: " << sizeof(MyClass) << " bytes" << endl;
    return 0;
}
```

输出结果：

```plain
Size of MyClass: 24 bytes
```

虽然 `a`、`b` 和 `c` 只占用了 `1 + 8 + 1 = 10` 字节，但由于内存对齐的原因，实际占用了 **24 字节**。

### 四、不同对齐方式的影响

为了让不同对齐方式的区别更加明显，我们可以通过 `#pragma pack` 来强制设置对齐规则：

```C++
#include <iostream>
using namespace std;

#pragma pack(4)  // 设置为 4 字节对齐
class MyClass4 {
public:
    char a;      // 1字节
    double b;    // 8字节
    char c;      // 1字节
};

#pragma pack(8)  // 设置为 8 字节对齐
class MyClass8 {
public:
    char a;      // 1字节
    double b;    // 8字节
    char c;      // 1字节
};

int main() {
    cout << "Size of MyClass4 (4-byte alignment): " << sizeof(MyClass4) << " bytes" << endl;
    cout << "Size of MyClass8 (8-byte alignment): " << sizeof(MyClass8) << " bytes" << endl;
    return 0;
}
```
程序输出：

```plain
Size of MyClass4 (4-byte alignment): 16 bytes
Size of MyClass8 (8-byte alignment): 24 bytes
```

#### 输出结果
+ **4 字节对齐**：
    - `a` 占用 1 字节，后面填充 3 字节。
    - `b` 从偏移量 `4` 开始，占用 8 字节。
    - `c` 从偏移量 `12` 开始，占用 1 字节。
    - 总大小：**16 字节**。
+ **8 字节对齐**：
    - 总大小：**24 字节**。

### 五、成员变量顺序的影响

讲完了不同对齐方式的影响，我们再来看一个更加“细节控”的话题：**类成员变量的顺序**。没错，不光对齐方式会影响内存布局，连你写代码时这些变量的顺序都会直接影响对象的大小！是不是感觉有点不可思议？别急，我们来拆解一下。

#### 成员变量的顺序真的重要吗？

你可能会想：“我随便写几个成员变量的顺序，编译器会不会自动给我安排成最优的内存布局？”答案是——不会！**C++ 编译器会严格按照你在类中声明的顺序来分配内存**，哪怕顺序可能导致更大的内存浪费。

所以，变量顺序这件事，不仅重要，而且直接决定了对象的大小。

#### 举个例子：调整变量顺序带来的影响



我们来看两个类，成员变量完全相同，但顺序不一样：

```C++
class MyClass1 {
public:
    char a;      // 1字节
    double b;    // 8字节
    char c;      // 1字节
};

class MyClass2 {
public:
    char a;      // 1字节
    char c;      // 1字节
    double b;    // 8字节
};
```

这两个类的成员变量一模一样，分别是 `char a`、`double b` 和 `char c`，只是顺序不同。那么，这两者在内存中的布局会有怎样的区别呢？

#### 内存布局分析

**第一种顺序（MyClass1）**

按照声明顺序，内存布局如下：

1. `a`：占用 1 字节，从偏移量 `0` 开始。
2. **填充**：为了满足 `double` 的 8 字节对齐要求，`a` 后面填充 7 个字节。
3. `b`：占用 8 字节，从偏移量 `8` 开始。
4. `c`：占用 1 字节，从偏移量 `16` 开始。
5. **填充**：为了使整个类的大小是 8 的倍数，填充 7 个字节。

最终内存布局：

```scss
| a (1 byte) | 填充 (7 bytes) | b (8 bytes) | c (1 byte) | 填充 (7 bytes) |
```

总大小：**24 字节**。

**第二种顺序（MyClass2）**

再看第二种顺序，内存布局如下：

1. `a`：占用 1 字节，从偏移量 `0` 开始。
2. `c`：占用 1 字节，从偏移量 `1` 开始。
3. **填充**：为了满足 `double` 的 8 字节对齐要求，`c` 后面填充 6 个字节。
4. `b`：占用 8 字节，从偏移量 `8` 开始。

最终内存布局：

```scss
| a (1 byte) | c (1 byte) | 填充 (6 bytes) | b (8 bytes) |
```

总大小：**16 字节**。

> **注意**：以上测试是在 VS2022 中完成的，系统默认采用 8 字节对齐规则，因此测试结果可能会因编译器或系统环境的不同而略有差异。

#### 为什么第二种顺序更省内存？

从布局中我们可以看出：

+ 第一种顺序：把 `char a` 和 `char c` 分开了，导致每个小变量都需要单独填充对齐。
+ 第二种顺序：把两个 `char` 类型的小变量放在一起，利用了它们的“天然紧凑性”，避免了额外的填充。

这就是**成员变量顺序优化**的威力！通过合理调整变量顺序，避免不必要的填充空间，可以有效减少内存浪费。

#### 验证代码：
我们可以用以下代码来验证这两种类的大小：

```C++
#include <iostream>
using namespace std;

class MyClass1 {
public:
    char a;      // 1字节
    double b;    // 8字节
    char c;      // 1字节
};

class MyClass2 {
public:
    char a;      // 1字节
    char c;      // 1字节
    double b;    // 8字节
};

int main() {
    cout << "Size of MyClass1: " << sizeof(MyClass1) << " bytes" << endl;
    cout << "Size of MyClass2: " << sizeof(MyClass2) << " bytes" << endl;
    return 0;
}
```

#### 输出结果：
```plain
Size of MyClass1: 24 bytes
Size of MyClass2: 16 bytes
```

从这个例子中，我们可以得出一个重要的经验：

+ **变量顺序影响内存布局**：合理调整成员变量的顺序，可以显著减少内存占用。
+ **将小变量组合在一起**：把 `char`、`short` 之类的小变量放在一起，尽量紧凑存放，减少对齐填充。

这就是为什么在设计类时，不仅要关注代码的逻辑，还要留意成员变量的顺序。看起来是个小细节，却可能对性能和内存效率产生大影响！

### 六、在实际使用中，真的会考虑成员变量顺序吗？

聊完了成员变量顺序对内存布局的影响，你可能会问：“在实际开发中，写代码的时候，我到底需不需要费心去优化这些变量顺序呢？这种优化真的有用吗？”别急，下面我会详细讲解：

#### 一般会不会考虑优化成员变量的顺序？

**答案是：看情况！**  

在大多数情况下，开发者并不会过于纠结成员变量的顺序。为什么？因为：

+ **普通业务代码优先关注逻辑**：在日常开发中，我们更多地关心代码的功能和可读性，比如按照业务逻辑将变量分组。这让代码结构更清晰，维护起来更容易。

举个例子，一个表示“用户”的类可能长这样：

```C++
class User {
public:
    // 用户信息
    string name;   // 用户名
    int age;       // 年龄
    char gender;   // 性别

    // 订单信息
    int orderCount;    // 订单数量
    double totalSpent; // 总消费金额
};

```

这里的变量顺序是按照逻辑分组来的，先是用户基本信息，然后是订单相关信息。这样一眼就能看出每个部分在描述什么。如果为了内存优化调整顺序，比如把所有 int 放在一起、char 放在最后，可能会让代码变得不直观。

更重要的是，如果这个类只会创建几百个用户对象，这点内存浪费可以完全忽略不计。

+ 现代内存不算紧张 : 今天的电脑、服务器通常都有充裕的内存空间，少浪费几个字节对大多数程序来说影响不大。与其在这种优化上花时间，不如专注于代码功能和逻辑的实现。

所以，如果你的类只是普通的业务代码数据结构，比如用户、订单之类的小对象，没必要刻意调整变量顺序。优先保持代码清晰、逻辑明确，更利于阅读和维护。

#### 什么情况下需要优化成员变量顺序？

有些场景下，优化成员变量的顺序是非常必要的：

1. **需要创建大量对象时** : 如果你的程序会创建成千上万，甚至百万个对象，这些对象的大小对内存的占用就会显著放大。

比如：

+ 游戏开发中，每个场景可能有数十万个“粒子”对象。
+ 服务端开发中，一个用户可能会对应多个对象，比如聊天消息、订单等，用户越多，对象就越多。

这时候，每节省一个字节，就可能节省几兆甚至几十兆的内存，非常有价值。

2. **嵌入式开发或内存紧张的场景** : 在嵌入式系统中，内存是极其有限的资源。比如，你的设备只有 512 KB 的内存，还要运行多个进程。在这种情况下，类的内存优化就至关重要。
3. **性能敏感的场景** :优化变量顺序不仅可以节省内存，还可能提升性能。紧凑的内存布局会减少 CPU 读取内存的开销，提升数据访问效率。

#### 优化成员变量顺序的效果到底有多大？

**效果可以非常显著！**  

通过前面的例子我们知道，不同的成员变量顺序可能让类的大小差别高达 30%-50%。当对象数量巨大时，这种优化的收益会被放大。

例如：

+ 如果一个类未优化时占用 24 字节，优化后占用 16 字节，节省了 33% 的空间。
+ 假如你有 1,000,000 个这样的对象，优化后可以节省 8 MB 的内存。

**实际收益依赖场景**：

+ 小项目，只有几百个对象：优化意义不大。
+ 大项目，有成百上千万个对象：优化收益显著。

#### 优化成员变量顺序需要注意什么？
**别为了优化牺牲可读性！**  

调整成员变量的顺序，可能让代码变得不直观。例如，你的类里逻辑上是相关的变量被拆开了，维护起来就很头疼。

**权衡的原则是：**

1. 如果是普通代码，顺序保持逻辑清晰更重要。
2. 如果是性能敏感的场景，比如游戏开发、大型系统，调整顺序节省内存是值得的。

#### 要不要优化成员变量顺序？
**一句话总结：**“小场景不用纠结，大场景慎重考虑！”

+ **小项目、少量对象**：不用特意优化，保持代码逻辑清晰就好。
+ **大型项目、大量对象**：优化变量顺序可以显著减少内存占用，是非常值得做的。

### 总结

好了，看到这里，咱们把 C++ 对象的内存布局的基础给捋清楚了。如果你之前从来没关心过这些事情，那现在是不是有种“卧槽，原来内存里还有这么多门道”的感觉？

- **内存布局是啥？** 它决定了你的对象在内存中是怎么排的，成员变量是怎么分布的，哪里要“挤一挤”，哪里需要“空一空”（填充字节）。
- **为什么要关心内存布局？** 因为它不光影响内存占用，还会直接决定程序性能！对齐方式和变量顺序不同，可能让你浪费不少内存，还影响程序效率——这可不是小事儿！
- **成员变量的顺序真的重要！** 随便写变量的顺序可能导致对象内存“大腹便便”，而合理安排顺序则能让对象变得“瘦身”，轻巧又高效。
- **工具要会用**： 多用 sizeof 和调试工具，看清楚对象到底占了多少内存，有时输出的结果会让你大吃一惊。

最后，你只需要记住一句话：**写代码不仅仅是让它“跑起来”，还要让它“跑得快、占得少”！** 了解 C++ 的内存布局，就相当于打开了通往“高效代码”的大门。

### 最后:

如果觉得这篇文章还不错，记得点个「赞」、点个「在看」，或者转发给你的朋友一起学！也欢迎关注我的公众号「跟着小康学编程」，后面咱们还会聊更有意思的内容，比如虚函数、多继承下的内存布局，甚至教你怎么通过内存布局优化程序性能。

还有啥不懂的，直接来留言区找我聊！咱们下篇再见，继续探秘 C++ 内存的“黑科技”！

## 🚀 跟我学，你能收获啥？

在这里，你不仅能看到干货，还能真正学到能用的技能：

+ **Linux 实战技巧**：服务器调优、常用命令、Shell 脚本，让你像高手一样操作系统。
+ **C/C++ 后台开发**：从基础语法到高性能编程，带你写出稳、快、可维护的服务端代码。
+ **C/C++ 项目实战**：真实项目案例，教你从需求到上线完整流程，掌握开发套路和最佳实践。
+ **常用开发工具**：调试、版本控制、构建工具、性能分析工具，让开发效率大幅提升。
+ **性能优化**：CPU/内存/IO 调优技巧，定位瓶颈，让你的程序跑得更快更稳。
+ **项目架构设计**：微服务、分层架构、模块设计思路，帮你构建可扩展、易维护的系统。
+ **Go 后端开发**：微服务、云原生实战，教你用 Go 搭建高并发、高可用系统。
+ **编程面试干货 & 算法**：核心算法套路、面试高频题解析，让你不再手忙脚乱。
+ **计算机基础梳理**：操作系统、网络、数据结构、并发原理，知识体系清晰明了。
+ **成长路线图**：系统规划你的学习路径，从初学到高级，帮你少走弯路。

内容**深入浅出、实用有趣**，再也不用看书看到睡着。  
无论是面试冲刺，还是技能升级，这里都是你的“技术加油站”。


## 👀 想加入？很简单！
**扫一扫下面二维码**，一键关注公众号，开启你的技术学习之旅！

![](https://files.mdnice.com/user/71186/0dde803d-d52f-4ed8-b74b-b7f3da5817b9.png)

另外，我还建了一个**技术交流群**，里面都是认真写代码的小伙伴，不吹牛、不闲聊，只聊技术。  
有问题？大家一块儿讨论，比一个人闷头学效率高多了！

![](https://files.mdnice.com/user/48364/4ebc72e9-e4bb-447a-9a92-8367a178df6d.png)

技术这条路，一个人走容易迷路，一群人走才有方向。  
跟上节奏，我们一起变强 💪