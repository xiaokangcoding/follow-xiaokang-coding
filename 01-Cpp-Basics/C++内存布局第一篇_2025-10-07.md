### 前言：对象是怎么在内存中存放的？

你有没想过，你写的 C++ 代码里每一个对象，它背后到底怎么在内存中存储的？你是不是觉得这个问题离你很远？其实，不管你是初学者，还是资深开发者，了解 C++ 对象的内存布局对你都非常重要！掌握了这些基本概念，不仅能让你写的代码更高效，还能帮你优化性能，避免那些潜藏的内存问题。

今天，我们就从最基础的内容开始，跟大家聊聊 C++ 对象的内存布局。你会发现，原来它并不像你想象的那么复杂，只要你耐心看下去，就能分分钟搞懂！

### 一、内存布局是什么？

先来点简单的概念：**内存布局，就是 C++ 对象在内存中的存储方式。** 我们可以把对象看成一个“盒子”，里面放着一个个变量，而这些变量就是对象的成员变量。C++ 会根据一定的规则，安排这些成员变量在内存中怎么排布。

我们来看个简单的例子：

```C++
class MyClass {
public:
    char a;      // 1字节
    double b;    // 8字节
    char c;      // 1字节
};

```

这个类中有三个成员变量：

+ `a` 是 `char` 类型，占用 1 字节。
+ `b` 是 `double` 类型，占用 8 字节。
+ `c` 是 `char` 类型，占用 1 字节。

你可能会以为它们会按顺序紧凑地存储在内存中：`a`、`b` 紧挨着，`c` 紧接其后。但实际上，由于**内存对齐**的原因，这些成员变量的存储并不总是这么直观。

### 二、为什么要关心内存布局？
你可能会觉得：“这不就是个简单的对象吗，为什么我要关心内存布局？” 其实，**了解内存布局对程序性能的影响非常大**，尤其是在优化性能或排查内存相关问题时。

**1.内存对齐**：为了提升内存访问效率，编译器会按一定规则对齐数据，这可能会在成员变量之间插入一些“空隙”。 

**2.调试与排错**：理解内存布局可以让你在调试时更加得心应手，知道程序的内存到底是怎么分配的。

**3.优化程序**：通过调整成员变量的顺序，你可以减少内存浪费，提高效率。

### 三、成员变量和内存布局

我们先看看在默认内存对齐下，这个类的成员变量会怎样存储。

#### 内存布局分析
以 `class MyClass` 为例：

```C++
class MyClass {
public:
    char a;      // 1字节
    double b;    // 8字节
    char c;      // 1字节
};
```

+ `a`（1 字节）：从偏移量 `0` 开始存储，占用 1 字节。
+ 填充：为了满足 `double` 的 8 字节对齐要求，编译器会插入 7 个字节的填充空间。
+ `b`（8 字节）：从偏移量 `8` 开始存储，占用 8 字节。
+ `c`（1 字节）：从偏移量 `16` 开始存储，占用 1 字节。
+ 填充：为了保证整个类的大小是 `8` 的倍数（因为 `double` 是 8 字节对齐），编译器会插入 7 个字节的填充空间。

最终内存布局：

```scss
| a (1 byte) | 填充 (7 bytes) | b (8 bytes) | c (1 byte) | 填充 (7 bytes) |
```

总大小：**24 字节**。

#### 使用 `sizeof` 查看内存大小

我们可以用 `sizeof` 操作符查看对象的实际内存大小：

```C++
#include <iostream>
using namespace std;

class MyClass {
public:
    char a;      // 1字节
    double b;    // 8字节
    char c;      // 1字节
};

int main() {
    cout << "Size of MyClass: " << sizeof(MyClass) << " bytes" << endl;
    return 0;
}
```

输出结果：

```plain
Size of MyClass: 24 bytes
```

虽然 `a`、`b` 和 `c` 只占用了 `1 + 8 + 1 = 10` 字节，但由于内存对齐的原因，实际占用了 **24 字节**。

### 四、不同对齐方式的影响

为了让不同对齐方式的区别更加明显，我们可以通过 `#pragma pack` 来强制设置对齐规则：

```C++
#include <iostream>
using namespace std;

#pragma pack(4)  // 设置为 4 字节对齐
class MyClass4 {
public:
    char a;      // 1字节
    double b;    // 8字节
    char c;      // 1字节
};

#pragma pack(8)  // 设置为 8 字节对齐
class MyClass8 {
public:
    char a;      // 1字节
    double b;    // 8字节
    char c;      // 1字节
};

int main() {
    cout << "Size of MyClass4 (4-byte alignment): " << sizeof(MyClass4) << " bytes" << endl;
    cout << "Size of MyClass8 (8-byte alignment): " << sizeof(MyClass8) << " bytes" << endl;
    return 0;
}
```
程序输出：

```plain
Size of MyClass4 (4-byte alignment): 16 bytes
Size of MyClass8 (8-byte alignment): 24 bytes
```

#### 输出结果
+ **4 字节对齐**：
    - `a` 占用 1 字节，后面填充 3 字节。
    - `b` 从偏移量 `4` 开始，占用 8 字节。
    - `c` 从偏移量 `12` 开始，占用 1 字节。
    - 总大小：**16 字节**。
+ **8 字节对齐**：
    - 总大小：**24 字节**。

### 五、成员变量顺序的影响

讲完了不同对齐方式的影响，我们再来看一个更加“细节控”的话题：**类成员变量的顺序**。没错，不光对齐方式会影响内存布局，连你写代码时这些变量的顺序都会直接影响对象的大小！是不是感觉有点不可思议？别急，我们来拆解一下。

#### 成员变量的顺序真的重要吗？

你可能会想：“我随便写几个成员变量的顺序，编译器会不会自动给我安排成最优的内存布局？”答案是——不会！**C++ 编译器会严格按照你在类中声明的顺序来分配内存**，哪怕顺序可能导致更大的内存浪费。

所以，变量顺序这件事，不仅重要，而且直接决定了对象的大小。

#### 举个例子：调整变量顺序带来的影响



我们来看两个类，成员变量完全相同，但顺序不一样：

```C++
class MyClass1 {
public:
    char a;      // 1字节
    double b;    // 8字节
    char c;      // 1字节
};

class MyClass2 {
public:
    char a;      // 1字节
    char c;      // 1字节
    double b;    // 8字节
};
```

这两个类的成员变量一模一样，分别是 `char a`、`double b` 和 `char c`，只是顺序不同。那么，这两者在内存中的布局会有怎样的区别呢？

#### 内存布局分析

**第一种顺序（MyClass1）**

按照声明顺序，内存布局如下：

1. `a`：占用 1 字节，从偏移量 `0` 开始。
2. **填充**：为了满足 `double` 的 8 字节对齐要求，`a` 后面填充 7 个字节。
3. `b`：占用 8 字节，从偏移量 `8` 开始。
4. `c`：占用 1 字节，从偏移量 `16` 开始。
5. **填充**：为了使整个类的大小是 8 的倍数，填充 7 个字节。

最终内存布局：

```scss
| a (1 byte) | 填充 (7 bytes) | b (8 bytes) | c (1 byte) | 填充 (7 bytes) |
```

总大小：**24 字节**。

**第二种顺序（MyClass2）**

再看第二种顺序，内存布局如下：

1. `a`：占用 1 字节，从偏移量 `0` 开始。
2. `c`：占用 1 字节，从偏移量 `1` 开始。
3. **填充**：为了满足 `double` 的 8 字节对齐要求，`c` 后面填充 6 个字节。
4. `b`：占用 8 字节，从偏移量 `8` 开始。

最终内存布局：

```scss
| a (1 byte) | c (1 byte) | 填充 (6 bytes) | b (8 bytes) |
```

总大小：**16 字节**。

> **注意**：以上测试是在 VS2022 中完成的，系统默认采用 8 字节对齐规则，因此测试结果可能会因编译器或系统环境的不同而略有差异。

#### 为什么第二种顺序更省内存？

从布局中我们可以看出：

+ 第一种顺序：把 `char a` 和 `char c` 分开了，导致每个小变量都需要单独填充对齐。
+ 第二种顺序：把两个 `char` 类型的小变量放在一起，利用了它们的“天然紧凑性”，避免了额外的填充。

这就是**成员变量顺序优化**的威力！通过合理调整变量顺序，避免不必要的填充空间，可以有效减少内存浪费。

#### 验证代码：
我们可以用以下代码来验证这两种类的大小：

```C++
#include <iostream>
using namespace std;

class MyClass1 {
public:
    char a;      // 1字节
    double b;    // 8字节
    char c;      // 1字节
};

class MyClass2 {
public:
    char a;      // 1字节
    char c;      // 1字节
    double b;    // 8字节
};

int main() {
    cout << "Size of MyClass1: " << sizeof(MyClass1) << " bytes" << endl;
    cout << "Size of MyClass2: " << sizeof(MyClass2) << " bytes" << endl;
    return 0;
}
```

#### 输出结果：
```plain
Size of MyClass1: 24 bytes
Size of MyClass2: 16 bytes
```

从这个例子中，我们可以得出一个重要的经验：

+ **变量顺序影响内存布局**：合理调整成员变量的顺序，可以显著减少内存占用。
+ **将小变量组合在一起**：把 `char`、`short` 之类的小变量放在一起，尽量紧凑存放，减少对齐填充。

这就是为什么在设计类时，不仅要关注代码的逻辑，还要留意成员变量的顺序。看起来是个小细节，却可能对性能和内存效率产生大影响！

### 六、在实际使用中，真的会考虑成员变量顺序吗？

聊完了成员变量顺序对内存布局的影响，你可能会问：“在实际开发中，写代码的时候，我到底需不需要费心去优化这些变量顺序呢？这种优化真的有用吗？”别急，下面我会详细讲解：

#### 一般会不会考虑优化成员变量的顺序？

**答案是：看情况！**  

在大多数情况下，开发者并不会过于纠结成员变量的顺序。为什么？因为：

+ **普通业务代码优先关注逻辑**：在日常开发中，我们更多地关心代码的功能和可读性，比如按照业务逻辑将变量分组。这让代码结构更清晰，维护起来更容易。

举个例子，一个表示“用户”的类可能长这样：

```C++
class User {
public:
    // 用户信息
    string name;   // 用户名
    int age;       // 年龄
    char gender;   // 性别

    // 订单信息
    int orderCount;    // 订单数量
    double totalSpent; // 总消费金额
};

```

这里的变量顺序是按照逻辑分组来的，先是用户基本信息，然后是订单相关信息。这样一眼就能看出每个部分在描述什么。如果为了内存优化调整顺序，比如把所有 int 放在一起、char 放在最后，可能会让代码变得不直观。

更重要的是，如果这个类只会创建几百个用户对象，这点内存浪费可以完全忽略不计。

+ 现代内存不算紧张 : 今天的电脑、服务器通常都有充裕的内存空间，少浪费几个字节对大多数程序来说影响不大。与其在这种优化上花时间，不如专注于代码功能和逻辑的实现。

所以，如果你的类只是普通的业务代码数据结构，比如用户、订单之类的小对象，没必要刻意调整变量顺序。优先保持代码清晰、逻辑明确，更利于阅读和维护。

#### 什么情况下需要优化成员变量顺序？

有些场景下，优化成员变量的顺序是非常必要的：

1. **需要创建大量对象时** : 如果你的程序会创建成千上万，甚至百万个对象，这些对象的大小对内存的占用就会显著放大。

比如：

+ 游戏开发中，每个场景可能有数十万个“粒子”对象。
+ 服务端开发中，一个用户可能会对应多个对象，比如聊天消息、订单等，用户越多，对象就越多。

这时候，每节省一个字节，就可能节省几兆甚至几十兆的内存，非常有价值。

2. **嵌入式开发或内存紧张的场景** : 在嵌入式系统中，内存是极其有限的资源。比如，你的设备只有 512 KB 的内存，还要运行多个进程。在这种情况下，类的内存优化就至关重要。
3. **性能敏感的场景** :优化变量顺序不仅可以节省内存，还可能提升性能。紧凑的内存布局会减少 CPU 读取内存的开销，提升数据访问效率。

#### 优化成员变量顺序的效果到底有多大？

**效果可以非常显著！**  

通过前面的例子我们知道，不同的成员变量顺序可能让类的大小差别高达 30%-50%。当对象数量巨大时，这种优化的收益会被放大。

例如：

+ 如果一个类未优化时占用 24 字节，优化后占用 16 字节，节省了 33% 的空间。
+ 假如你有 1,000,000 个这样的对象，优化后可以节省 8 MB 的内存。

**实际收益依赖场景**：

+ 小项目，只有几百个对象：优化意义不大。
+ 大项目，有成百上千万个对象：优化收益显著。

#### 优化成员变量顺序需要注意什么？
**别为了优化牺牲可读性！**  

调整成员变量的顺序，可能让代码变得不直观。例如，你的类里逻辑上是相关的变量被拆开了，维护起来就很头疼。

**权衡的原则是：**

1. 如果是普通代码，顺序保持逻辑清晰更重要。
2. 如果是性能敏感的场景，比如游戏开发、大型系统，调整顺序节省内存是值得的。

#### 要不要优化成员变量顺序？
**一句话总结：**“小场景不用纠结，大场景慎重考虑！”

+ **小项目、少量对象**：不用特意优化，保持代码逻辑清晰就好。
+ **大型项目、大量对象**：优化变量顺序可以显著减少内存占用，是非常值得做的。

### 总结

好了，看到这里，咱们把 C++ 对象的内存布局的基础给捋清楚了。如果你之前从来没关心过这些事情，那现在是不是有种“卧槽，原来内存里还有这么多门道”的感觉？

- **内存布局是啥？** 它决定了你的对象在内存中是怎么排的，成员变量是怎么分布的，哪里要“挤一挤”，哪里需要“空一空”（填充字节）。
- **为什么要关心内存布局？** 因为它不光影响内存占用，还会直接决定程序性能！对齐方式和变量顺序不同，可能让你浪费不少内存，还影响程序效率——这可不是小事儿！
- **成员变量的顺序真的重要！** 随便写变量的顺序可能导致对象内存“大腹便便”，而合理安排顺序则能让对象变得“瘦身”，轻巧又高效。
- **工具要会用**： 多用 sizeof 和调试工具，看清楚对象到底占了多少内存，有时输出的结果会让你大吃一惊。

最后，你只需要记住一句话：**写代码不仅仅是让它“跑起来”，还要让它“跑得快、占得少”！** 了解 C++ 的内存布局，就相当于打开了通往“高效代码”的大门。

### 最后:

如果觉得这篇文章还不错，记得点个「赞」、点个「在看」，或者转发给你的朋友一起学！也欢迎关注我的公众号「跟着小康学编程」，后面咱们还会聊更有意思的内容，比如虚函数、多继承下的内存布局，甚至教你怎么通过内存布局优化程序性能。

还有啥不懂的，直接来留言区找我聊！咱们下篇再见，继续探秘 C++ 内存的“黑科技”！

#### 怎么关注我的公众号？

点击下方公众号名片即可关注。

![](https://files.mdnice.com/user/48364/65158d3c-cd38-4604-861a-8f0379066dc0.png)

另外，小康还建了一个技术交流群，专门聊技术、答疑解惑。如果你在读文章时碰到不懂的地方，随时欢迎来群里提问！我会尽力帮大家解答，群里还有不少技术大佬在线支援，咱们一起学习进步，互相成长！

![](https://files.mdnice.com/user/48364/971ccaa3-8f57-4e33-8bc9-d0863eeade81.png)