
大家好，我是小康

### 前言
你有没有想过，为什么办公室里有些资料可以多人同时查阅，而一旦有人要修改，它就变得“专属”了？

在我们的程序世界里，也有类似的规则：**读者可以共享，但写者必须独占**。这套规则就是——**读写锁（Read-Write Lock）**。

今天咱们就来聊聊这个既有趣又实用的概念，用生活化的例子彻底理解它的工作方式，让你一看就懂、马上能用。

> 💡 学习建议：
> 1、动手实践：建议在自己的小程序里模拟读写锁场景，比如多个线程同时读取共享数据、一个线程写入数据，观察运行结果。
>
> 2、观察并发效果：尝试不同数量的读者和写者，看看锁的策略如何影响程序行为。 
>                    
> 如果在学习过程中遇到问题，或者想获取更多 Linux、C/C++、Go 后端开发等技术干货，欢迎关注我的公众号「跟着小康学编程」。有问题也可以添加我的个人微信交流讨论。
> 
> <table>
> <tr>
> <td align="center">
> <img src="https://github.com/xiaokangcoding/follow-xiaokang-coding/raw/main/images/qrcode-wechat-official.png" width="200">
> <br>
> <em>公众号「跟着学小康编程」</em>
> </td>
> <td align="center">
> <img src="https://github.com/xiaokangcoding/follow-xiaokang-coding/raw/main/images/qrcode-personal-wechat.png" width="200">
> <br>
> <em>个人微信（备注：加群）</em>
> </td>
> </tr>
> </table>

### 一、什么是读写锁？用“餐厅点菜”来理解
想象一家餐厅：

1. **点菜的顾客（读者线程）**
    - 顾客只是在看菜单、挑菜，并不会修改菜单上的内容。
    - 多个顾客可以同时看菜单，互不干扰。
2. **工作人员修改菜单（写者线程）**
    - 有时候工作人员要更新菜单，比如改菜价或上新菜。
    - 在修改菜单的过程中，所有顾客都**不能看菜单**，必须等厨师修改完毕。

**总结一下：**

+ 读写锁就是餐厅的“菜单管理规则”：
    - **读者共享**：多个人可以同时读，不互相干扰
    - **写者独占**：写的时候，所有读者和其他写者都得等

这样一来，程序里读取数据的操作就可以同时进行，而写操作则保证了数据一致性，避免出现“菜价半更新、顾客看错菜单”的情况 😄

### 二、为什么不用普通的互斥锁？
可能你会好奇：为啥我们不用普通的**互斥锁**呢？答案很简单：效率！

普通互斥锁是一种“无差别锁”，无论你是读还是写，都得等待。对于“读多写少”的场景，互斥锁会浪费大量时间在“等”上面。而读写锁则聪明地拆分了读和写的权限，允许多个读者同时进行阅读，只有当写者来时，才会让大家停下来等他写完。

### 三、读写锁的基本接口
在 Linux 的 `pthread` 库中，我们可以用 `pthread_rwlock_init` 来初始化一个读写锁，用 `pthread_rwlock_rdlock` 和 `pthread_rwlock_wrlock` 分别对读锁和写锁进行上锁，用 `pthread_rwlock_unlock` 来解锁。

需要注意的是，读写锁允许多个线程同时获取读锁（读取数据），但在写锁被持有时，其他线程无法获取读锁或写锁。

```c++

pthread_rwlock_t rwlock;
pthread_rwlock_init(&rwlock, NULL);  // 初始化读写锁

pthread_rwlock_rdlock(&rwlock);      // 获取读锁
// 读取共享资源
pthread_rwlock_unlock(&rwlock);      // 释放读锁

pthread_rwlock_wrlock(&rwlock);      // 获取写锁
// 修改共享资源
pthread_rwlock_unlock(&rwlock);      // 释放写锁

pthread_rwlock_destroy(&rwlock);     // 销毁读写锁
```



这样你就可以用 `pthread_rwlock_rdlock` 和 `pthread_rwlock_wrlock` 分别控制读写权限，帮助更高效地管理共享资源。

### 四、读写锁的代码示例
接下来，让我们看看读写锁在实际代码中的使用。以下是一个简单的 C 语言示例：

```c++

pthread_rwlock_t rwlock; // 声明一个读写锁
int shared_data = 0;

void* reader(void* arg) {
    pthread_rwlock_rdlock(&rwlock); // 申请读锁
    printf("Reader: Reading shared data: %d\n", shared_data);
    pthread_rwlock_unlock(&rwlock); // 释放读锁
    return NULL;
}

void* writer(void* arg) {
    pthread_rwlock_wrlock(&rwlock); // 申请写锁
    shared_data++; // 修改共享数据
    printf("Writer: Writing shared data: %d\n", shared_data);
    pthread_rwlock_unlock(&rwlock); // 释放写锁
    return NULL;
}

int main() {
    pthread_t readers[3], writer_thread;
    pthread_rwlock_init(&rwlock, NULL); // 初始化读写锁

    for (int i = 0; i < 3; i++) {
        pthread_create(&readers[i], NULL, reader, NULL); // 创建读线程
    }
    pthread_create(&writer_thread, NULL, writer, NULL); // 创建写线程

    for (int i = 0; i < 3; i++) {
        pthread_join(readers[i], NULL); // 等待读线程完成
    }
    pthread_join(writer_thread, NULL); // 等待写线程完成

    pthread_rwlock_destroy(&rwlock); // 销毁读写锁
    return 0;
}
```

在这个代码示例中，我们用了一个 **读写锁 **来控制对共享数据`shared_data`的访问：

1. **读线程 **使用`pthread_rwlock_rdlock`来获取读锁。
2. **写线程 **使用`pthread_rwlock_wrlock`来获取写锁。

当多个读线程读取数据时，它们可以同时执行，不会互相阻塞；而当写线程需要修改数据时，读线程和其他写线程都必须等待。

### 五、读写锁的优缺点
**优点**：

+ **并发性能高**：多个读线程可以同时读取数据，提高了并发性能。
+ **适合读多写少的场景**：在读操作频繁的环境下，可以减少锁争用，提高效率。

**缺点**：

+ **有可能造成“写者饥饿”**：如果读操作过多，写线程可能长时间无法获取写锁，导致“写饥饿”。
+ **适用场景有限**：在读写频率差不多或者写操作很多的场景下，读写锁的性能优势不明显。  



### 六、读写锁的应用场景：什么时候用读写锁？
读写锁的“本事”就是分开读和写的权限，适合“读多写少”的场景，让大家可以一起读，但写的时候就得让出空间。具体来说，读写锁适合下面这些情况：

1. **读的多、写的少**：如果你有个数据很多线程都需要读，只有少量线程需要改，那用读写锁就很合适。多个线程可以一起读，只有当有人要改数据时，才会让其他人暂停，比如配置文件、缓存数据等，读写锁可以让读的速度快，又不妨碍写操作。
2. **日志系统**：日志系统里，通常会有很多线程在读取日志进行分析，只有少数线程会添加新的日志内容。用读写锁，读取日志的线程可以同时工作，写日志的线程则能独占写入，避免冲突。
3. **状态信息**：有些系统里的状态信息是给多个线程读取的，比如一些共享的统计数据，读取很频繁，但更新很少。读写锁能让多个线程同时读取，而当状态需要更新时，写锁可以保证独占。



**简单说**，读写锁特别适合“读多写少”的情况。当有很多读线程需要频繁访问数据而写线程很少时，读写锁可以显著提升效率，多个读线程可以同时读取，省去了等待时间。注意，如果读和写的频率差不多，那用读写锁可能会导致写线程“饥饿”，这种情况可能就要换别的锁，比如互斥锁。

### 七、总结

读写锁是一种专为**读多写少**场景设计的锁，它灵活地允许多个读者同时读取数据，而当写者出现时，才会把其他读者排在一旁等候。使用读写锁可以有效地提升并发性能，但在设计中也要注意可能的“写饥饿”问题。

希望今天这篇文章能让你彻底理解什么是读写锁！下次遇到这类面试题，拿出你的图书馆管理员思维，从容应对！

## 最后：

如果这篇文章帮你轻松搞懂了互斥锁，记得点个在看和赞👍，也可以分享给身边的小伙伴，让更多人一起进步！另外，欢迎关注我的公众号「**跟着小康学编程**」，这里会持续更新更多编程干货，每周带你轻松掌握各种技术难点！

## 关注我能学到什么？

- 这里分享 Linux C、C++、Go 开发、计算机基础知识 和 编程面试干货等，内容深入浅出，让技术学习变得轻松有趣。

- 无论您是备战面试，还是想提升编程技能，这里都致力于提供实用、有趣、有深度的技术分享。快来关注，让我们一起成长！

## 怎么关注我的公众号？

**非常简单！扫描下方二维码即可一键关注。**

![](https://files.mdnice.com/user/71186/0dde803d-d52f-4ed8-b74b-b7f3da5817b9.png)

另外我还建了个**技术交流群**，里面都是真正在写代码的同行，不聊虚的，只聊技术。有问题大家一起讨论，比一个人闷头学效率高多了。
  
![](https://files.mdnice.com/user/48364/4ebc72e9-e4bb-447a-9a92-8367a178df6d.png)

记住，技术这条路，一个人走容易迷路，一群人走才能走得更远。




