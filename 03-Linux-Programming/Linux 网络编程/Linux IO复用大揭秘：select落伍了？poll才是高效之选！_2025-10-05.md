
# Linux Socket 编程 | I/O 复用进阶篇：彻底搞懂 poll！
大家好，我是小康 👋

还记得我们上次聊的 `select` 吗？如果说 `select` 是 Linux I/O 复用机制的入门级角色，那今天登场的 `**poll**` 就是它的进阶版兄弟——更灵活、更强大，也更贴近真实服务器开发的需求。

在并发连接数少的时候，`select` 表现还行；但一旦连接数多了，它的种种“老毛病”就暴露出来了，比如只能监控 1024 个文件描述符、每次都要重置 fd 集合、性能随连接数增多而下降……  
这时候，`poll` 闪亮登场！💥

今天这篇文章，会带你从 “啥是 poll” 到 “怎么用 poll”，全程轻松搞定不烧脑。  
准备好了吗？咱们开始进阶之旅！🚀

## 一、poll 是个啥？和 select 有啥不一样？
还记得 `select` 吧？它的核心思想是：

“我把一堆文件描述符交给你（内核），你告诉我哪些有事件。”

`poll` 其实干的也是同一件事——只是换了个更聪明的做法。


### 1. 先回顾一下 select 的缺点 🧱
`select` 的确是经典，但也确实老了，主要痛点如下：

+ **数量有限**：`select` 最多只能监听 1024 个文件描述符（FD_SETSIZE 限制），对于成百上千连接的高并发服务器就力不从心了。
+ **效率问题**：每次调用前都要重新“打包”一堆 fd 集合交给内核，哪怕其中大部分并没有变化。
+ **状态重置麻烦**：每次返回后集合都会被修改，下次再用必须重置，非常繁琐。


### 2. poll 的改进点 🚀
于是 Linux 推出了更强的 `poll`，它在机制上对 `select` 做了系统性优化：

+ ✅ **不再受 1024 限制**：支持的文件描述符数量几乎不受限制（只受系统最大打开文件数限制）。
+ ✅ **结构体数组传递 fd 信息**：使用 `struct pollfd` 数组，不需要像 `select` 那样重置 fd 集合。
+ ✅ **事件类型更丰富**：除了读、写，还可以监控错误事件（`POLLERR`）、挂断事件（`POLLHUP`）等。
+ ✅ **结果返回更直观**：哪个 fd 有事件，直接通过 `revents` 字段判断，一目了然。

可以说，`poll` 继承了 `select` 的优点，又解决了它的短板，是 I/O 复用机制的一次重要升级。

> 💡 小贴士：
>
>后续文章中，我们还会继续进化，学习 Linux 下更高效的 I/O 复用神器——`epoll`！  
>
>如果你还没看过本系列的前几篇（单进程、多进程、多线程、select 篇），建议先补一下，这样你能完整理解整个 I/O 模型的演进路线。
>
> 另外，所有源码、思维导图与学习路线图，我都整理在了 GitHub 仓库：  
>👉 [https://github.com/xiaokangcoding/follow-xiaokang-coding](https://github.com/xiaokangcoding/follow-xiaokang-coding) 
> 
> 如果在学习过程中遇到问题，或者想获取更多 Linux、C/C++、Go 后端开发等技术干货，欢迎关注我的公众号「跟着小康学编程」。有问题也可以添加我的个人微信交流讨论。
>
> <table>
> <tr>
> <td align="center">
> <img src="https://github.com/xiaokangcoding/follow-xiaokang-coding/raw/main/images/qrcode-wechat-official.png" width="200">
> <br>
> <em>公众号「跟着学小康编程」</em>
> </td>
> <td align="center">
> <img src="https://github.com/xiaokangcoding/follow-xiaokang-coding/raw/main/images/qrcode-personal-wechat.png" width="200">
> <br>
> <em>个人微信（备注：加群）</em>
> </td>
> </tr>
> </table>

## 二、poll 怎么用？从 0 到 1 完整走一遍！

好了，理论讲完，我们直接上手实战。  
接下来你将看到一个最小可运行的示例，完整展示 `poll` 的使用流程。  
我们会一步步拆解：

1. 怎么初始化 `pollfd` 数组；
2. 如何监听多个客户端；
3. 如何在事件发生时判断是哪一个 fd 出问题。

看完这一节，相信你会发现其实并不难，甚至比 `select` 还清爽！💪


### 1. 准备阶段：理解 pollfd 结构体

在 `poll` 中，我们不再用 `fd_set` 这种集合，而是用一个结构体数组 `pollfd` 来描述监控的文件描述符。每个 `pollfd` 结构体都包含以下内容：

```c++

struct pollfd {
    int fd;         // 文件描述符
    short events;   // 感兴趣的事件
    short revents;  // 实际发生的事件
};
```

这个结构体的核心就是 `events` 和 `revents`。比如，如果 `events` 设为 `POLLIN`，意思是你对这个 `fd` 上的“读事件”感兴趣。而 `revents` 是内核告诉你的结果：哪个事件真的发生了。

### 来看张图，了解下 poll 底层采用的数据结构：

![](https://files.mdnice.com/user/71186/9b567f2d-2bec-4866-8ce6-d4b6fd486f20.png)


**用户空间的 struct pollfd 数组**：

- 在用户空间（也就是我们的代码里），poll 使用一个 struct pollfd 数组来存储所有需要监控的文件描述符。
- 每个 pollfd 结构体包含三个字段：
  - **fd**：文件描述符，用于标识一个客户端连接。
  - **events**：我们感兴趣的事件类型，比如可读、可写等。
  - **revents**：实际发生的事件。这个字段在 poll 返回后更新，告诉我们哪些事件已经发生。
  
- 在数组中，每个 pollfd 结构体对应一个文件描述符，poll 会循环检查这个数组里的每个 pollfd。

**内核空间的 struct poll_list 链表**：

- 当 poll 被调用时，用户空间的 pollfd 数组会被拷贝到内核空间。
- 在内核空间，poll 使用了一个 `struct poll_list` 链表来管理这些文件描述符。每个 `poll_list` 节点包含一部分 pollfd 结构体，链表结构让内核可以更灵活地处理文件描述符，尤其是数量较多的情况。
- 这种链表结构方便内核在大规模文件描述符的情况下动态扩展空间，不会受到数组固定大小的限制。

### 2. poll 函数本身长啥样？

`poll` 的函数原型如下：

```c++

int poll(struct pollfd *fds, nfds_t nfds, int timeout);
```

各参数简单解释下：

+ `fds`：指向 `pollfd` 数组的指针，包含我们想监控的所有文件描述符。
+ `nfds`：`pollfd` 数组的长度（也就是监控的文件描述符数量）。
+ `timeout`：超时时间（以毫秒为单位），-1 表示无限等待。

返回值：

+ 正数：表示有事件发生的文件描述符数量。
+ 0：超时，没有事件发生。
+ -1：出错了。



#### 3.`poll` 的工作流程是怎样的(含图解)

poll 接口了解了，我们再来看看 poll 的工作流程：

在 `poll` 中，我们将所有需要监控的连接放进一个“监控表”—`pollfd` 数组，然后调用 `poll()` 函数。`poll()` 会持续“盯”着这些连接，看看是否有事件发生（比如某个客户端发来了新消息）。一旦有事件，`poll` 就会返回这些发生事件的连接，程序立即去处理它们，而其他没有事件的连接不会占用额外的资源(CPU资源)。  

下面我们以一个实际例子来看看 poll 的实际流程和背后的原理，帮助你更直观地理解它是如何高效工作的。

假设场景：

假设我们有一个服务器，正在监听多个客户端连接的状态。每个客户端连接用一个文件描述符（fd）来表示，比如 3、4 和 5。我们的目标是：只要有任何一个客户端发来了新消息，服务器就能第一时间知道并进行处理，而不是逐个客户端去处理。为此，我们使用 `poll` 来高效监控这些连接。

### 1. 初始化用户空间的 `pollfd` 数组
首先，我们在用户空间创建了一个 `pollfd` 数组，用来记录需要监控的文件描述符（比如，客户端连接的 `fd`）以及希望监听的事件类型。

**图解:**
```diff

+----+----------+--------+
| fd |  events  | revents|
+----+----------+--------+
| 3  | POLLIN   |   0    |
| 4  | POLLIN   |   0    |
| 5  | POLLIN   |   0    |
+----+----------+--------+
```

+ `fd`: 文件描述符，比如 3、4 和 5 表示客户端连接。
+ `events`: 我们关注的事件类型，比如 `POLLIN`（表示有数据到来）。
+ `revents`: 事件的实际情况，开始为 0，会在内核更新时填充。

这个数组就是告诉内核：“帮我盯着这些连接（3、4、5），有消息到来就通知我！”

### Step 2：调用 `poll()` 函数

设置好 `pollfd` 数组后，调用 `poll()` 函数，把数组传递给内核，让它开始监控这些文件描述符的状态。用户程序会暂停在这里等待，直到内核发现了事件发生。

**图解：**
```lua
用户空间          内核空间
+----+-----+       +----+--------+
| 程序 |--> | poll() 调用       |
+----+-----+       +----+--------+
```

### Step 3：内核开始“盯”住文件描述符（内核空间的 struct poll_list 链表）

在内核空间中，内核把传过来的 `pollfd` 数组分成若干个 `struct poll_list` 节点，每个节点中包含多个文件描述符。这些节点通过链表连接在一起，这样可以轻松支持大量文件描述符的监控。  

**内核空间的 poll_list 链表结构:**

```diff
内核空间:

+------------------------+       +------------------------+       +------------------------+
| struct poll_list 节点1 |  -->  | struct poll_list 节点2 |  -->  | struct poll_list 节点3 |
+------------------------+       +------------------------+       +------------------------+
| +----+----------+------+ |     | +----+----------+------+ |     | +----+----------+------+ |
| | fd |  events  | revents|     | | fd |  events  | revents|     | | fd |  events  | revents|
| +----+----------+------+ |     | +----+----------+------+ |     | +----+----------+------+ |
| |  3 | POLLIN   |   0   |     | |  ...          ...     |     | |  ...          ...     |
| |  4 | POLLIN   |   0   |     |                         |     |
| |  5 | POLLIN   |   0   |     |                         |     |
+------------------------+       +------------------------+       +------------------------+
```

在每个 `struct poll_list` 节点中都包含若干个 `pollfd` 结构体，它们记录了文件描述符（fd）、希望监控的事件（events）、和实际发生的事件（revents）。

**内核会“盯住”这些文件描述符**，查看它们的状态，比如是否有新数据到达。如果有数据到来，就会进行下一步。

### Step 4：事件发生，内核更新 `pollfd` 的 `revents` 字段

如果有事件发生，比如文件描述符 4 收到了新数据，内核就会把这个 `pollfd` 结构体中的 `revents` 字段更新为 `POLLIN`，标记事件的发生。

内核空间更新后的 `poll_list`节点:

```diff
内核空间:

+------------------------+       +------------------------+       +------------------------+
| struct poll_list 节点1 |  -->  | struct poll_list 节点2 |  -->  | struct poll_list 节点3 |
+------------------------+       +------------------------+       +------------------------+
| +----+----------+------+ |     | +----+----------+------+ |     | +----+----------+------+ |
| | fd |  events  | revents|     | | fd |  events  | revents|     | | fd |  events  | revents|
| +----+----------+------+ |     | +----+----------+------+ |     | +----+----------+------+ |
| |  3 | POLLIN   |   0   |     | |  ...          ...     |     | |  ...          ...     |
| |  4 | POLLIN   |POLLIN |     |                         |     |
| |  5 | POLLIN   |   0   |     |                         |     |
+------------------------+       +------------------------+       +------------------------+
```


此时，我们可以看到，只有文件描述符 4 的 `revents` 字段被标记为 `POLLIN`，表示该连接有数据到达。

### Step 5：`poll` 返回到用户空间

当 `poll` 监测到事件返回后，用户空间的 `pollfd` 数组也会被更新，显示哪些文件描述符发生了事件。用户程序可以通过检查 `revents` 字段，知道哪个文件描述符有事件发生，然后去处理它。

**图解：**

```diff
+----+----------+--------+
| fd |  events  | revents|
+----+----------+--------+
| 3  | POLLIN   |   0    |
| 4  | POLLIN   | POLLIN |
| 5  | POLLIN   |   0    |
+----+----------+--------+
```

在这个例子中，用户程序就知道 4 号客户端有新数据到达，可以去处理这个连接的数据了。

### 小结

+ `poll` 使用 `pollfd` 数组来记录需要监控的文件描述符和事件。
+ 内核会将这些描述符加载到 `struct poll_list` 链表结构中管理，方便扩展。
+ 当事件发生时，内核会更新对应的 `revents` 字段，并在 `poll` 返回时传递给用户空间。
+ 用户程序通过检查 `revents` 字段，知道哪个文件描述符有事件发生，然后进行处理。

这个过程让 `poll` 能够有效地监控多个文件描述符，比较适合用在需要处理中等规模连接的场景中。

#### 3. 实战代码示例：用 poll 实现并发服务器

接下来，让我们来看看 poll 如何实现并发服务器的：

```c++
#include <poll.h>

#define MAX_CLIENTS 100

int main() {
    int server_fd = setup_server();            // 设置服务器：创建、绑定、监听
    struct pollfd fds[MAX_CLIENTS + 1];        // 存储服务器和客户端的文件描述符

    fds[0].fd = server_fd;                     // 将服务器 socket 放入 fds[0]
    fds[0].events = POLLIN;                    // 监听新连接请求

    for (int i = 1; i <= MAX_CLIENTS; i++) {
        fds[i].fd = -1;                        // 初始化客户端位置为空
    }

    while (1) {
        poll(fds, MAX_CLIENTS + 1, -1);        // 监控所有连接的事件

        if (fds[0].revents & POLLIN) {         // 如果有新客户端连接
            int client_fd = accept(server_fd); // 接受新连接
            add_to_fds(fds, client_fd);        // 将新连接加入到 fds 数组
        }

        for (int i = 1; i <= MAX_CLIENTS; i++) {
            if (fds[i].fd != -1 && fds[i].revents & POLLIN) { // 检查各个客户端 socket 是否有数据
                int bytes = recv(fds[i].fd, buffer, sizeof(buffer), 0);
                if (bytes > 0) {
                    process_data(fds[i].fd, buffer); // 处理收到的数据
                } else {
                    close_connection(fds, i);       // 关闭断开的连接
                }
            }
        }
    }
    return 0;
}

```

#### 代码解读：

1. 初始化
+ 服务器 socket 放入 `fds[0]`：我们先把服务器的 socket 放在 `fds[0]` 位置，这样 `poll` 就可以帮我们监听有没有新客户端连接。
+ 初始化客户端数组：接下来，我们准备好一个数组 `fds`，存放每个客户端的 socket。初始化时，所有位置都设为 `-1`，表示没有人连接进来。

2. 调用 `poll()` 等待事件

+ 等待事件发生：调用 `poll()` 后，程序进入“等消息”模式，只有当服务器或客户端有事件时才会继续往下走。

3. 处理新连接

+ 接收新连接：如果 `fds[0]` 上有事件，说明有新客户端想连接，我们用 `accept()` 把这个新连接“接进来”。
+ 加入到 `fds` 数组：然后我们把新客户端的连接放到 `fds` 数组的空位置上，方便 `poll` 继续监听它的消息。

4. 处理客户端数据

+ 遍历数组，查看消息：我们检查 `fds` 数组里的每个客户端，看看有没有发消息过来。如果有，就读取并处理消息；如果客户端断开，就关闭连接并清除它的位置。

这样，通过 `poll`，我们就实现了一个可以同时管理多个客户端的聊天服务器。

> 为了不让篇幅过长，我将 select 实现的并发服务器和客户端代码放在公众号后台了，有需要的小伙伴可以微信搜索「**跟着小康学编程**」关注公众号后，在后台回复「**select**」即可获取完整代码示例。


## 三、poll 的优缺点

#### 优点

+ **文件描述符数量不限**：  
`poll` 没有像 `select` 那样的硬性数量上限（`select` 通常最多支持 1024 个文件描述符）。所以，连接的客户端数量多也不怕撑爆。不过，这个数量还是会受限于系统最大文件描述符数。
+ **支持更多事件类型**：  
`poll` 可以监控更多的事件类型，比 `select` 的“有数据可读”、“可以写数据”更丰富，像一些特殊的错误事件也可以监控。这让 `poll` 在处理需要监听多种情况的场景时很有优势。
+ **接口操作更简单，不用每次重置**：

  在 `select` 中，每次调用之前，程序都得把所有需要监控的文件描述符（比如所有客户端连接）重新放到集合  里，因为 `select` 会把这个集合改掉。也就是说，代码每次都要清空集合，然后把服务器和每个客户端的文件描述符重新加一遍，才能用 `select` 监控。

  而 `poll` 就省事得多了。它用的是一个数组（`pollfd` 数组），这个数组里的每个“格子”存了文件描述符和要监控的事件。调用 `poll` 时，这个数组不会被改动，也不需要每次重置或重新填入。你只要设定好一组文件描述符，`poll` 可以一次次复用这个数组，省下了一堆重复工作，代码也简单得多！

#### 缺点

+ **效率问题**： 每次调用 `poll`，它都会从头到尾检查整个 `pollfd` 数组里的文件描述符。文件描述符越多，检查时间越长，所以当有大量连接时，性能会下降。而 `epoll`（`poll` 的改进版）通过“事件触发机制”避免了这种效率瓶颈。
+ **无“状态记忆”**： `poll` 不会记住上一次调用时的状态，所以每次调用都要把整个 `pollfd` 数组传进去。这和 `select` 一样，都没有“记忆功能”，程序每次都要维护一个完整的监控表，很繁琐。在这方面，`epoll` 更加智能，可以在内核中保存状态，避免了每次重复传参的问题。

## 四、poll 的适用场景

`poll` 适合那些 **中等规模** 的网络应用，比如有几十、上百个乃至上千客户端的聊天室、简单的 Web 服务器等。让我们来具体看看它在哪些场景中会比较合适：

1. **多人聊天室**：如果你要做一个支持几十、上百人的聊天室，`poll` 是个不错的选择。聊天室需要监控每个客户端的消息传递，但同时大家也不会“疯狂发言”占满你的资源。这个时候，`poll` 既能高效处理多个连接，又不至于“过载”。
2. **轻量级 Web 服务器**：对于一个小型 Web 服务器来说，`poll` 也能胜任。当同时连接的用户在几百以内时，`poll` 可以帮你很好地管理这些连接。用户来了数据就处理，没数据就等着，不用每个请求都创建新线程或进程，省了不少资源。
3. **实时小规模监控系统**：比如你有一批传感器需要实时监控状态，`poll` 可以帮你随时检查每个传感器的状态。当传感器数量在几十到上百个之间时，`poll` 能轻松搞定。

如果你的应用场景中有大量的连接（比如成千上万个同时在线的客户端），`poll` 就有点力不从心了。这时 `epoll` 更适合，它可以高效处理大量的连接，尤其是“空闲连接”较多的情况。  

## 五、总结：其实 poll 没那么难！

今天我们一起把 poll 从头到尾过了一遍，是不是发现它其实没那么复杂？poll 的出现，帮我们解决了 select 的一些限制，让高并发编程多了一个选择。它的优点是比 select 更灵活，能支持更多的连接，在中等规模的并发场景下表现不错。

不过，poll 也有它的极限。当连接数越来越多时，它的性能还是会下降。这时候，就轮到我们更强的工具登场了—epoll！它是为超大规模并发设计的，性能更高，也更适合那些连接数爆炸的场景。

下次，我们就来聊聊这个更厉害的 epoll，看看它为什么是高并发的最佳选择！

如果觉得今天的内容有帮助，别忘了点赞、分享、在看！让更多小伙伴一起轻松入门 Linux I/O 复用。敬请期待后续更有趣的内容！


## 关注我能学到什么？

- 这里分享 Linux C、C++、Go 开发、计算机基础知识 和 编程面试干货等，内容深入浅出，让技术学习变得轻松有趣。

- 无论您是备战面试，还是想提升编程技能，这里都致力于提供实用、有趣、有深度的技术分享。快来关注，让我们一起成长！

## 怎么关注我的公众号？

**非常简单！扫描下方二维码即可一键关注。**

![](https://files.mdnice.com/user/71186/0dde803d-d52f-4ed8-b74b-b7f3da5817b9.png)

另外我还建了个**技术交流群**，里面都是真正在写代码的同行，不聊虚的，只聊技术。有问题大家一起讨论，比一个人闷头学效率高多了。
  
![](https://files.mdnice.com/user/48364/4ebc72e9-e4bb-447a-9a92-8367a178df6d.png)

记住，技术这条路，一个人走容易迷路，一群人走才能走得更远。


