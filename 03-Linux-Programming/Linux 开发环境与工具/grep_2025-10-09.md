## 前言：别再傻傻地翻文件了！grep 让你效率翻倍！

你有没有遇到过这种情况？

👉 日志文件太大，想找某个关键字，翻得眼花缭乱？  

👉 代码里某个变量到底在哪改的，找半天都没找到？

👉 成百上千个文件里，想找某个特定的内容，手动翻找效率太低？

如果你还在一行行地 **Ctrl + F** 查找内容，那你真的该认识一下 Linux 里最强大的查找工具——`grep`！它不仅能帮你 **快速定位** 关键内容，还能 **支持正则匹配、多文件查找、高亮显示**，让你在海量数据中一秒找到目标！

今天，我们就用 **大白话 + 实战** 带你彻底学会 `grep`，让你告别低效查找，成为 Linux 命令行高手！

## 一、grep 到底是干嘛的？

**一句话总结：** `grep` 是 Linux 里的 **文本搜索神器**，能在 **文件、日志、代码** 里 **快速搜索** 你想找的内容。

比如，你有个日志文件 `server.log`，想找出里面 **出现 “error” 的所有行**，如果你用鼠标翻，可能要几分钟，但用 `grep` 只要 **1 秒钟**：

```bash
grep "error" server.log
```

是不是很酷？接下来，我们就来看看 `grep` 的常用玩法！

## 二、最常用的 grep 语法

### 1. 基本用法：查找关键词

#### 👉 查找文件中包含某个关键词的行
```bash
grep "hello" myfile.txt
```

💡 **解释**：这个命令会在 `myfile.txt` 里查找 **包含 "hello" 的所有行**，然后把结果打印出来。

### 2. 忽略大小写

#### 👉 大小写不敏感匹配（比如 `Error` 和 `error` 都能找到）
```bash
grep -i "error" server.log
```

💡 **解释**：`-i` 让 `grep`**忽略大小写**，比如 `ERROR`、`Error`、`error`，统统都能匹配出来！

### 3. 递归查找：在多个文件中查找

#### 👉 想找某个关键词在哪个文件里出现了？

```bash
grep -r "main()" .
```

💡 **解释**：

+ `-r` 让 `grep` 进入 当前目录的所有文件和子目录 里查找 "main()"。
+ 这个对 **查找代码里的某个函数、某个变量** 非常有用！

### 4. 显示行号

#### 👉 查找时顺便显示行号，方便定位
```bash
grep -n "password" config.txt
```

💡 **解释**：`-n` 让 `grep` 显示匹配的行 **在文件里的行号**，这样你就能一眼找到它在哪。

### 5. 只显示匹配的文件

#### 👉 当你在一堆文件里找内容时，只想知道哪些文件包含这个关键词
```bash
grep -l "TODO" *.c
```

💡 **解释**：`-l` 只显示 **包含 "TODO" 的文件名**，不会输出具体匹配内容。

### 6. 反向查找（排除某些内容）
#### 👉 想找不包含某个关键词的行？
```bash
grep -v "debug" log.txt
```

💡 **解释**：`-v` 让 `grep`**排除** 包含 "debug" 的行，输出 **不含 "debug" 的内容**。

### 7. 显示匹配的上下文

#### 👉 只看匹配行可能不够，想看看前后几行内容？
```bash
grep -C 5 "error" server.log
```

💡 **解释**：`-C 5` 让 `grep`**显示匹配行前后 5 行**，这样你就能看到错误前后发生了什么。

### 8. 高亮显示匹配内容
#### 👉 让匹配的部分更醒目
```bash
grep --color "error" server.log
```

💡 **解释**：`--color` 让 `grep`**高亮显示匹配的内容**，这样你就能更快地看到关键部分。

> **注意**：加不加 --color 参数，可能显示结果都一样，因为系统默认启用了 --color=auto 参数。

### 9. 结合 `-c`，统计匹配的行数
#### 👉 统计 log.txt 里包含 "error" 的行数
```bash
grep -c "error" log.txt
```

💡 **解释**：`-c`**只统计匹配的行数**，不输出具体内容。

✅ **适用场景**：快速检查某个关键词在文件中出现的次数，比如日志里有多少行是错误信息。

### 10. 结合 `-o`，只输出匹配的关键内容

#### 👉 从日志中提取所有 IP 地址
```bash
grep -oE "[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+" logs.txt
```

💡 **解释**：

+ `-o`**只输出匹配的部分**，而不是整行内容。
+ `-E`**启用正则**，匹配 IPv4 地址。

✅ **适用场景**：当你只想提取某些关键信息时，比如 **提取 IP、URL、邮箱等**。

### 11. 结合 `-m`，限制匹配的行数

#### 👉 查找文件中的 "error"，但最多只输出前 3 行
```bash
grep -m 3 "error" server.log
```

💡 **解释**：

+ `-m 3`**最多匹配 3 行**，即使文件里有更多匹配项，也只显示 3 行。

✅ **适用场景**：当你只想看 **部分匹配内容**，避免输出太多信息时。

### 12. 结合 `-w`，精确匹配完整单词
#### 👉 只匹配完整的 "error"，不匹配 "error_code" 或 "myerror"
```bash
grep -w "error" server.log
```

💡 **解释**：

+ `-w`**匹配完整单词**，比如 "error"，但不会匹配 "myerror" 或 "error_code"。

✅ **适用场景**：查找变量名、关键字，避免匹配到无关内容。

### 13. 结合 `-F`，精准匹配，不使用正则

#### 👉 查找包含 `[ERROR]` 的日志行
```bash
grep -F "[ERROR]" logs.txt
```

💡 **解释**：

+ `-F`**把搜索内容当作普通字符串**，不会当成正则表达式解析。
+ 避免 `[ ] . * +` 这些符号被误认为正则表达式。

✅ **适用场景**：当搜索的内容包含 **特殊字符**，但你不想用正则时。

## 三、进阶用法：组合 grep 选项，让查找更高效！
在实际使用中，单独使用 `grep` 可能不够灵活，很多时候我们需要 **组合多个选项**，让 `grep` 更加强大！下面是几种常见的组合用法：

### 1. 结合 `-r` 和 `-n`，递归查找并显示行号

#### 👉 在当前目录及子目录中，查找 "error"，并显示行号
```bash
grep -rn "error" .   

// 命令解释：在当前目录 (.) 及其所有子目录中递归 (-r)，查找包含 "error" 的文件，并显示匹配的行号 (-n)。
```

💡 **解释**：`-r` 递归查找，`-n` 显示行号，方便快速定位错误位置。

### 2. 结合 `-v` 和 `-i`，排除某些内容，并忽略大小写

#### 👉 查找日志中所有包含 "warning" 但不包含 "debug" 的行

```bash
grep -i "warning" server.log | grep -v "debug"
```

💡 **解释**：

+ `-i` 让 "warning" 大小写不敏感匹配（`WARNING`、`Warning` 都能匹配）。
+ `grep -v "debug"`**把包含 "debug" 的行过滤掉**，只留下我们关心的 warning 信息。

### 3. 结合 `-l` 和 `-r`，快速找到含有关键字的文件

#### 👉 在项目目录中，找出所有包含 "TODO" 关键字的文件

```bash
grep -rl "TODO" .

命令解释：在当前目录 (.) 及其所有子目录中递归 (-r) 搜索包含 "TODO" 的文件，并仅显示匹配的文件名 (-l)，而不显示具体内容。
```

💡 **解释**：

+ `-r` 递归查找文件。
+ `-l` 只显示 **文件名**，不会显示匹配的具体内容。
+ 适用于 **查找代码里哪些文件包含某个关键词**，特别方便！

### 4. 结合 `-A` / `-B` / `-C`，按上下文查找

#### 👉 找出包含 "error" 的日志，并显示前后 5 行
```bash
grep -C 5 "error" server.log
```

#### 👉 找出包含 "error" 的日志，并显示前 5 行
```bash
grep -B 5 "error" server.log
```

#### 👉 找出包含 "error" 的日志，并显示后 5 行
```bash
grep -A 5 "error" server.log
```

💡 **解释**：

+ `-C` 让 `grep`**显示匹配行的前后 5 行**。
+ `-B` 只显示 **前 5 行**（`B` = Before）。
+ `-A` 只显示 **后 5 行**（`A` = After）。
+ 适用于 **查找某个错误发生的上下文信息**，有助于分析问题。

### 5. 结合 `|`（管道符），把 grep 结果再过滤

#### 👉 查找日志中所有 "error" 相关内容，但排除 "timeout"
```bash
grep "error" server.log | grep -v "timeout"
```

💡 **解释**：

+ 先用 `grep "error"` 找到所有包含 "error" 的行。
+ 再用 `grep -v "timeout"`**过滤掉包含 "timeout" 的行**。
+ 适用于 **日志分析、过滤关键数据**。

### 6. 结合 `-nRI`，递归查找文本文件并显示行号

#### 👉 在项目代码中查找某个函数，但忽略二进制文件
```bash
grep -nRI "init_database" .
```

💡 **解释**：

+ `-n`**显示行号**，方便快速定位。
+ `-R`**递归查找**，会进入子目录搜索所有文件。
+ `-I`**忽略二进制文件**，避免 `.o`、`.so` 这些非文本文件干扰搜索结果。

✅ **适用场景**：在 **C/C++、Python、Shell 项目** 里快速查找函数、变量的定义、以及任何其他关键词。

### 7. 结合 `xargs`，批量查找多个关键词

#### 👉场景1： 在所有 `.c` 文件中查找 "error" 或 "warning"

```bash
echo -e "error\nwarning" | xargs -I {} grep -rn {} *.c
```

💡 **解释**：

+ `echo -e "error\nwarning"` 生成 **两个关键词**。
+ `xargs -I {}` : **把关键词一个个传给 `grep` 进行匹配**。

✅ **适用场景**：当你需要 **查找多个关键词** 时，比如找 "error" 和 "warning"，但不想写多个 `grep` 命令。

#### 👉场景2：删除所有包含 "DEBUG" 的日志文件
```bash
grep -rl "DEBUG" /var/log | xargs rm -f
```

✅ **解释**：

+ `grep -rl "DEBUG" /var/log` 查找 **包含 "DEBUG"** 的日志文件
+ `xargs rm -f` 把这些文件名传给 `rm` 命令，**批量删除**

⚠️注意：此命令**不可逆**，建议先用 `grep -rl` 确认文件后再执行删除！

### 8. 结合 `tail`，实时监控日志中的关键字
#### 👉 实时监控日志，并只显示包含 "error" 的行
```bash
tail -f /var/log/syslog | grep --color "error"
```

💡 **解释**：

+ `tail -f`**持续输出最新的日志**，不需要每次手动运行。
+ `grep --color "error"`**实时匹配 "error"，并高亮显示**。

✅ **适用场景**：

+ 服务器日志实时监控，及时发现错误。
+ 监控 Web 服务器访问日志（如 `nginx`、`apache`）。

### 9. 查找日志中所有 IP 地址（并去重）

#### 👉 从日志文件中提取所有出现过的 IP 地址，并去重

```bash
grep -oE "[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+" /var/log/syslog | sort | uniq
```

💡 **解释**：

+ `-o`**只输出匹配的部分**，不会打印整行日志，只显示匹配的 IP 地址。
+ `-E`**启用扩展正则**，用于匹配 **IPv4 地址格式**（四段数字，每段 0-255 之间）。
+ `sort`**排序**，让相同的 IP 挨在一起，方便去重。
+ `uniq`**去重**，让每个 IP 只出现一次，防止重复数据干扰分析。

✅ **适用场景**：

+ 统计日志中有哪些访问 IP，分析访问来源。
+ 用于网络安全、服务器日志分析，查看可疑 IP。

如果你想 **统计每个 IP 出现的次数**，可以这样做：

```bash
grep -oE "[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+" /var/log/syslog | sort | uniq -c | sort -nr
```

💡 **解释**：

+ `uniq -c`**统计去重后的 IP 出现次数**。
+ `sort -nr`**按出现次数从高到低排序**，快速找到最常见的 IP。

✅ **适用场景**：

+ 识别 **访问频率最高的 IP**，防止恶意攻击（如 DDoS）。
+ 监控日志，分析服务器访问情况。

### 10. 结合 `grep` 和 `cut`，提取某列数据

#### 👉 场景1：从 CSV 文件中提取第二列的用户 ID，并统计不同 ID 的个数
```bash
grep "成功" logs.csv | cut -d',' -f2 | sort | uniq -c
```

💡 **解释**：

+ `grep "成功"` :先筛选出包含 "成功" 的行。
+ `cut -d',' -f2` : 提取 CSV 里用逗号分隔的第二列（假设是用户 ID）。
+ `sort | uniq -c` 统计不同用户 ID 的出现次数。

✅ **适用场景**：

+ 数据分析，统计不同用户 ID 的成功请求次数。
+ 处理日志文件，提取和筛选有用数据。

#### 👉 场景2：提取 Nginx 访问日志的 URL
**示例日志（access.log）**

```swift
192.168.1.1 - - [01/Feb/2024:12:34:56] "GET /index.html HTTP/1.1" 200 512 "-"
192.168.1.2 - - [01/Feb/2024:12:35:00] "GET /about.html HTTP/1.1" 200 432 "-"
192.168.1.3 - - [01/Feb/2024:12:35:10] "GET /contact.html HTTP/1.1" 200 654 "-"
```

📌 提取所有 GET 请求的 URL

```bash
grep "GET" access.log | cut -d'"' -f2 | cut -d' ' -f2
```

✅ **解释**：

+ `grep "GET"` 过滤出 HTTP GET 请求
+ `cut -d'"' -f2` 提取 **双引号内** 的内容
+ `cut -d' ' -f2` 提取 **第二个字段**（URL）

✅ **输出**

```bash
/index.html
/about.html
/contact.html
```

#### 📌 统计访问量最高的 URL
```bash
grep "GET" access.log | cut -d'"' -f2 | cut -d' ' -f2 | sort | uniq -c | sort -nr
```

✅ **示例输出**

```bash
5 /index.html
3 /about.html
2 /contact.html
```

💡 **实用场景**：

+ 提取网站访问的 URL
+ 统计访问次数，分析热门页面

✨ 简洁高效，适用于日志分析！🚀

### 11. 结合 `grep` 和 `find`，搜索指定类型的文件

#### 👉 在 /path 目录递归查找所有 .log 文件，并在这些文件中搜索 "关键词"，输出匹配的行。
```bash
find /path -type f -name "*.log" -exec grep "关键词" {} +
```

#### 🔍 逐步拆解
| **部分** | **作用** |
| --- | --- |
| `find /path` | 在 `/path`<br/> 目录及所有子目录中查找文件 |
| `-type f` | 只查找**普通文件**（排除目录等其他类型） |
| `-name "*.log"` | 只匹配 **.log** 结尾的文件（即日志文件） |
| `-exec` | **对查找到的文件执行后续命令** |
| `grep "关键词" {}` | 在每个找到的日志文件中搜索 `"关键词"` |
| `{}` | 代表 `find`<br/> 查找到的**文件名**，会被 `grep`<br/> 替换 |
| `+` | 批量执行`grep`<br/>，提高效率（不同于 `\;`<br/>，它会逐个执行） |


#### 🌟 例子 1：查找 `/var/log/`目录下所有 `*.log` 文件中包含 ERROR 的行

```bash
find /var/log -type f -name "*.log" -exec grep "ERROR" {} +
```

✅ **实际作用**：

+ 先在 `/var/log` 目录下查找所有 `.log` 文件
+ 然后在这些 `.log` 文件中搜索 `"ERROR"`
+ 输出包含 `"ERROR"` 的 **行 + 文件名**

**示例输出**
```pgsql
/var/log/system.log:Feb 1 12:30:22 server kernel: ERROR: Disk failure detected
```

#### 📌 `-exec` 中 `+` 和 `\;` 的区别

#### ✅ `+`（推荐）—— 批量执行，提高效率

```bash
find /var/log -type f -name "*.log" -exec grep "ERROR" {} +
```
+ `find`会尽可能把多个文件传递给 `grep`，减少命令执行次数，提高效率。
+ **等效于**

```bash
grep "ERROR" file1.log file2.log file3.log
```

#### ❌`\;` —— 每个文件执行一次，效率低

```bash
find /var/log -type f -name "*.log" -exec grep "ERROR" {} \;
```

+ `find`会对每个`*.log`文件单独执行`grep`，效率低下。
+ **等效于**

```bash
grep "ERROR" file1.log
grep "ERROR" file2.log
grep "ERROR" file3.log
```

📌 推荐使用 `+`，避免对大量文件执行 `grep` 时的性能问题！

#### 🌟 例子 2：查找 `*.log` 文件中包含`"ERROR"`，但排除 `backup.log`
```bash
find /var/log -type f -name "*.log" ! -name "backup.log" -exec grep "ERROR" {} +
```

✅ **作用**：

+ `! -name "backup.log"` 让 `find`排除`backup.log`，防止误搜

#### 🌟 例子 3：统计 `*.log` 文件中`"ERROR"` 关键词出现的次数
```bash
find /var/log -type f -name "*.log" -exec grep -c "ERROR" {} +
```

✅ **示例输出**

```pgsql
/var/log/nginx/access.log: 15
/var/log/system.log: 3
```

📌 `grep -c` 统计 `"ERROR"` 出现的次数，适用于日志分析。

### 12. 结合 `grep` 和 `head`，只显示最前面的匹配结果

#### 👉 在日志文件中查找 "error"，只显示最早的 5 行
```bash
grep -i "error" /var/log/syslog | head -5
```

💡 **解释**：

+ `grep -i "error"`**找出所有包含 "error" 的行**。
+ `head -5` 只显示前 5 行，避免输出太多内容。

✅ **适用场景**：

+ 只想看看 **最早发生的错误**，不关心后面的记录。

### 13. 结合 `grep` 和 `diff`，对比两个文件的不同之处

#### 👉 对比 `file1.log` 和 `file2.log`，只显示不同的行
```bash
grep -v -f file1.log file2.log
```

💡 **解释**：

+ `-f file1.log`将 `file1.log` 里的内容作为匹配模板。
+ `grep -v`排除所有在 `file1.log` 里已经存在的行，最终显示 `file2.log` 里有但 `file1.log` 里没有的内容。

✅ **适用场景**：

+ 比较两个日志文件的不同，找出新增的错误或信息。

### 14. 结合 `grep` 和 `wc`，统计不同关键词的出现次数

#### 👉 统计日志中 "error"、"warning"、"failed" 出现的次数
```bash
grep -E "error|warning|failed" /var/log/syslog | wc -l
```

💡 **解释**：

+ `grep -E "error|warning|failed"`**匹配多个关键词（支持正则表达式）**。
+ `wc -l`**统计匹配到的行数**，让你知道这些关键词在日志里出现了多少次。

✅ **适用场景**：

+ 统计关键日志事件的发生频率，判断是否有严重问题。

### 15. 结合 `grep` 和 `tee`，同时输出匹配结果到终端和文件

#### 👉 查找日志中的 "error"，并保存到 `error.log`

```bash
grep -i "error" /var/log/syslog | tee error.log
```

💡 **解释**：

+ `grep -i "error"`**查找所有错误信息**。
+ `tee error.log`**把结果同时输出到终端和 `error.log` 文件**，方便后续分析。

✅ **适用场景**：

+ 需要 **实时查看匹配结果，同时保存到文件** 以备后续分析。

### 16. `grep` + `sort | uniq`：统计匹配内容

#### 👉 统计 `server.log` 中出现的所有错误类型
```bash
grep "ERROR" server.log | awk '{print $2}' | sort | uniq -c
```

✅ **解释**：

+ `grep "ERROR" server.log` 先找出所有包含 `"ERROR"` 的行
+ `awk '{print $2}'` 提取 **第二列**（假设错误类型在第二列）
+ `sort` 排序
+ `uniq -c` 统计每种错误类型出现的次数

💡 **实用场景**：统计日志中各种错误的发生频率，快速定位高频错误。

### 17. 结合 `sed`，批量替换文本
#### 👉 批量替换日志中的 "error" 为 "ERROR"
```bash
grep -l "error" *.log | xargs sed -i 's/error/ERROR/g'
```

💡 **解释**：

+ `grep -l "error" *.log` : **找到所有包含 "error" 的日志文件**。
+ `xargs sed -i 's/error/ERROR/g'` : 逐个修改这些文件，将 "error" 变成 "ERROR"。

✅ **适用场景**：

+ **批量修改** 文件中的内容，避免手动修改多个文件。

### 18. 结合 `awk`，提取关键信息

#### 👉 从 `access.log` 里提取访问 IP

```bash
grep "200" access.log | awk '{print $1}' | sort | uniq -c | sort -nr
```

💡 **解释**：

+ `grep "200"` : **筛选返回状态码 200（成功访问） 的日志**。
+ `awk '{print $1}'` : **提取日志中的第 1 列（通常是 IP 地址）**。
+ `sort | uniq -c` : **统计每个 IP 访问次数**。
+ `sort -nr` : **按访问次数从高到低排序**。

✅ **适用场景**：

+ 分析 **网站访问来源**，识别热门 IP。
+ 识别恶意爬虫，发现异常高频 IP。

### 19. `grep` + `ps`：查找正在运行的进程
#### 👉：检查系统中是否有 `nginx` 进程运行
```bash
ps aux | grep "nginx"
```

✅ **解释**：

+ `ps aux` 列出所有运行的进程
+ `grep "nginx"` 过滤出包含 `"nginx"` 的进程

🚀 **更精确的用法**（排除 `grep` 自己）

```bash
ps aux | grep nginx | grep -v grep
或
ps aux | grep "[n]ginx"
```

📌 这里的 `[n]ginx` 是一个小技巧，避免 `grep` 命令本身出现在结果中。

### 20. `grep` + `netstat` / `ss`：查看端口占用
#### 👉：查找正在使用 8080 端口的进程
```bash
netstat -tulnp | grep "8080"
```

✅ **解释**：

+ `netstat -tulnp` 显示所有监听的端口
+ `grep "8080"` 过滤出使用 8080 端口的进程

📌 如果 `netstat` 不可用，可以用 `ss` 代替：

```bash
ss -tulnp | grep "8080"
```

💡 **实用场景**：排查端口占用问题，确认某个端口是否被某个进程占用。

## 四、总结：学会 grep，你的查找效率起飞！

`grep` 是一个超级实用的工具，掌握以下几个最常用的参数，你的查找效率绝对提升 10 倍。

### 📌常用语法：

✅ `grep "关键词" 文件` —— 查找文件中的内容  
✅ `grep -i "关键词" 文件` —— 忽略大小写  
✅ `grep -r "关键词" 目录` —— 递归查找文件夹中的内容  
✅ `grep -n "关键词" 文件` —— 显示匹配的行号  
✅ `grep -v "关键词" 文件` —— 反向查找，不包含关键词的行  
✅ `grep -C 3 "关键词" 文件` —— 显示前后 3 行内容  
✅ `grep --color "关键词" 文件` —— 高亮显示匹配的内容

### 📌 进阶用法：组合 `grep` 选项，让查找更高效！

✅ `grep -rn "关键词" .` —— 递归查找文件，并显示行号  
✅ `grep -ri "关键词" .` —— 递归查找，并忽略大小写  
✅ `grep -rl "关键词" .` —— 递归查找，只显示匹配的文件名  
✅ `grep -A 3 "关键词" 文件` —— 显示匹配行及 **后 3 行**  
✅ `grep -B 5 "关键词" 文件` —— 显示匹配行及 **前 5 行**  
✅ `grep -C 2 "关键词" 文件` —— 显示匹配行的 **前后 2 行**  
✅ `grep -c "关键词" 文件` —— 统计 **匹配行的数量**  
✅ `grep -o "关键词" 文件` —— 只显示匹配的 **关键词**，不输出整行  
✅ `grep -m 5 "关键词" 文件` —— **限制** 输出最多 5 行匹配内容  
✅ `grep -w "关键词" 文件` —— 精确匹配完整单词，不匹配部分字符  
✅ `grep -F "关键词" 文件` —— 纯文本匹配，不使用正则表达式  
✅ `grep "关键词" 文件 | grep "其他关键词"` —— **多次过滤**，筛选更精准  
✅ `grep "关键词" 文件 | sort | uniq -c | sort -nr` —— 统计关键词出现次数  
✅ `grep -r "关键词" /path | xargs grep "其他关键词"` —— **批量搜索多个关键词**  
✅ `grep "关键词" 文件 | tee output.log` —— **同时输出到终端和文件**  
✅ `grep "关键词" 文件 | cut -d' ' -f2` —— **提取特定字段**（如 URL）  
✅ `find /path -type f -name "*.log" -exec grep "关键词" {} +` —— **按文件类型搜索**  
✅ `ps aux | grep "nginx"` —— 查找 **正在运行的进程**  
✅ `netstat -tulnp | grep "8080"` —— 查找 **被占用的端口**  
✅ `tail -f 文件 | grep "关键词"` —— **实时监控日志**，过滤关键内容  
✅ `diff <(grep "关键词" 文件1) <(grep "关键词" 文件2)` —— **对比两个文件的匹配差异**

觉得有收获的话，记得点个「赞」👍 点个「在看」👀，顺便分享给你的小伙伴们，一起学编程！😉

如果你还想继续挖掘更多编程技巧，快来关注我的公众号「跟着小康学编程」，这里有一堆干货等着你！有问题或者想聊的，评论区见！技术的路上，我们一起走，大家一起进步，绝对不孤单！💪

### 下一步，掌握 `sed` 和 `awk`，玩转文本处理！

`grep` 适合查找文本，而在 Linux 世界里，**修改和格式化文本** 还需要两个更强大的工具：`sed` 和 `awk`。

+ `sed`：强大的 **文本编辑器**，可以 **批量替换、删除、修改** 内容。
+ `awk`：强大的 **文本处理工具**，适用于 **数据提取、格式化、统计**。

在下一篇文章里，我们将深入学习 `sed` 和 `awk`，看看它们如何让文本处理变得更简单高效！📖🔍


#### 怎么关注我的公众号？

点击下方公众号名片即可关注。

![](https://files.mdnice.com/user/48364/65158d3c-cd38-4604-861a-8f0379066dc0.png)

另外，小康还建了一个技术交流群，专门聊技术、答疑解惑。如果你在读文章时碰到不懂的地方，随时欢迎来群里提问！我会尽力帮大家解答，群里还有不少技术大佬在线支援，咱们一起学习进步，互相成长！

![](https://files.mdnice.com/user/48364/971ccaa3-8f57-4e33-8bc9-d0863eeade81.png)